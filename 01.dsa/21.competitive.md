# Advanced Competitive Programming Techniques

## Table of Contents
1. [Advanced Techniques Overview](#advanced-techniques-overview)
2. [Meet in the Middle](#meet-in-the-middle)
3. [Meet in the Middle: Applications](#meet-in-the-middle-applications)
4. [Binary Lifting](#binary-lifting)
5. [Binary Lifting: LCA](#binary-lifting-lca)
6. [Binary Lifting: Kth Ancestor](#binary-lifting-kth-ancestor)
7. [DSU on Tree](#dsu-on-tree)
8. [Policy-Based Data Structures](#policy-based-data-structures)
9. [Order Statistics Tree](#order-statistics-tree)
10. [Common Problems](#common-problems)

---

## Advanced Techniques Overview

### Optimization Techniques

**These techniques optimize brute force solutions:**

| Technique | Optimization | Typical Use |
|-----------|--------------|-------------|
| **Meet in the Middle** | O(2^n) ‚Üí O(2^(n/2)) | Subset problems |
| **Binary Lifting** | O(n) ‚Üí O(log n) | Tree queries |
| **DSU on Tree** | O(n¬≤) ‚Üí O(n log n) | Subtree queries |

### When to Use Each

**Meet in the Middle:**
‚úÖ Subset sum/search problems  
‚úÖ n ‚â§ 40 (too large for 2^n)  
‚úÖ Can split into two independent parts

**Binary Lifting:**
‚úÖ Tree ancestor queries  
‚úÖ LCA (Lowest Common Ancestor)  
‚úÖ Path queries on trees

**DSU on Tree:**
‚úÖ Subtree statistics  
‚úÖ Color counting  
‚úÖ Distinct elements in subtree

---

## Meet in the Middle

### What is Meet in the Middle?

**Optimization:** Split problem into two halves, solve separately, combine.

**Key insight:** 2^40 is too large, but 2^20 √ó 2 is manageable!

```
Brute force: O(2^n)

Meet in the middle:
  - Split into two sets of size n/2
  - Generate all subsets of each half
  - Combine results
  
Complexity: O(2^(n/2))
```

### Classic Problem: Subset Sum

**Given:** Array of n integers, target sum T  
**Find:** Is there a subset summing to T?

**Naive:** Try all 2^n subsets ‚Üí too slow for n=40

**Meet in the middle:**
1. Split array into two halves
2. Generate all subset sums of left half
3. Generate all subset sums of right half
4. For each sum in left, check if (T - sum) exists in right

### How It Works

**Visual:**
```
Array: [1, 2, 3, 4, 5, 6]
Target: 10

Split:
  Left:  [1, 2, 3]
  Right: [4, 5, 6]

Left subsets and sums:
  {} ‚Üí 0
  {1} ‚Üí 1
  {2} ‚Üí 2
  {3} ‚Üí 3
  {1,2} ‚Üí 3
  {1,3} ‚Üí 4
  {2,3} ‚Üí 5
  {1,2,3} ‚Üí 6

Right subsets and sums:
  {} ‚Üí 0
  {4} ‚Üí 4
  {5} ‚Üí 5
  {6} ‚Üí 6
  {4,5} ‚Üí 9
  {4,6} ‚Üí 10  ‚Üê Found!
  {5,6} ‚Üí 11
  {4,5,6} ‚Üí 15

For target 10:
  Left sum 0 ‚Üí need 10 from right ‚úì (exists: {4,6})
  
Solution: {} ‚à™ {4,6} = {4,6}
```

### Implementation

```cpp
bool subsetSumMeetInMiddle(vector<int>& arr, int target) {
    int n = arr.size();
    int mid = n / 2;
    
    // Generate all subset sums for left half
    vector<int> leftSums;
    for (int mask = 0; mask < (1 << mid); mask++) {
        int sum = 0;
        for (int i = 0; i < mid; i++) {
            if (mask & (1 << i)) {
                sum += arr[i];
            }
        }
        leftSums.push_back(sum);
    }
    
    // Sort for binary search
    sort(leftSums.begin(), leftSums.end());
    
    // Generate right sums and check
    for (int mask = 0; mask < (1 << (n - mid)); mask++) {
        int sum = 0;
        for (int i = 0; i < n - mid; i++) {
            if (mask & (1 << i)) {
                sum += arr[mid + i];
            }
        }
        
        int needed = target - sum;
        if (binary_search(leftSums.begin(), leftSums.end(), needed)) {
            return true;
        }
    }
    
    return false;
}
```

### Complete Trace

```
arr = [2, 3, 5, 7]
target = 10

Split: mid = 2
  Left:  [2, 3]
  Right: [5, 7]

Left subsets (2^2 = 4):
  mask=00: sum = 0
  mask=01: sum = 2
  mask=10: sum = 3
  mask=11: sum = 5
  
leftSums = [0, 2, 3, 5]

Right subsets (2^2 = 4):
  mask=00: sum = 0, needed = 10
    Binary search 10 in [0,2,3,5]? NO
  
  mask=01: sum = 5, needed = 5
    Binary search 5 in [0,2,3,5]? YES ‚úì
    
Solution found: left subset {} (sum=0) + right subset {5} doesn't work
Actually: left subset {5} is from {2,3}, right subset {5} is from {5}
Wait, let me recalculate...

Actually mask=11 for left gives {2,3} with sum 5
mask=01 for right gives {5} with sum 5
needed = 10 - 5 = 5
5 exists in leftSums ‚úì

Solution: {2,3} ‚à™ {5} = {2,3,5} with sum 10 ‚úì
```

**Time:** O(2^(n/2) √ó log(2^(n/2))) = O(2^(n/2) √ó n)  
**Space:** O(2^(n/2))

---

## Meet in the Middle: Applications

### Problem 1: Closest Subset Sum

**Find:** Subset sum closest to target T

```cpp
int closestSubsetSum(vector<int>& arr, int target) {
    int n = arr.size();
    int mid = n / 2;
    
    // Generate left sums
    vector<int> leftSums;
    for (int mask = 0; mask < (1 << mid); mask++) {
        int sum = 0;
        for (int i = 0; i < mid; i++) {
            if (mask & (1 << i)) sum += arr[i];
        }
        leftSums.push_back(sum);
    }
    
    sort(leftSums.begin(), leftSums.end());
    
    int closest = INT_MAX;
    
    // Generate right sums and find closest
    for (int mask = 0; mask < (1 << (n - mid)); mask++) {
        int sum = 0;
        for (int i = 0; i < n - mid; i++) {
            if (mask & (1 << i)) sum += arr[mid + i];
        }
        
        int needed = target - sum;
        
        // Find closest in leftSums
        auto it = lower_bound(leftSums.begin(), leftSums.end(), needed);
        
        if (it != leftSums.end()) {
            closest = min(closest, abs(target - (sum + *it)));
        }
        if (it != leftSums.begin()) {
            --it;
            closest = min(closest, abs(target - (sum + *it)));
        }
    }
    
    return closest;
}
```

### Problem 2: 4-Sum (Meet in the Middle)

```cpp
vector<vector<int>> fourSum(vector<int>& nums, int target) {
    int n = nums.size();
    set<vector<int>> result;
    
    // Generate all pairs and their sums
    map<long long, vector<pair<int, int>>> pairSums;
    
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            long long sum = (long long)nums[i] + nums[j];
            pairSums[sum].push_back({i, j});
        }
    }
    
    // For each pair, check if complement exists
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            long long sum = (long long)nums[i] + nums[j];
            long long needed = target - sum;
            
            if (pairSums.find(needed) != pairSums.end()) {
                for (auto& p : pairSums[needed]) {
                    // Ensure no index overlap
                    if (p.first != i && p.first != j && 
                        p.second != i && p.second != j) {
                        vector<int> quad = {nums[i], nums[j], 
                                          nums[p.first], nums[p.second]};
                        sort(quad.begin(), quad.end());
                        result.insert(quad);
                    }
                }
            }
        }
    }
    
    return vector<vector<int>>(result.begin(), result.end());
}
```

### Problem 3: Partition into Equal Sum Subsets

```cpp
bool canPartition(vector<int>& arr) {
    int total = accumulate(arr.begin(), arr.end(), 0);
    if (total % 2 != 0) return false;
    
    return subsetSumMeetInMiddle(arr, total / 2);
}
```

---

## Binary Lifting

### What is Binary Lifting?

**Precompute ancestors at powers of 2 distances.**

**Key idea:** Any distance k can be represented in binary!

```
Jump 13 steps = jump 8 + 4 + 1 steps
              = jump 2¬≥ + 2¬≤ + 2‚Å∞ steps

13 = 1101‚ÇÇ
```

### How Binary Lifting Works

**up[node][k] = 2^k-th ancestor of node**

**Build table:**
```
up[node][0] = parent[node]  (1st ancestor = parent)

up[node][k] = up[up[node][k-1]][k-1]

Why?
  2^k-th ancestor = go up 2^(k-1) steps twice!
  
  Example: 8th ancestor
    = 4th ancestor of 4th ancestor
    up[node][3] = up[up[node][2]][2]
```

**Visual:**
```
        0
       / \
      1   2
     / \   \
    3   4   5
   /
  6

up table:
       k=0  k=1  k=2
node   (1)  (2)  (4)
  0     -    -    -
  1     0    -    -
  2     0    -    -
  3     1    0    -
  4     1    0    -
  5     2    0    0
  6     3    1    0

up[6][0] = 3  (parent)
up[6][1] = 1  (2nd ancestor: up[3][0])
up[6][2] = 0  (4th ancestor: up[1][1])
```

### Implementation

```cpp
class BinaryLifting {
    vector<vector<int>> up;
    vector<int> depth;
    int LOG;
    
public:
    BinaryLifting(vector<vector<int>>& tree, int root = 0) {
        int n = tree.size();
        LOG = ceil(log2(n)) + 1;
        
        up.assign(n, vector<int>(LOG, -1));
        depth.assign(n, 0);
        
        dfs(tree, root, -1);
    }
    
    void dfs(vector<vector<int>>& tree, int node, int parent) {
        up[node][0] = parent;
        
        // Build up table
        for (int k = 1; k < LOG; k++) {
            if (up[node][k-1] != -1) {
                up[node][k] = up[up[node][k-1]][k-1];
            }
        }
        
        for (int child : tree[node]) {
            if (child != parent) {
                depth[child] = depth[node] + 1;
                dfs(tree, child, node);
            }
        }
    }
    
    int kthAncestor(int node, int k) {
        for (int i = 0; i < LOG; i++) {
            if (k & (1 << i)) {
                node = up[node][i];
                if (node == -1) return -1;
            }
        }
        return node;
    }
};
```

### Complete Trace

```
Tree:       0
           / \
          1   2
         /     \
        3       4
       /
      5

DFS from root 0:

Visit 0:
  up[0][0] = -1 (no parent)
  up[0][k] = -1 for all k
  depth[0] = 0

Visit 1:
  up[1][0] = 0
  up[1][1] = up[0][0] = -1
  depth[1] = 1

Visit 3:
  up[3][0] = 1
  up[3][1] = up[1][0] = 0
  up[3][2] = up[0][1] = -1
  depth[3] = 2

Visit 5:
  up[5][0] = 3
  up[5][1] = up[3][0] = 1
  up[5][2] = up[1][1] = -1
  depth[5] = 3

Query: 3rd ancestor of node 5
  k = 3 = 011‚ÇÇ
  
  Bit 0 (2^0 = 1): set
    node = up[5][0] = 3
  
  Bit 1 (2^1 = 2): set
    node = up[3][1] = 0
  
  Result: 0 ‚úì

Verification: 5 ‚Üí 3 ‚Üí 1 ‚Üí 0 (3 steps)
```

**Time:**
- Preprocess: O(n log n)
- Query: O(log n)

**Space:** O(n log n)

---

## Binary Lifting: LCA

### Lowest Common Ancestor

**LCA(u, v) = deepest node that is ancestor of both u and v**

**Visual:**
```
        0
       / \
      1   2
     / \   \
    3   4   5
   /
  6

LCA(6, 4) = 1
LCA(6, 5) = 0
LCA(3, 4) = 1
```

### How LCA with Binary Lifting Works

**Algorithm:**
1. Bring both nodes to same depth
2. Binary search for LCA (jump upward simultaneously)

**Why it works:**
```
If u and v at same depth:
  - Jump both up by 2^k while ancestors differ
  - When they meet, we've gone too far
  - Parent of current position is LCA
```

### Implementation

```cpp
class LCA {
    vector<vector<int>> up;
    vector<int> depth;
    int LOG;
    
    void dfs(vector<vector<int>>& tree, int node, int parent) {
        up[node][0] = parent;
        
        for (int k = 1; k < LOG; k++) {
            if (up[node][k-1] != -1) {
                up[node][k] = up[up[node][k-1]][k-1];
            }
        }
        
        for (int child : tree[node]) {
            if (child != parent) {
                depth[child] = depth[node] + 1;
                dfs(tree, child, node);
            }
        }
    }
    
public:
    LCA(vector<vector<int>>& tree, int root = 0) {
        int n = tree.size();
        LOG = ceil(log2(n)) + 1;
        
        up.assign(n, vector<int>(LOG, -1));
        depth.assign(n, 0);
        
        dfs(tree, root, -1);
    }
    
    int lca(int u, int v) {
        // Bring to same depth
        if (depth[u] < depth[v]) swap(u, v);
        
        int diff = depth[u] - depth[v];
        for (int i = 0; i < LOG; i++) {
            if (diff & (1 << i)) {
                u = up[u][i];
            }
        }
        
        if (u == v) return u;
        
        // Binary search for LCA
        for (int k = LOG - 1; k >= 0; k--) {
            if (up[u][k] != up[v][k]) {
                u = up[u][k];
                v = up[v][k];
            }
        }
        
        return up[u][0];
    }
    
    int distance(int u, int v) {
        return depth[u] + depth[v] - 2 * depth[lca(u, v)];
    }
};
```

### Complete Trace

```
Tree:       0 (depth 0)
           / \
          1   2 (depth 1)
         / \   \
        3   4   5 (depth 2)
       /
      6 (depth 3)

up table:
       k=0  k=1  k=2
  0    -1   -1   -1
  1     0   -1   -1
  2     0   -1   -1
  3     1    0   -1
  4     1    0   -1
  5     2    0    0
  6     3    1    0

Query: LCA(6, 4)

Step 1: Bring to same depth
  depth[6] = 3, depth[4] = 2
  diff = 1 = 001‚ÇÇ
  
  Bit 0 set: u = up[6][0] = 3
  Now u=3, v=4, both at depth 2

Step 2: Binary search
  k=2: up[3][2] = -1, up[4][2] = -1 (same, skip)
  k=1: up[3][1] = 0, up[4][1] = 0 (same, skip)
  k=0: up[3][0] = 1, up[4][0] = 1 (same, skip)
  
  No jumps made, so u=3, v=4 still
  Wait, let me recalculate...

Actually:
  u=3, v=4 at depth 2
  
  k=2: up[3][2]=-1, skip
  k=1: up[3][1]=0, up[4][1]=0, same, skip
  k=0: up[3][0]=1, up[4][0]=1, same, skip
  
  Since they never jumped, check if u==v? No
  
  Return up[u][0] = up[3][0] = 1 ‚úì

LCA(6, 4) = 1 ‚úì
```

**Time:** O(log n) per query  
**Space:** O(n log n)

---

## Binary Lifting: Kth Ancestor

### Kth Ancestor Query

**Given:** Node u and distance k  
**Find:** k-th ancestor of u

**This is exactly what binary lifting was designed for!**

### Implementation

```cpp
int kthAncestor(int node, int k) {
    // Decompose k into binary
    for (int i = 0; i < LOG; i++) {
        if (k & (1 << i)) {
            node = up[node][i];
            if (node == -1) return -1;
        }
    }
    return node;
}
```

### Path Queries

**Query on path from u to v:**

```cpp
int pathQuery(int u, int v, vector<int>& values) {
    int l = lca(u, v);
    
    // Query from u to l
    int result = 0;
    int curr = u;
    while (curr != l) {
        result += values[curr];  // Or any operation
        curr = up[curr][0];
    }
    
    // Query from v to l
    curr = v;
    while (curr != l) {
        result += values[curr];
        curr = up[curr][0];
    }
    
    result += values[l];
    
    return result;
}
```

---

## DSU on Tree

### What is DSU on Tree?

**Small to Large technique on tree subtrees.**

**Problem:** Count distinct colors in each subtree.

**Naive:** For each node, DFS entire subtree ‚Üí O(n¬≤)

**DSU on Tree:** Reuse calculations from heavy child ‚Üí O(n log n)

### How DSU on Tree Works

**Key insight:**
```
Light children: small subtrees ‚Üí count separately
Heavy child: largest subtree ‚Üí keep its data!

For each node:
  1. Process all light children (add to global counter, then remove)
  2. Process heavy child (keep data)
  3. Add light children's data back
  4. Compute answer for current node
```

**Why it works:**
```
Each node is "light" at most O(log n) times!
(Each time it moves up, parent's subtree ‚â• 2√ó larger)

Total work: O(n log n)
```

### Visual Example

```
Tree with colors:
        0(red)
       / \
      1   2(blue)
    (red) |
    / \   3(green)
   4   5
 (blue)(red)

Subtree sizes:
  0: 6
  1: 3 (heavy child of 0)
  2: 2 (light child of 0)
  4: 1
  5: 1
  3: 1

Process node 0:
  1. Process light child 2:
     - Add colors from subtree of 2: {blue, green}
     - Count = 2
     - Remove colors
  
  2. Process heavy child 1:
     - Add colors from subtree of 1: {red, blue}
     - KEEP THIS DATA
  
  3. Re-add light child 2:
     - Add {blue, green} back
  
  4. Add node 0's color: {red}
  
  Final colors in subtree of 0: {red, blue, green}
  Answer: 3 distinct colors
```

### Implementation

```cpp
class DSUonTree {
    vector<vector<int>> tree;
    vector<int> color;
    vector<int> subtreeSize;
    vector<int> answer;
    
    map<int, int> cnt;  // color ‚Üí count
    int distinctColors;
    
    void calcSize(int node, int parent) {
        subtreeSize[node] = 1;
        for (int child : tree[node]) {
            if (child != parent) {
                calcSize(child, node);
                subtreeSize[node] += subtreeSize[child];
            }
        }
    }
    
    void add(int node, int parent, int delta) {
        cnt[color[node]] += delta;
        if (delta > 0 && cnt[color[node]] == 1) distinctColors++;
        if (delta < 0 && cnt[color[node]] == 0) distinctColors--;
        
        for (int child : tree[node]) {
            if (child != parent) {
                add(child, node, delta);
            }
        }
    }
    
    void dsu(int node, int parent, bool keep) {
        // Find heavy child
        int heavyChild = -1;
        int maxSize = 0;
        
        for (int child : tree[node]) {
            if (child != parent && subtreeSize[child] > maxSize) {
                maxSize = subtreeSize[child];
                heavyChild = child;
            }
        }
        
        // Process light children
        for (int child : tree[node]) {
            if (child != parent && child != heavyChild) {
                dsu(child, node, false);  // Don't keep
            }
        }
        
        // Process heavy child
        if (heavyChild != -1) {
            dsu(heavyChild, node, true);  // Keep data
        }
        
        // Add light children and current node
        for (int child : tree[node]) {
            if (child != parent && child != heavyChild) {
                add(child, node, 1);
            }
        }
        add(node, parent, 1);  // Don't recurse, just current node
        
        // Store answer
        answer[node] = distinctColors;
        
        // Remove data if not keeping
        if (!keep) {
            add(node, parent, -1);
        }
    }
    
public:
    vector<int> solve(vector<vector<int>>& tree_, vector<int>& color_) {
        int n = tree_.size();
        tree = tree_;
        color = color_;
        subtreeSize.resize(n);
        answer.resize(n);
        distinctColors = 0;
        
        calcSize(0, -1);
        dsu(0, -1, false);
        
        return answer;
    }
};
```

### Complete Trace

```
Tree:    0
        / \
       1   2
      / \
     3   4

Colors: [1, 1, 2, 3, 1]
        (each node's color)

Subtree sizes: [5, 3, 1, 1, 1]

Process:

dsu(0):
  Heavy child = 1 (size 3)
  Light child = 2 (size 1)
  
  Process light child 2:
    dsu(2, keep=false):
      No children
      add(2, delta=1): cnt[2]++, distinctColors=1
      answer[2] = 1
      add(2, delta=-1): cnt[2]--, distinctColors=0
  
  Process heavy child 1:
    dsu(1, keep=true):
      Heavy child = ? (size 1 = size 1, pick 3)
      
      Process light child 4:
        dsu(4, keep=false):
          add(4, delta=1): cnt[1]++, distinctColors=1
          answer[4] = 1
          add(4, delta=-1): removed
      
      Process heavy child 3:
        dsu(3, keep=true):
          add(3, delta=1): cnt[3]++, distinctColors=1
          answer[3] = 1
          Keep data: cnt={3:1}, distinctColors=1
      
      Add light child 4:
        add(4, delta=1): cnt[1]++, distinctColors=2
      
      Add node 1:
        cnt[1]++ (now cnt[1]=2), distinctColors=2
      
      answer[1] = 2 (colors 1 and 3)
      Keep data: cnt={1:2, 3:1}, distinctColors=2
  
  Add light child 2:
    add(2, delta=1): cnt[2]++, distinctColors=3
  
  Add node 0:
    cnt[1]++ (now cnt[1]=3), distinctColors=3
  
  answer[0] = 3 (colors 1, 2, 3)

Final answers: [3, 2, 1, 1, 1]
```

**Time:** O(n log n)  
**Space:** O(n)

---

## Policy-Based Data Structures

### What are PBDS?

**GNU C++ library extensions with advanced data structures.**

**Not in standard C++, but available in GCC!**

```cpp
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace __gnu_pbds;
```

### Order Statistics Tree

**RB-tree with order statistics support:**
- Find kth smallest element
- Count elements less than x
- All set operations

**Think:** `set` + `find_by_order` + `order_of_key`

### How PBDS Works

**Augmented Red-Black Tree:**
```
Each node stores:
  - Value
  - Left/right children
  - Subtree size ‚Üê Extra info!

With subtree size:
  - Can find kth element by navigating tree
  - Can count smaller elements
```

**Visual:**
```
        5 (size=7)
       / \
      3   8 (size=3)
     / \   \
    1   4   9 (size=1)
   /
  0 (size=1)

find_by_order(3):
  Start at root (size 7)
  Left subtree size = 4
  k=3 < 4 ‚Üí go left
  
  At node 3 (size 4)
  Left subtree size = 2
  k=3 ‚â• 2 ‚Üí go right, k = 3-2-1 = 0
  
  At node 4 (size 1)
  k=0, this is the answer!
```

### Implementation

```cpp
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace __gnu_pbds;

// Order statistics tree
template<typename T>
using ordered_set = tree<
    T,                          // Key type
    null_type,                  // Mapped type (null for set)
    less<T>,                    // Comparison
    rb_tree_tag,                // Red-black tree
    tree_order_statistics_node_update  // Policy
>;

// Usage
ordered_set<int> s;

s.insert(5);
s.insert(2);
s.insert(8);
s.insert(1);

// Find kth smallest (0-indexed)
auto it = s.find_by_order(2);  // 3rd smallest = 5
cout << *it << endl;

// Count elements less than x
int cnt = s.order_of_key(6);   // Elements < 6 ‚Üí 3 (1,2,5)
cout << cnt << endl;

// All normal set operations
s.erase(2);
if (s.find(8) != s.end()) { ... }
```

### Complete Example

```cpp
ordered_set<int> s;

Operations:
  insert(5)  ‚Üí s = {5}
  insert(2)  ‚Üí s = {2, 5}
  insert(8)  ‚Üí s = {2, 5, 8}
  insert(1)  ‚Üí s = {1, 2, 5, 8}

find_by_order(0):
  0th element = 1

find_by_order(2):
  2nd element = 5

order_of_key(6):
  Elements < 6: {1, 2, 5}
  Count = 3

order_of_key(2):
  Elements < 2: {1}
  Count = 1

erase(2)  ‚Üí s = {1, 5, 8}

find_by_order(1):
  1st element = 5 (not 2, which was deleted)
```

### PBDS with Pairs (Multiset)

```cpp
// To allow duplicates, use pairs
ordered_set<pair<int, int>> s;

void insert(int val) {
    static int timestamp = 0;
    s.insert({val, timestamp++});
}

void erase(int val) {
    auto it = s.lower_bound({val, 0});
    if (it != s.end() && it->first == val) {
        s.erase(it);
    }
}

int kthSmallest(int k) {
    return s.find_by_order(k)->first;
}

int countLess(int val) {
    return s.order_of_key({val, 0});
}
```

---

## Order Statistics Tree

### Applications

**1. Inversion count**
```cpp
long long countInversions(vector<int>& arr) {
    ordered_set<int> s;
    long long inversions = 0;
    
    for (int i = arr.size() - 1; i >= 0; i--) {
        inversions += s.order_of_key(arr[i]);
        s.insert(arr[i]);
    }
    
    return inversions;
}
```

**2. Kth largest in stream**
```cpp
class KthLargest {
    ordered_set<pair<int, int>> s;
    int k;
    int timestamp;
    
public:
    KthLargest(int k_) : k(k_), timestamp(0) {}
    
    int add(int val) {
        s.insert({val, timestamp++});
        
        if (s.size() < k) return -1;
        
        // kth largest = (size - k)th smallest
        return s.find_by_order(s.size() - k)->first;
    }
};
```

**3. Range count queries**
```cpp
int countInRange(ordered_set<int>& s, int L, int R) {
    return s.order_of_key(R + 1) - s.order_of_key(L);
}
```

### PBDS Hash Table

```cpp
#include <ext/pb_ds/assoc_container.hpp>

using namespace __gnu_pbds;

// Faster hash table (not ordered)
gp_hash_table<int, int> table;

table[5] = 10;
table[3] = 20;

// Benefits:
// - Faster than unordered_map (no chaining overhead)
// - Better collision handling
```

### Comparison with Other Structures

| Operation | set | ordered_set | map | Priority Queue |
|-----------|-----|-------------|-----|----------------|
| **Insert** | O(log n) | O(log n) | O(log n) | O(log n) |
| **Delete** | O(log n) | O(log n) | O(log n) | O(log n) |
| **Find** | O(log n) | O(log n) | O(log n) | ‚ùå |
| **Kth smallest** | ‚ùå | O(log n) ‚úì | ‚ùå | ‚ùå |
| **Count < x** | ‚ùå | O(log n) ‚úì | ‚ùå | ‚ùå |

---

## Common Problems

### Problem 1: Count Smaller Numbers After Self

```cpp
vector<int> countSmaller(vector<int>& nums) {
    ordered_set<pair<int, int>> s;
    vector<int> result(nums.size());
    
    for (int i = nums.size() - 1; i >= 0; i--) {
        result[i] = s.order_of_key({nums[i], 0});
        s.insert({nums[i], i});  // Use index to handle duplicates
    }
    
    return result;
}
```

### Problem 2: Split Array Largest Sum (Meet in Middle)

```cpp
bool canSplit(vector<int>& nums, int m, long long maxSum) {
    int groups = 1;
    long long currentSum = 0;
    
    for (int num : nums) {
        if (currentSum + num > maxSum) {
            groups++;
            currentSum = num;
        } else {
            currentSum += num;
        }
    }
    
    return groups <= m;
}

int splitArray(vector<int>& nums, int m) {
    long long left = *max_element(nums.begin(), nums.end());
    long long right = accumulate(nums.begin(), nums.end(), 0LL);
    
    while (left < right) {
        long long mid = left + (right - left) / 2;
        
        if (canSplit(nums, m, mid)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    
    return left;
}
```

### Problem 3: Kth Ancestor of a Tree Node

```cpp
class TreeAncestor {
    vector<vector<int>> up;
    int LOG;
    
public:
    TreeAncestor(int n, vector<int>& parent) {
        LOG = ceil(log2(n)) + 1;
        up.assign(n, vector<int>(LOG, -1));
        
        for (int i = 0; i < n; i++) {
            up[i][0] = parent[i];
        }
        
        for (int k = 1; k < LOG; k++) {
            for (int node = 0; node < n; node++) {
                if (up[node][k-1] != -1) {
                    up[node][k] = up[up[node][k-1]][k-1];
                }
            }
        }
    }
    
    int getKthAncestor(int node, int k) {
        for (int i = 0; i < LOG; i++) {
            if (k & (1 << i)) {
                node = up[node][i];
                if (node == -1) return -1;
            }
        }
        return node;
    }
};
```

---

## Summary Tables

### Technique Comparison

| Technique | From | To | When to Use |
|-----------|------|-----|-------------|
| **Meet in Middle** | O(2^n) | O(2^(n/2)) | Subset problems, n ‚â§ 40 |
| **Binary Lifting** | O(n) | O(log n) | Tree ancestor/LCA queries |
| **DSU on Tree** | O(n¬≤) | O(n log n) | Subtree statistics |

### PBDS Operations

| Operation | ordered_set | Time |
|-----------|-------------|------|
| **insert(x)** | Add element | O(log n) |
| **erase(x)** | Remove element | O(log n) |
| **find_by_order(k)** | Kth smallest | O(log n) |
| **order_of_key(x)** | Count < x | O(log n) |

### Complexity Analysis

| Problem | Naive | Optimized | Technique |
|---------|-------|-----------|-----------|
| **Subset sum n=40** | O(2^40) | O(2^20 log 2^20) | Meet in Middle |
| **Kth ancestor** | O(n) | O(log n) | Binary Lifting |
| **LCA** | O(n) | O(log n) | Binary Lifting |
| **Subtree colors** | O(n¬≤) | O(n log n) | DSU on Tree |
| **Kth smallest** | O(n log n) | O(log n) | PBDS |

---

## Practice Problems

### Meet in the Middle
- [ ] Partition Equal Subset Sum (large n)
- [ ] 4Sum
- [ ] Closest Subsequence Sum
- [ ] Split Array with Equal Sum

### Binary Lifting
- [ ] Kth Ancestor of a Tree Node
- [ ] LCA of a Binary Tree
- [ ] Distance Between Nodes in BST
- [ ] Jump Game VII

### DSU on Tree
- [ ] Distinct Colors in Subtree
- [ ] Count Nodes Equal to Average of Subtree
- [ ] Subtree Queries

### PBDS
- [ ] Count of Smaller Numbers After Self
- [ ] Reverse Pairs
- [ ] Count of Range Sum
- [ ] Longest Continuous Subarray with Absolute Diff

---

## Key Takeaways

1. **Meet in middle splits exponential search** - O(2^n) ‚Üí O(2^(n/2))
2. **Generate all subsets of each half separately** - Combine with binary search
3. **Meet in middle needs sorting** - To enable binary search for complement
4. **Binary lifting precomputes 2^k ancestors** - Any k = binary combination
5. **up[node][k] = 2^k-th ancestor** - Build with DP: up[node][k] = up[up[node][k-1]][k-1]
6. **Binary lifting for LCA: equalize depth first** - Then jump until ancestors differ
7. **Binary lifting query: O(log n)** - Decompose k into binary
8. **DSU on tree uses small to large** - Keep heavy child data
9. **Each node is light O(log n) times** - Subtree doubles when moving up
10. **DSU on tree: O(n log n)** - Instead of O(n¬≤) naive
11. **PBDS provides order statistics** - Augmented RB-tree
12. **find_by_order(k) returns kth smallest** - 0-indexed
13. **order_of_key(x) counts elements < x** - Fast range queries
14. **Use pairs for PBDS multiset** - {value, timestamp}
15. **PBDS faster than implementing own** - Battle-tested, optimized

Master these advanced techniques and you'll solve complex competitive programming problems efficiently! üöÄ

