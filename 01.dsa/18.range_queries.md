# Range Queries & Data Structures

## Table of Contents
1. [Range Query Overview](#range-query-overview)
2. [Sparse Table](#sparse-table)
3. [Sparse Table Construction](#sparse-table-construction)
4. [Range Minimum Query (RMQ)](#range-minimum-query-rmq)
5. [Fenwick Tree (BIT)](#fenwick-tree-bit)
6. [BIT Construction](#bit-construction)
7. [BIT: Prefix Sums](#bit-prefix-sums)
8. [BIT: Kth Smallest by Frequency](#bit-kth-smallest-by-frequency)
9. [Segment Tree](#segment-tree)
10. [Segment Tree: Point & Range Updates](#segment-tree-point--range-updates)
11. [Lazy Propagation](#lazy-propagation)
12. [Common Problems](#common-problems)

---

## Range Query Overview

### Problem Types

**Range Query:** Answer questions about array ranges [L, R]

**Common queries:**
- Range sum
- Range minimum/maximum
- Range GCD
- Range XOR

**Naive approach:** Loop from L to R → O(n) per query

**Goal:** Preprocess to answer in O(log n) or O(1)

### Data Structure Comparison

| Structure | Build | Query | Update | Space | Idempotent? |
|-----------|-------|-------|--------|-------|-------------|
| **Prefix Sum** | O(n) | O(1) | O(n) | O(n) | No |
| **Sparse Table** | O(n log n) | O(1) | ❌ Static | O(n log n) | Yes ✓ |
| **Fenwick (BIT)** | O(n log n) | O(log n) | O(log n) | O(n) | No |
| **Segment Tree** | O(n) | O(log n) | O(log n) | O(4n) | Any ✓ |

**When to use each:**

**Sparse Table:**
✅ Static array (no updates)  
✅ Idempotent operations (min, max, gcd)  
✅ Need O(1) query  
❌ Can't handle sum (not idempotent)

**Fenwick Tree (BIT):**
✅ Point updates  
✅ Range sum queries  
✅ Space efficient  
✅ Frequency/order statistics  
❌ More complex than segment tree

**Segment Tree:**
✅ Any range query  
✅ Point and range updates  
✅ Lazy propagation  
✅ Most versatile  
❌ More space

---

## Sparse Table

### What is Sparse Table?

**Precomputes answers for all ranges of length 2^k.**

**Key property:** Overlapping ranges OK for **idempotent** operations!

**Idempotent:** `f(x, x) = x`
- min(x, x) = x ✓
- max(x, x) = x ✓
- gcd(x, x) = x ✓
- sum(x, x) = 2x ✗ (NOT idempotent)

**Why overlapping OK:**
```
Range [L, R]:
  Split into [L, L+2^k) and (R-2^k, R]
  
  Example: [2, 8], length = 7
    k = floor(log2(7)) = 2, 2^k = 4
    
    Range 1: [2, 6)  ← length 4
    Range 2: [5, 9)  ← length 4
    Overlap: [5, 6)
    
    min([2,8]) = min(min([2,6)), min([5,9)))
    
    Even if overlap, min(overlap, overlap) = overlap ✓
```

### How Sparse Table Works

**State:** `st[i][j]` = answer for range [i, i + 2^j - 1]

**Build:**
```
st[i][0] = arr[i]  (range of length 1)

st[i][j] = f(st[i][j-1], st[i + 2^(j-1)][j-1])

Combine two halves of length 2^(j-1)
```

**Query [L, R]:**
```
k = floor(log2(R - L + 1))
answer = f(st[L][k], st[R - 2^k + 1][k])
```

**Visual:**
```
Array: [2, 4, 3, 1, 6, 7, 8, 9]

Sparse table for min:

j=0 (length 1):
  st[0][0] = 2
  st[1][0] = 4
  st[2][0] = 3
  ...

j=1 (length 2):
  st[0][1] = min(st[0][0], st[1][0]) = min(2, 4) = 2
  st[1][1] = min(st[1][0], st[2][0]) = min(4, 3) = 3
  st[2][1] = min(st[2][0], st[3][0]) = min(3, 1) = 1
  ...

j=2 (length 4):
  st[0][2] = min(st[0][1], st[2][1]) = min(2, 1) = 1
  st[1][2] = min(st[1][1], st[3][1]) = min(3, 1) = 1
  ...

Query min([1, 6]):
  Length = 6, k = floor(log2(6)) = 2, 2^k = 4
  
  Range 1: st[1][2] = min([1, 4])
  Range 2: st[6-4+1][2] = st[3][2] = min([3, 6])
  
  answer = min(st[1][2], st[3][2])
```

---

## Sparse Table Construction

### Implementation

```cpp
class SparseTable {
    vector<vector<int>> st;
    vector<int> lg;
    int n;
    
    int op(int a, int b) {
        return min(a, b);  // Can be max, gcd, etc.
    }
    
public:
    SparseTable(vector<int>& arr) {
        n = arr.size();
        
        // Precompute logarithms
        lg.resize(n + 1);
        lg[1] = 0;
        for (int i = 2; i <= n; i++) {
            lg[i] = lg[i / 2] + 1;
        }
        
        // Build sparse table
        int K = lg[n] + 1;
        st.assign(n, vector<int>(K));
        
        // Base case: ranges of length 1
        for (int i = 0; i < n; i++) {
            st[i][0] = arr[i];
        }
        
        // Build for increasing lengths
        for (int j = 1; j < K; j++) {
            for (int i = 0; i + (1 << j) <= n; i++) {
                st[i][j] = op(st[i][j-1], st[i + (1 << (j-1))][j-1]);
            }
        }
    }
    
    int query(int L, int R) {
        int k = lg[R - L + 1];
        return op(st[L][k], st[R - (1 << k) + 1][k]);
    }
};
```

**Complete trace:**
```
arr = [3, 2, 4, 5, 1, 1, 5, 3]

Build sparse table:

j=0:
  st[0][0] = 3
  st[1][0] = 2
  st[2][0] = 4
  st[3][0] = 5
  st[4][0] = 1
  st[5][0] = 1
  st[6][0] = 5
  st[7][0] = 3

j=1 (length 2 = 2^1):
  st[0][1] = min(st[0][0], st[1][0]) = min(3, 2) = 2
  st[1][1] = min(st[1][0], st[2][0]) = min(2, 4) = 2
  st[2][1] = min(st[2][0], st[3][0]) = min(4, 5) = 4
  st[3][1] = min(st[3][0], st[4][0]) = min(5, 1) = 1
  st[4][1] = min(st[4][0], st[5][0]) = min(1, 1) = 1
  st[5][1] = min(st[5][0], st[6][0]) = min(1, 5) = 1
  st[6][1] = min(st[6][0], st[7][0]) = min(5, 3) = 3

j=2 (length 4 = 2^2):
  st[0][2] = min(st[0][1], st[2][1]) = min(2, 4) = 2
  st[1][2] = min(st[1][1], st[3][1]) = min(2, 1) = 1
  st[2][2] = min(st[2][1], st[4][1]) = min(4, 1) = 1
  st[3][2] = min(st[3][1], st[5][1]) = min(1, 1) = 1
  st[4][2] = min(st[4][1], st[6][1]) = min(1, 3) = 1

j=3 (length 8 = 2^3):
  st[0][3] = min(st[0][2], st[4][2]) = min(2, 1) = 1

Query min([2, 6]):
  Length = 5, k = lg[5] = 2, 2^k = 4
  
  L = 2, R = 6
  Range 1: st[2][2] covers [2, 5]
  Range 2: st[6-4+1][2] = st[3][2] covers [3, 6]
  
  answer = min(st[2][2], st[3][2]) = min(1, 1) = 1 ✓
```

**Time:** 
- Build: O(n log n)
- Query: O(1)

**Space:** O(n log n)

---

## Range Minimum Query (RMQ)

### RMQ Variants

**Static RMQ:** Sparse Table (O(1) query)

**Dynamic RMQ:** Segment Tree (O(log n) query, supports updates)

### Example: Range Min/Max

```cpp
// Range Maximum Query
class RMQ_Max {
    SparseTable st;
    
    int op(int a, int b) {
        return max(a, b);
    }
    
public:
    RMQ_Max(vector<int>& arr) : st(arr) {}
    
    int queryMax(int L, int R) {
        return st.query(L, R);
    }
};

// Range GCD
class RMQ_GCD {
    int gcd(int a, int b) {
        return b ? gcd(b, a % b) : a;
    }
    
    int op(int a, int b) {
        return gcd(a, b);
    }
    
    // ... similar implementation
};
```

**Why Sparse Table perfect for RMQ:**
```
1. Static array (RMQ queries don't modify)
2. min/max are idempotent
3. O(1) query is fastest possible
4. Simple to implement
```

---

## Fenwick Tree (BIT)

### What is Fenwick Tree?

**Binary Indexed Tree (BIT):** Efficient structure for prefix sums.

**Key idea:** Each position stores sum of a range based on binary representation.

**Range coverage:**
```
Position i covers range of length LSB(i) = i & (-i)

Example:
  i = 6 = 110₂
  LSB(6) = 010₂ = 2
  BIT[6] stores sum of range [5, 6]
  
  i = 8 = 1000₂
  LSB(8) = 1000₂ = 8
  BIT[8] stores sum of range [1, 8]
```

**Why it works:**
```
Binary representation allows covering [0, n] with O(log n) ranges!

Example: Prefix sum [0, 13]:
  13 = 1101₂
  
  Split: 1101 = 1000 + 0100 + 0001
         (8)    (4)    (1)
  
  sum[0, 13] = BIT[8] + BIT[12] + BIT[13]
               └─[1,8] └─[9,12] └─[13,13]
```

### How BIT Works

**Structure:**
```
Array: [3, 2, -1, 6, 5, 4, -3, 3]
Index:  1  2   3  4  5  6   7  8

BIT visualization:
  8 ─────────────────┐
  4 ─────┐           │
  2 ─┐   │           │
  1  3   │   6       │
     ↓   ↓   ↓       ↓
    [1] [2] [4]     [8]
     3   5   10      16

BIT[1] = arr[1] = 3
BIT[2] = arr[1] + arr[2] = 5
BIT[4] = arr[1] + arr[2] + arr[3] + arr[4] = 10
BIT[8] = sum of all 8 elements = 16
```

**Operations:**

**Update(i, delta):** Add delta to arr[i]
```
Update all ranges containing position i
i += LSB(i) repeatedly
```

**Query(i):** Prefix sum [1, i]
```
Sum all ranges ending at or before i
i -= LSB(i) repeatedly
```

---

## BIT Construction

### Implementation

```cpp
class FenwickTree {
    vector<int> bit;
    int n;
    
    int LSB(int i) {
        return i & (-i);
    }
    
public:
    FenwickTree(int n) : n(n), bit(n + 1, 0) {}
    
    FenwickTree(vector<int>& arr) : n(arr.size()), bit(n + 1, 0) {
        for (int i = 0; i < n; i++) {
            update(i + 1, arr[i]);  // 1-indexed
        }
    }
    
    void update(int i, int delta) {
        while (i <= n) {
            bit[i] += delta;
            i += LSB(i);
        }
    }
    
    int query(int i) {
        int sum = 0;
        while (i > 0) {
            sum += bit[i];
            i -= LSB(i);
        }
        return sum;
    }
    
    int rangeQuery(int L, int R) {
        return query(R) - query(L - 1);
    }
};
```

**Complete trace:**
```
arr = [3, 2, -1, 6, 5, 4, -3, 3]
      1  2   3  4  5  6   7  8  (1-indexed)

Build BIT by updating each position:

update(1, 3):
  i = 1, LSB(1) = 1
  bit[1] += 3 → bit[1] = 3
  i = 1 + 1 = 2, LSB(2) = 2
  bit[2] += 3 → bit[2] = 3
  i = 2 + 2 = 4, LSB(4) = 4
  bit[4] += 3 → bit[4] = 3
  i = 4 + 4 = 8, LSB(8) = 8
  bit[8] += 3 → bit[8] = 3
  i = 8 + 8 = 16 > 8, stop

update(2, 2):
  i = 2, bit[2] += 2 → bit[2] = 5
  i = 4, bit[4] += 2 → bit[4] = 5
  i = 8, bit[8] += 2 → bit[8] = 5
  
update(3, -1):
  i = 3, bit[3] += -1 → bit[3] = -1
  i = 4, bit[4] += -1 → bit[4] = 4
  i = 8, bit[8] += -1 → bit[8] = 4

update(4, 6):
  i = 4, bit[4] += 6 → bit[4] = 10
  i = 8, bit[8] += 6 → bit[8] = 10

... continuing for all elements

Final BIT:
  bit[1] = 3
  bit[2] = 5
  bit[3] = -1
  bit[4] = 10
  bit[5] = 5
  bit[6] = 9
  bit[7] = -3
  bit[8] = 19

Query prefix sum [1, 6]:
  i = 6, sum += bit[6] = 9
    LSB(6) = 010₂ = 2
    i = 6 - 2 = 4
  
  i = 4, sum += bit[4] = 9 + 10 = 19
    LSB(4) = 100₂ = 4
    i = 4 - 4 = 0
  
  i = 0, stop
  
  answer = 19 ✓
  
Verify: arr[1..6] = 3 + 2 + (-1) + 6 + 5 + 4 = 19 ✓
```

**Visual of query path:**
```
Query(6):
      8
     ╱ ╲
    4   12
   ╱ ╲
  2   6 ← start here
     ↓
     4 ← go here
     ↓
     0 (stop)

Path: 6 → 4 → 0
Sum: bit[6] + bit[4]
```

**Time:**
- Build: O(n log n)
- Update: O(log n)
- Query: O(log n)

**Space:** O(n)

---

## BIT: Prefix Sums

### Standard Use Case

**Problem:** Array updates and range sum queries.

**Example:**
```cpp
vector<int> arr = {1, 3, 5, 7, 9, 11};
FenwickTree bit(arr);

// Query sum [2, 5] (0-indexed → 1-indexed: [3, 6])
int sum = bit.rangeQuery(3, 6);  // sum of [5, 7, 9, 11] = 32

// Update arr[2] += 10 (0-indexed → 1-indexed: 3)
bit.update(3, 10);

// New query sum [2, 5]
sum = bit.rangeQuery(3, 6);  // sum of [15, 7, 9, 11] = 42
```

### Point Update, Range Query

```cpp
class BIT_PointUpdate {
    FenwickTree bit;
    
public:
    BIT_PointUpdate(vector<int>& arr) : bit(arr) {}
    
    void pointUpdate(int idx, int val) {
        int oldVal = rangeQuery(idx, idx);
        bit.update(idx + 1, val - oldVal);  // Delta
    }
    
    int rangeQuery(int L, int R) {
        return bit.rangeQuery(L + 1, R + 1);
    }
};
```

### Range Update, Point Query

**Trick:** Use difference array!

```cpp
class BIT_RangeUpdate {
    FenwickTree bit;
    
public:
    BIT_RangeUpdate(int n) : bit(n) {}
    
    void rangeUpdate(int L, int R, int delta) {
        bit.update(L + 1, delta);
        bit.update(R + 2, -delta);
    }
    
    int pointQuery(int idx) {
        return bit.query(idx + 1);
    }
};
```

**How it works:**
```
Difference array: d[i] = arr[i] - arr[i-1]

Range update [L, R] by delta:
  d[L] += delta
  d[R+1] -= delta

Point query arr[i]:
  arr[i] = sum of d[0..i]
  
Use BIT on difference array!
```

---

## BIT: Kth Smallest by Frequency

### Problem

**Frequency array: freq[x] = count of value x**

**Query:** Find kth smallest value (by cumulative frequency).

**Example:**
```
freq = [0, 2, 1, 3, 0, 1]
        0  1  2  3  4  5

Values: 1, 1, 2, 3, 3, 3, 5
        └──┘  └  └─────┘  └

kth smallest:
  k=1 → 1
  k=3 → 2
  k=5 → 3
  k=7 → 5
```

### How It Works

**Key insight:** BIT stores cumulative frequencies!

**Query kth:**
```
Binary search on BIT:
  Start from highest bit
  Try adding current bit
  If cumulative sum < k, add bit and reduce k
```

**Implementation:**
```cpp
class BIT_KthOrder {
    FenwickTree bit;
    int maxVal;
    
public:
    BIT_KthOrder(int maxVal) : maxVal(maxVal), bit(maxVal) {}
    
    void insert(int val) {
        bit.update(val, 1);
    }
    
    void remove(int val) {
        bit.update(val, -1);
    }
    
    int kthSmallest(int k) {
        int pos = 0;
        int cumSum = 0;
        
        // Start from highest bit
        for (int i = __lg(maxVal); i >= 0; i--) {
            int nextPos = pos + (1 << i);
            
            if (nextPos <= maxVal && cumSum + bit.bit[nextPos] < k) {
                pos = nextPos;
                cumSum += bit.bit[nextPos];
            }
        }
        
        return pos + 1;
    }
};
```

**Complete trace:**
```
freq = [0, 2, 1, 3, 0, 1]  (values 1-5)

Build BIT:
  insert(1) twice
  insert(2) once
  insert(3) three times
  insert(5) once

BIT (cumulative frequencies):
  bit[1] = 2
  bit[2] = 3
  bit[3] = 1
  bit[4] = 6
  bit[5] = 1

Query kth smallest, k=4:
  pos = 0, cumSum = 0
  
  i=2 (bit = 4):
    nextPos = 0 + 4 = 4
    cumSum + bit[4] = 0 + 6 >= 4? YES
    Don't move (would overshoot)
  
  i=1 (bit = 2):
    nextPos = 0 + 2 = 2
    cumSum + bit[2] = 0 + 3 < 4? YES
    pos = 2, cumSum = 3
  
  i=0 (bit = 1):
    nextPos = 2 + 1 = 3
    cumSum + bit[3] = 3 + 1 >= 4? YES
    Don't move
  
  answer = pos + 1 = 3
  
Verify:
  Values: 1, 1, 2, 3, 3, 3, 5
                    ↑ 4th smallest
  Answer: 3 ✓
```

**Time:** O(log² n) or O(log n) with direct BIT access

---

## Segment Tree

### What is Segment Tree?

**Tree structure where each node represents a range.**

**Properties:**
- Root: entire array
- Leaves: single elements
- Internal nodes: merge of children

**Visual:**
```
Array: [1, 3, 5, 7, 9, 11, 13, 15]

Segment Tree (range sum):
                 [0,7]=64
                /         \
         [0,3]=16          [4,7]=48
         /     \           /      \
    [0,1]=4  [2,3]=12  [4,5]=20  [6,7]=28
     /  \     /  \      /  \      /  \
   [0] [1] [2] [3]   [4] [5]   [6] [7]
    1   3   5   7     9   11   13  15
```

**Node indexing:**
```
1-indexed tree:
  Node 1: root
  Node i:
    Left child: 2i
    Right child: 2i + 1
    
Array representation: tree[4*n]
```

### How Segment Tree Works

**Build:**
```cpp
void build(int node, int L, int R) {
    if (L == R) {
        tree[node] = arr[L];  // Leaf
    } else {
        int mid = (L + R) / 2;
        build(2*node, L, mid);
        build(2*node+1, mid+1, R);
        tree[node] = tree[2*node] + tree[2*node+1];  // Merge
    }
}
```

**Query [qL, qR]:**
```cpp
int query(int node, int L, int R, int qL, int qR) {
    if (qL > R || qR < L) return 0;  // No overlap
    
    if (qL <= L && R <= qR) return tree[node];  // Full overlap
    
    // Partial overlap
    int mid = (L + R) / 2;
    return query(2*node, L, mid, qL, qR) +
           query(2*node+1, mid+1, R, qL, qR);
}
```

**Update:**
```cpp
void update(int node, int L, int R, int idx, int val) {
    if (L == R) {
        tree[node] = val;  // Leaf
    } else {
        int mid = (L + R) / 2;
        if (idx <= mid) {
            update(2*node, L, mid, idx, val);
        } else {
            update(2*node+1, mid+1, R, idx, val);
        }
        tree[node] = tree[2*node] + tree[2*node+1];  // Recompute
    }
}
```

---

## Segment Tree: Point & Range Updates

### Implementation

```cpp
class SegmentTree {
    vector<int> tree;
    int n;
    
    void build(vector<int>& arr, int node, int L, int R) {
        if (L == R) {
            tree[node] = arr[L];
        } else {
            int mid = (L + R) / 2;
            build(arr, 2*node, L, mid);
            build(arr, 2*node+1, mid+1, R);
            tree[node] = tree[2*node] + tree[2*node+1];
        }
    }
    
    void update(int node, int L, int R, int idx, int val) {
        if (L == R) {
            tree[node] = val;
        } else {
            int mid = (L + R) / 2;
            if (idx <= mid) {
                update(2*node, L, mid, idx, val);
            } else {
                update(2*node+1, mid+1, R, idx, val);
            }
            tree[node] = tree[2*node] + tree[2*node+1];
        }
    }
    
    int query(int node, int L, int R, int qL, int qR) {
        if (qL > R || qR < L) return 0;  // No overlap
        
        if (qL <= L && R <= qR) return tree[node];  // Full overlap
        
        int mid = (L + R) / 2;
        return query(2*node, L, mid, qL, qR) +
               query(2*node+1, mid+1, R, qL, qR);
    }
    
public:
    SegmentTree(vector<int>& arr) {
        n = arr.size();
        tree.resize(4 * n);
        build(arr, 1, 0, n - 1);
    }
    
    void update(int idx, int val) {
        update(1, 0, n - 1, idx, val);
    }
    
    int query(int L, int R) {
        return query(1, 0, n - 1, L, R);
    }
};
```

**Complete trace:**
```
arr = [1, 3, 5, 7]

Build tree (1-indexed):

build(1, 0, 3):
  mid = 1
  build(2, 0, 1):
    mid = 0
    build(4, 0, 0): tree[4] = arr[0] = 1
    build(5, 1, 1): tree[5] = arr[1] = 3
    tree[2] = tree[4] + tree[5] = 4
  
  build(3, 2, 3):
    mid = 2
    build(6, 2, 2): tree[6] = arr[2] = 5
    build(7, 3, 3): tree[7] = arr[3] = 7
    tree[3] = tree[6] + tree[7] = 12
  
  tree[1] = tree[2] + tree[3] = 16

Tree:
  Node:    1    2   3   4  5  6  7
  Value:  16    4  12   1  3  5  7
  Range: [0,3][0,1][2,3][0][1][2][3]

Query sum [1, 2]:
  query(1, 0, 3, 1, 2):
    mid = 1
    query(2, 0, 1, 1, 2):
      mid = 0
      query(4, 0, 0, 1, 2): no overlap, return 0
      query(5, 1, 1, 1, 2): full overlap, return 3
      return 0 + 3 = 3
    
    query(3, 2, 3, 1, 2):
      mid = 2
      query(6, 2, 2, 1, 2): full overlap, return 5
      query(7, 3, 3, 1, 2): no overlap, return 0
      return 5 + 0 = 5
    
    return 3 + 5 = 8
  
Answer: 8 ✓ (arr[1] + arr[2] = 3 + 5)

Update arr[2] = 10:
  update(1, 0, 3, 2, 10):
    mid = 1, idx=2 > mid, go right
    update(3, 2, 3, 2, 10):
      mid = 2, idx=2 <= mid, go left
      update(6, 2, 2, 2, 10):
        tree[6] = 10
      tree[3] = tree[6] + tree[7] = 10 + 7 = 17
    tree[1] = tree[2] + tree[3] = 4 + 17 = 21

Updated tree:
  Node:    1    2   3   4  5  6  7
  Value:  21    4  17   1  3 10  7
```

**Time:**
- Build: O(n)
- Query: O(log n)
- Update: O(log n)

**Space:** O(4n) ≈ O(n)

---

## Lazy Propagation

### Why Lazy Propagation?

**Problem:** Range updates are slow!

**Naive range update:** Update each element → O(n log n)

**Lazy propagation:** Defer updates → O(log n)!

### How Lazy Propagation Works

**Key idea:** Mark nodes as "needs update" without updating entire subtree.

**Push updates down only when needed.**

**Lazy array:** `lazy[node]` = pending update for node's range

**Operations:**

**1. Range update [uL, uR] by delta:**
```
If node range fully inside [uL, uR]:
  Apply delta to node
  Mark children as lazy
  Don't recurse!

If partial overlap:
  Push lazy value to children
  Recurse
```

**2. Query:**
```
Before using node value:
  If lazy[node] != 0:
    Apply lazy update
    Push to children
```

### Implementation

```cpp
class SegmentTreeLazy {
    vector<long long> tree, lazy;
    int n;
    
    void push(int node, int L, int R) {
        if (lazy[node] != 0) {
            // Apply lazy update
            tree[node] += lazy[node] * (R - L + 1);
            
            if (L != R) {
                // Push to children
                lazy[2*node] += lazy[node];
                lazy[2*node+1] += lazy[node];
            }
            
            lazy[node] = 0;
        }
    }
    
    void updateRange(int node, int L, int R, int uL, int uR, long long delta) {
        push(node, L, R);  // Apply pending updates
        
        if (uL > R || uR < L) return;  // No overlap
        
        if (uL <= L && R <= uR) {
            // Full overlap: update and mark lazy
            lazy[node] += delta;
            push(node, L, R);
            return;
        }
        
        // Partial overlap: recurse
        int mid = (L + R) / 2;
        updateRange(2*node, L, mid, uL, uR, delta);
        updateRange(2*node+1, mid+1, R, uL, uR, delta);
        
        // Recompute after pushing
        push(2*node, L, mid);
        push(2*node+1, mid+1, R);
        tree[node] = tree[2*node] + tree[2*node+1];
    }
    
    long long query(int node, int L, int R, int qL, int qR) {
        if (qL > R || qR < L) return 0;
        
        push(node, L, R);  // Apply pending updates
        
        if (qL <= L && R <= qR) return tree[node];
        
        int mid = (L + R) / 2;
        return query(2*node, L, mid, qL, qR) +
               query(2*node+1, mid+1, R, qL, qR);
    }
    
public:
    SegmentTreeLazy(int n) : n(n) {
        tree.resize(4 * n, 0);
        lazy.resize(4 * n, 0);
    }
    
    void updateRange(int L, int R, long long delta) {
        updateRange(1, 0, n - 1, L, R, delta);
    }
    
    long long query(int L, int R) {
        return query(1, 0, n - 1, L, R);
    }
};
```

**Complete trace:**
```
arr = [0, 0, 0, 0, 0]  (5 zeros)

Range update [1, 3] += 5:
  updateRange(1, 0, 4, 1, 3, 5):
    Partial overlap
    mid = 2
    
    updateRange(2, 0, 2, 1, 3, 5):
      Partial overlap
      mid = 1
      
      updateRange(4, 0, 1, 1, 3, 5):
        Partial overlap
        mid = 0
        
        updateRange(8, 0, 0, 1, 3, 5): no overlap
        updateRange(9, 1, 1, 1, 3, 5): full overlap!
          lazy[9] += 5
          tree[9] = 5 (range size = 1)
      
      tree[4] = tree[8] + tree[9] = 0 + 5 = 5
      
      updateRange(5, 2, 2, 1, 3, 5): full overlap!
        lazy[5] += 5
        tree[5] = 5
    
    tree[2] = tree[4] + tree[5] = 5 + 5 = 10
    
    updateRange(3, 3, 4, 1, 3, 5):
      Partial overlap
      mid = 3
      
      updateRange(6, 3, 3, 1, 3, 5): full overlap!
        lazy[6] += 5
        tree[6] = 5
      
      updateRange(7, 4, 4, 1, 3, 5): no overlap
    
    tree[3] = tree[6] + tree[7] = 5 + 0 = 5
  
  tree[1] = tree[2] + tree[3] = 10 + 5 = 15

State after update:
  tree = [?, 15, 10, 5, 5, 5, 5, 0, 0, 5, ...]
  lazy = [?, 0, 0, 0, 0, 5, 5, 0, 0, 5, ...]
  
  Lazy values at leaves 5, 6, 9 (not yet pushed)

Query sum [0, 4]:
  query(1, 0, 4, 0, 4):
    push(1): lazy[1] = 0, nothing
    Full overlap, return tree[1] = 15
  
  But wait! Lazy values not applied!
  
Actually, when we query, push propagates:
  Leaves get lazy updates applied
  Final answer: 0 + 5 + 5 + 5 + 0 = 15 ✓
```

**Why it works:**
```
Lazy updates stored at highest possible nodes.
Only when we query/update path, we push down.
Amortized O(log n) per operation!
```

**Time:**
- Range update: O(log n)
- Query: O(log n)

---

## Common Problems

### Problem 1: Range Sum Query - Mutable

```cpp
class NumArray {
    SegmentTree st;
    
public:
    NumArray(vector<int>& nums) : st(nums) {}
    
    void update(int index, int val) {
        st.update(index, val);
    }
    
    int sumRange(int left, int right) {
        return st.query(left, right);
    }
};
```

### Problem 2: Range Minimum Query

```cpp
class RMQ_SegTree {
    vector<int> tree;
    int n;
    
    void build(vector<int>& arr, int node, int L, int R) {
        if (L == R) {
            tree[node] = arr[L];
        } else {
            int mid = (L + R) / 2;
            build(arr, 2*node, L, mid);
            build(arr, 2*node+1, mid+1, R);
            tree[node] = min(tree[2*node], tree[2*node+1]);
        }
    }
    
    int query(int node, int L, int R, int qL, int qR) {
        if (qL > R || qR < L) return INT_MAX;
        if (qL <= L && R <= qR) return tree[node];
        
        int mid = (L + R) / 2;
        return min(query(2*node, L, mid, qL, qR),
                   query(2*node+1, mid+1, R, qL, qR));
    }
    
public:
    RMQ_SegTree(vector<int>& arr) {
        n = arr.size();
        tree.resize(4 * n);
        build(arr, 1, 0, n - 1);
    }
    
    int rangeMin(int L, int R) {
        return query(1, 0, n - 1, L, R);
    }
};
```

### Problem 3: Count of Smaller Numbers After Self

```cpp
class Solution {
public:
    vector<int> countSmaller(vector<int>& nums) {
        int n = nums.size();
        
        // Coordinate compression
        vector<int> sorted = nums;
        sort(sorted.begin(), sorted.end());
        sorted.erase(unique(sorted.begin(), sorted.end()), sorted.end());
        
        unordered_map<int, int> compress;
        for (int i = 0; i < sorted.size(); i++) {
            compress[sorted[i]] = i + 1;
        }
        
        FenwickTree bit(sorted.size() + 1);
        vector<int> result(n);
        
        // Process from right to left
        for (int i = n - 1; i >= 0; i--) {
            int compressed = compress[nums[i]];
            result[i] = bit.query(compressed - 1);
            bit.update(compressed, 1);
        }
        
        return result;
    }
};
```

### Problem 4: Range Addition

```cpp
class RangeAddition {
    FenwickTree bit;
    
public:
    RangeAddition(int n) : bit(n) {}
    
    void rangeAdd(int L, int R, int val) {
        bit.update(L + 1, val);
        bit.update(R + 2, -val);
    }
    
    vector<int> getArray(int n) {
        vector<int> result(n);
        for (int i = 0; i < n; i++) {
            result[i] = bit.query(i + 1);
        }
        return result;
    }
};
```

---

## Summary Tables

### Data Structure Comparison

| Structure | Build | Query | Update | Space | Best For |
|-----------|-------|-------|--------|-------|----------|
| **Sparse Table** | O(n log n) | O(1) | ❌ | O(n log n) | Static RMQ |
| **BIT** | O(n log n) | O(log n) | O(log n) | O(n) | Prefix sums |
| **Segment Tree** | O(n) | O(log n) | O(log n) | O(4n) | Any range query |
| **Lazy SegTree** | O(n) | O(log n) | O(log n) | O(4n) | Range updates |

### When to Use Each

| Use Case | Data Structure |
|----------|----------------|
| **Static min/max query** | Sparse Table |
| **Dynamic prefix sums** | Fenwick Tree |
| **Order statistics** | Fenwick Tree |
| **Range sum with updates** | Segment Tree or BIT |
| **Range min/max with updates** | Segment Tree |
| **Range updates, range queries** | Lazy Segment Tree |
| **Non-idempotent, no updates** | Prefix sum array |

### Operation Complexity

| Operation | Sparse | BIT | SegTree | Lazy SegTree |
|-----------|--------|-----|---------|--------------|
| **Point update** | ❌ | O(log n) | O(log n) | O(log n) |
| **Range update** | ❌ | O(log n)* | O(n log n) | O(log n) |
| **Point query** | O(1) | O(log n) | O(log n) | O(log n) |
| **Range query** | O(1) | O(log n) | O(log n) | O(log n) |

*With difference array trick

---

## Practice Problems

### Sparse Table
- [ ] Range Minimum Query
- [ ] Shortest Uncommon Substring in an Array
- [ ] Range GCD Query

### Fenwick Tree (BIT)
- [ ] Range Sum Query - Mutable
- [ ] Count of Smaller Numbers After Self
- [ ] Reverse Pairs
- [ ] Create Sorted Array through Instructions

### Segment Tree
- [ ] Range Sum Query - Mutable
- [ ] Count of Range Sum
- [ ] My Calendar I/II/III
- [ ] The Skyline Problem
- [ ] Falling Squares

### Lazy Propagation
- [ ] Range Addition
- [ ] Range Sum Query - Lazy
- [ ] Shortest Subarray to be Removed to Make Array Sorted
- [ ] Amount of New Area Painted Each Day

---

## Key Takeaways

1. **Sparse Table for static idempotent RMQ** - O(1) query, no updates
2. **Idempotent: f(x,x) = x** - min, max, gcd work; sum doesn't
3. **Sparse Table overlapping ranges OK** - Because idempotent!
4. **BIT uses binary representation** - LSB determines range coverage
5. **BIT update: i += LSB(i)** - Propagate up tree
6. **BIT query: i -= LSB(i)** - Sum prefix ranges
7. **BIT 1-indexed** - Easier to handle LSB
8. **BIT for kth order: binary search on cumulative** - O(log n)
9. **Segment tree node i: children 2i and 2i+1** - 1-indexed tree
10. **Segment tree size: 4n** - Sufficient for all cases
11. **Lazy propagation defers updates** - Mark nodes, push when needed
12. **Lazy push before use** - Apply pending updates first
13. **Range update with lazy: O(log n)** - Not O(n log n)!
14. **BIT range update trick: difference array** - Update endpoints only
15. **Choose structure by requirements** - Static? Updates? Idempotent?

Master these range query structures and you'll handle any query problem efficiently! ⚡

