# Recursion & Backtracking - Complete Guide

## Table of Contents
1. [Recursion Fundamentals](#recursion-fundamentals)
2. [Backtracking Fundamentals](#backtracking-fundamentals)
3. [Subsets Problems](#subsets-problems)
4. [Permutations Problems](#permutations-problems)
5. [N-Queens Problem](#n-queens-problem)
6. [Sudoku Solver](#sudoku-solver)
7. [State Design](#state-design)
8. [Visitation Strategies](#visitation-strategies)
9. [Early Exit & Pruning](#early-exit--pruning)
10. [Advanced Patterns](#advanced-patterns)

---

## Recursion Fundamentals

### What is Recursion?

**Concept:** A function that calls itself to solve smaller instances of the same problem.

**Components:**
1. **Base case:** Stopping condition (prevents infinite recursion)
2. **Recursive case:** Function calls itself with smaller input
3. **Progress:** Each call moves toward base case

**Visual:**
```
factorial(5)
  ‚Üí 5 * factorial(4)
       ‚Üí 4 * factorial(3)
            ‚Üí 3 * factorial(2)
                 ‚Üí 2 * factorial(1)
                      ‚Üí 1 (base case)
                      
Call stack:
factorial(5)
  factorial(4)
    factorial(3)
      factorial(2)
        factorial(1) ‚Üí returns 1
      returns 2 * 1 = 2
    returns 3 * 2 = 6
  returns 4 * 6 = 24
returns 5 * 24 = 120
```

### Basic Examples

#### Example 1: Factorial

```cpp
int factorial(int n) {
    // Base case
    if (n <= 1) return 1;
    
    // Recursive case
    return n * factorial(n - 1);
}
```

**Trace:**
```
factorial(5)
= 5 * factorial(4)
= 5 * (4 * factorial(3))
= 5 * (4 * (3 * factorial(2)))
= 5 * (4 * (3 * (2 * factorial(1))))
= 5 * (4 * (3 * (2 * 1)))
= 5 * (4 * (3 * 2))
= 5 * (4 * 6)
= 5 * 24
= 120
```

#### Example 2: Fibonacci

```cpp
int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}
```

**Tree visualization:**
```
                    fib(5)
                  /        \
            fib(4)          fib(3)
           /      \        /      \
       fib(3)   fib(2)  fib(2)   fib(1)
      /    \    /   \   /   \
  fib(2) fib(1) f(1) f(0) f(1) f(0)
  /   \
f(1) f(0)
```

**Time:** O(2^n) - exponential! (Can optimize with memoization)

#### Example 3: Power

```cpp
long long power(int base, int exp) {
    if (exp == 0) return 1;
    
    long long half = power(base, exp / 2);
    
    if (exp % 2 == 0) {
        return half * half;
    } else {
        return base * half * half;
    }
}
```

**Time:** O(log n) - much better than O(n) iterative!

### Recursion vs Iteration

| Aspect | Recursion | Iteration |
|--------|-----------|-----------|
| Code | Cleaner, elegant | More verbose |
| Space | O(depth) stack | O(1) usually |
| Overhead | Function calls | None |
| Infinite loop | Stack overflow | Infinite loop |
| Use case | Tree/graph, divide-conquer | Simple loops |

---

## Backtracking Fundamentals

### What is Backtracking?

**Concept:** Try all possibilities by building solution incrementally and abandoning (backtracking) when constraints violated.

**Pattern:**
```
explore(state):
    if (is_solution(state)):
        record_solution(state)
        return
    
    if (is_invalid(state)):
        return  // Prune
    
    for each choice:
        make_choice(state, choice)
        explore(state)
        undo_choice(state, choice)  // BACKTRACK!
```

**Key steps:**
1. **Choose:** Make a choice and add to current state
2. **Explore:** Recursively explore with this choice
3. **Unchoose (Backtrack):** Remove choice before trying next option

**Visual:**
```
Solving: Find all subsets of [1,2,3]

                        []
                      / | \
                    /   |   \
                [1]    [2]   [3]
               / \      |
            [1,2] [1,3] [2,3]
             /
         [1,2,3]

At each node:
1. Add element (choose)
2. Recurse (explore)
3. Remove element (unchoose)
```

### Backtracking Template

```cpp
void backtrack(state, choices, result) {
    // Base case: valid solution found
    if (is_solution(state)) {
        result.push_back(state);
        return;
    }
    
    // Pruning: invalid state
    if (is_invalid(state)) {
        return;
    }
    
    // Try all choices
    for (auto& choice : choices) {
        // Skip if choice is invalid
        if (!is_valid_choice(choice)) continue;
        
        // Make choice
        state.add(choice);
        
        // Recurse
        backtrack(state, next_choices, result);
        
        // Backtrack (undo choice)
        state.remove(choice);
    }
}
```

---

## Subsets Problems

### Pattern 1: Generate All Subsets

**Problem:** Given array [1,2,3], generate all subsets (power set).

**How it works:** For each element, we have 2 choices: include or exclude.

```cpp
void backtrack(vector<int>& nums, int start, vector<int>& current, 
               vector<vector<int>>& result) {
    // Every state is a valid subset
    result.push_back(current);
    
    // Try adding each remaining element
    for (int i = start; i < nums.size(); i++) {
        // Choose
        current.push_back(nums[i]);
        
        // Explore
        backtrack(nums, i + 1, current, result);
        
        // Unchoose (backtrack)
        current.pop_back();
    }
}

vector<vector<int>> subsets(vector<int>& nums) {
    vector<vector<int>> result;
    vector<int> current;
    backtrack(nums, 0, current, result);
    return result;
}
```

**Detailed trace:**
```
nums = [1, 2, 3]

Call tree:

backtrack([], start=0)
  Add [] to result
  
  i=0: Choose 1
    backtrack([1], start=1)
      Add [1] to result
      
      i=1: Choose 2
        backtrack([1,2], start=2)
          Add [1,2] to result
          
          i=2: Choose 3
            backtrack([1,2,3], start=3)
              Add [1,2,3] to result
              (no more elements)
            Unchoose 3
        Unchoose 2
      
      i=2: Choose 3
        backtrack([1,3], start=3)
          Add [1,3] to result
        Unchoose 3
    Unchoose 1
  
  i=1: Choose 2
    backtrack([2], start=2)
      Add [2] to result
      
      i=2: Choose 3
        backtrack([2,3], start=3)
          Add [2,3] to result
        Unchoose 3
    Unchoose 2
  
  i=2: Choose 3
    backtrack([3], start=3)
      Add [3] to result
    Unchoose 3

Result: [[], [1], [1,2], [1,2,3], [1,3], [2], [2,3], [3]]
```

**State progression:**
```
[]                     (initial)
  [1]                  (add 1)
    [1,2]              (add 2)
      [1,2,3]          (add 3)
      [1,2]            (remove 3)
    [1]                (remove 2)
    [1,3]              (add 3)
    [1]                (remove 3)
  []                   (remove 1)
  [2]                  (add 2)
    [2,3]              (add 3)
    [2]                (remove 3)
  []                   (remove 2)
  [3]                  (add 3)
  []                   (remove 3)
```

**Time:** O(2^n √ó n) - 2^n subsets, O(n) to copy each  
**Space:** O(n) recursion depth

### Pattern 2: Subsets with Duplicates

**Problem:** [1,2,2] ‚Üí avoid duplicate subsets.

**Key insight:** Sort first, skip duplicates at same recursion level!

```cpp
void backtrack(vector<int>& nums, int start, vector<int>& current,
               vector<vector<int>>& result) {
    result.push_back(current);
    
    for (int i = start; i < nums.size(); i++) {
        // Skip duplicates at same level
        if (i > start && nums[i] == nums[i - 1]) continue;
        
        current.push_back(nums[i]);
        backtrack(nums, i + 1, current, result);
        current.pop_back();
    }
}

vector<vector<int>> subsetsWithDup(vector<int>& nums) {
    sort(nums.begin(), nums.end());  // Sort first!
    vector<vector<int>> result;
    vector<int> current;
    backtrack(nums, 0, current, result);
    return result;
}
```

**Why skip duplicates?**
```
nums = [1, 2, 2] (sorted)

Without skipping:
  []
    [1]
      [1,2]
        [1,2,2]  ‚úì
      [1,2]      (from 2nd 2)  ‚úó duplicate of [1,2]
    [2]
      [2,2]      ‚úì
    [2]          ‚úó duplicate of [2]

With skipping (i > start && nums[i] == nums[i-1]):
  At start=0: Can choose first 2
  At start=1: Skip second 2 (i=2, start=1, nums[2]==nums[1])
  Result: No duplicates!
```

**Time:** O(2^n √ó n)

### Pattern 3: Combination Sum

**Problem:** Find all combinations that sum to target (can reuse elements).

```cpp
void backtrack(vector<int>& candidates, int target, int start,
               vector<int>& current, vector<vector<int>>& result) {
    // Base case: found solution
    if (target == 0) {
        result.push_back(current);
        return;
    }
    
    // Pruning: exceeded target
    if (target < 0) return;
    
    for (int i = start; i < candidates.size(); i++) {
        current.push_back(candidates[i]);
        
        // Can reuse same element, so pass i (not i+1)
        backtrack(candidates, target - candidates[i], i, current, result);
        
        current.pop_back();
    }
}

vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
    vector<vector<int>> result;
    vector<int> current;
    backtrack(candidates, target, 0, current, result);
    return result;
}
```

**Example:**
```
candidates = [2, 3, 6, 7], target = 7

backtrack(target=7, start=0, current=[])
  i=0: Add 2, target=5
    i=0: Add 2, target=3
      i=0: Add 2, target=1
        i=0: Add 2, target=-1 ‚Üí prune
      i=1: Add 3, target=0 ‚Üí found [2,2,3]
    i=1: Add 3, target=2
      i=1: Add 3, target=-1 ‚Üí prune
  i=1: Add 3, target=4
    i=1: Add 3, target=1
      i=1: Add 3, target=-2 ‚Üí prune
  i=3: Add 7, target=0 ‚Üí found [7]

Result: [[2,2,3], [7]]
```

**Time:** O(2^target) approximately

---

## Permutations Problems

### Pattern 1: Generate All Permutations

**Problem:** Generate all permutations of [1,2,3].

**How it works:** At each position, try all unused elements.

```cpp
void backtrack(vector<int>& nums, vector<bool>& used, 
               vector<int>& current, vector<vector<int>>& result) {
    // Base case: permutation complete
    if (current.size() == nums.size()) {
        result.push_back(current);
        return;
    }
    
    // Try each number
    for (int i = 0; i < nums.size(); i++) {
        // Skip if already used
        if (used[i]) continue;
        
        // Choose
        current.push_back(nums[i]);
        used[i] = true;
        
        // Explore
        backtrack(nums, used, current, result);
        
        // Unchoose (backtrack)
        current.pop_back();
        used[i] = false;
    }
}

vector<vector<int>> permute(vector<int>& nums) {
    vector<vector<int>> result;
    vector<int> current;
    vector<bool> used(nums.size(), false);
    backtrack(nums, used, current, result);
    return result;
}
```

**Detailed trace:**
```
nums = [1, 2, 3]

Decision tree:

Level 0: []
         / | \
        1  2  3
Level 1:
      [1]  [2]  [3]
      / \   |     
     2   3  1 3  1 2
Level 2:
  [1,2] [1,3] [2,1] [2,3] [3,1] [3,2]
    |     |     |     |     |     |
    3     2     3     1     2     1
Level 3:
[1,2,3] [1,3,2] [2,1,3] [2,3,1] [3,1,2] [3,2,1]

Execution trace:
backtrack(current=[], used=[F,F,F])
  i=0: Choose 1
    backtrack([1], [T,F,F])
      i=1: Choose 2
        backtrack([1,2], [T,T,F])
          i=2: Choose 3
            backtrack([1,2,3], [T,T,T])
              Add [1,2,3] ‚úì
            Unchoose 3
        Unchoose 2
      i=2: Choose 3
        backtrack([1,3], [T,F,T])
          i=1: Choose 2
            backtrack([1,3,2], [T,T,T])
              Add [1,3,2] ‚úì
          Unchoose 2
        Unchoose 3
    Unchoose 1
  i=1: Choose 2
    ... (similar for [2,1,3] and [2,3,1])
  i=2: Choose 3
    ... (similar for [3,1,2] and [3,2,1])
```

**Time:** O(n! √ó n) - n! permutations, O(n) to copy each  
**Space:** O(n) recursion depth

### Pattern 2: Permutations with Duplicates

**Problem:** [1,1,2] ‚Üí avoid duplicate permutations.

```cpp
void backtrack(vector<int>& nums, vector<bool>& used,
               vector<int>& current, vector<vector<int>>& result) {
    if (current.size() == nums.size()) {
        result.push_back(current);
        return;
    }
    
    for (int i = 0; i < nums.size(); i++) {
        if (used[i]) continue;
        
        // Skip duplicate: if same as previous and previous not used
        // This ensures we use duplicates in order
        if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
            continue;
        }
        
        current.push_back(nums[i]);
        used[i] = true;
        
        backtrack(nums, used, current, result);
        
        current.pop_back();
        used[i] = false;
    }
}

vector<vector<int>> permuteUnique(vector<int>& nums) {
    sort(nums.begin(), nums.end());  // Sort first!
    vector<vector<int>> result;
    vector<int> current;
    vector<bool> used(nums.size(), false);
    backtrack(nums, used, current, result);
    return result;
}
```

**Why the condition `!used[i-1]`?**
```
nums = [1, 1, 2] (sorted)

Without condition:
  [1‚ÇÅ, 1‚ÇÇ, 2]  ‚úì
  [1‚ÇÇ, 1‚ÇÅ, 2]  ‚úó duplicate
  
With condition (i>0 && nums[i]==nums[i-1] && !used[i-1]):
  When choosing 1‚ÇÇ, check if 1‚ÇÅ was used:
    If 1‚ÇÅ used: OK, this is [1‚ÇÅ, 1‚ÇÇ, ...]
    If 1‚ÇÅ NOT used: Skip! Would create [1‚ÇÇ, 1‚ÇÅ, ...] duplicate

Forces duplicates to be used in order!
```

**Time:** O(n! √ó n)

### Pattern 3: Next Permutation

**Problem:** Find next lexicographically greater permutation.

```cpp
void nextPermutation(vector<int>& nums) {
    int n = nums.size();
    
    // Find first decreasing element from right
    int i = n - 2;
    while (i >= 0 && nums[i] >= nums[i + 1]) {
        i--;
    }
    
    if (i >= 0) {
        // Find element just larger than nums[i]
        int j = n - 1;
        while (nums[j] <= nums[i]) {
            j--;
        }
        swap(nums[i], nums[j]);
    }
    
    // Reverse suffix
    reverse(nums.begin() + i + 1, nums.end());
}
```

**Example:**
```
nums = [1, 3, 5, 4, 2]

Step 1: Find first decreasing from right
  [1, 3, 5, 4, 2]
      ‚Üë i=1 (3 < 5)

Step 2: Find just larger than nums[i]=3
  [1, 3, 5, 4, 2]
         ‚Üë j=2 (4 is smallest > 3 from right)
  Swap: [1, 4, 5, 3, 2]

Step 3: Reverse suffix after i
  [1, 4, | 5, 3, 2]
  Reverse: [1, 4, 2, 3, 5]

Result: [1, 4, 2, 3, 5]
```

**Time:** O(n)

---

## N-Queens Problem

### Problem Statement

**Place N queens on N√óN chessboard so no two queens attack each other.**

Queens attack: same row, column, or diagonal.

**Visual (N=4):**
```
Solution 1:
. Q . .
. . . Q
Q . . .
. . Q .

Solution 2:
. . Q .
Q . . .
. . . Q
. Q . .
```

### How N-Queens Works

**State:** Current row being processed  
**Choice:** Which column to place queen in current row  
**Constraint:** No conflicts with previously placed queens

**Conflict checking:**
1. **Column:** No other queen in same column
2. **Diagonal 1:** No queen on `row - col` diagonal
3. **Diagonal 2:** No queen on `row + col` diagonal

**Visual of diagonals:**
```
N=4 board with diagonal labels:

row-col:        row+col:
 -3 -2 -1  0     0  1  2  3
 -2 -1  0  1     1  2  3  4
 -1  0  1  2     2  3  4  5
  0  1  2  3     3  4  5  6

Each diagonal has unique sum/difference!
```

### Implementation

```cpp
class Solution {
private:
    vector<bool> cols;       // cols[c] = true if queen in column c
    vector<bool> diag1;      // diag1[row-col+n] = true
    vector<bool> diag2;      // diag2[row+col] = true
    vector<vector<string>> result;
    
    bool isSafe(int row, int col, int n) {
        // Check column
        if (cols[col]) return false;
        
        // Check diagonal 1 (row - col)
        if (diag1[row - col + n]) return false;
        
        // Check diagonal 2 (row + col)
        if (diag2[row + col]) return false;
        
        return true;
    }
    
    void backtrack(int row, int n, vector<string>& board) {
        // Base case: placed all queens
        if (row == n) {
            result.push_back(board);
            return;
        }
        
        // Try each column in current row
        for (int col = 0; col < n; col++) {
            if (!isSafe(row, col, n)) continue;
            
            // Place queen
            board[row][col] = 'Q';
            cols[col] = true;
            diag1[row - col + n] = true;
            diag2[row + col] = true;
            
            // Recurse to next row
            backtrack(row + 1, n, board);
            
            // Remove queen (backtrack)
            board[row][col] = '.';
            cols[col] = false;
            diag1[row - col + n] = false;
            diag2[row + col] = false;
        }
    }
    
public:
    vector<vector<string>> solveNQueens(int n) {
        cols.resize(n, false);
        diag1.resize(2 * n, false);
        diag2.resize(2 * n, false);
        
        vector<string> board(n, string(n, '.'));
        backtrack(0, n, board);
        
        return result;
    }
};
```

### Detailed Trace (N=4)

```cpp
backtrack(row=0, board=[...., ...., ...., ....])
  col=0: Safe? YES
    Place Q at (0,0)
    Board: [Q..., ...., ...., ....]
    
    backtrack(row=1)
      col=0: Conflict (column)
      col=1: Conflict (diagonal)
      col=2: Safe? YES
        Place Q at (1,2)
        Board: [Q..., ..Q., ...., ....]
        
        backtrack(row=2)
          col=0: Conflict (diagonal)
          col=1: Conflict (diagonal)
          col=2: Conflict (column)
          col=3: Conflict (diagonal)
          All columns conflict! Backtrack.
        
        Remove Q at (1,2)
      
      col=3: Safe? YES
        Place Q at (1,3)
        Board: [Q..., ...Q, ...., ....]
        
        backtrack(row=2)
          col=0: Conflict (diagonal)
          col=1: Safe? YES
            Place Q at (2,1)
            Board: [Q..., ...Q, .Q.., ....]
            
            backtrack(row=3)
              col=0: Conflict
              col=1: Conflict
              col=2: Conflict (diagonal)
              col=3: Conflict (column)
              All conflict! Backtrack.
            
            Remove Q at (2,1)
          
          col=2: Conflict (diagonal)
          col=3: Conflict (column)
          All fail! Backtrack.
        
        Remove Q at (1,3)
    
    Remove Q at (0,0)
  
  col=1: Safe? YES
    Place Q at (0,1)
    Board: [.Q.., ...., ...., ....]
    
    backtrack(row=1)
      col=0: Conflict (diagonal)
      col=1: Conflict (column)
      col=2: Conflict (diagonal)
      col=3: Safe? YES
        Place Q at (1,3)
        Board: [.Q.., ...Q, ...., ....]
        
        backtrack(row=2)
          col=0: Safe? YES
            Place Q at (2,0)
            Board: [.Q.., ...Q, Q..., ....]
            
            backtrack(row=3)
              col=0: Conflict (column)
              col=1: Conflict (diagonal)
              col=2: Safe? YES
                Place Q at (3,2)
                Board: [.Q.., ...Q, Q..., ..Q.]
                
                Row 4 reached! SOLUTION FOUND ‚úì
                Add to result
              
              Remove Q at (3,2)
              col=3: Conflict
            
            Remove Q at (2,0)
          ... continue search
```

**Time:** O(N!) - At row i, we have ‚â§ N-i choices  
**Space:** O(N) recursion depth

### Optimization: Pruning

The `isSafe` check is **pruning** - we skip entire subtrees that violate constraints!

**Without pruning:** Try all N^N placements ‚Üí O(N^N)  
**With pruning:** Skip invalid states ‚Üí O(N!)

---

## Sudoku Solver

### Problem Statement

**Fill 9√ó9 grid so each row, column, and 3√ó3 box contains digits 1-9.**

**Example:**
```
Input:
5 3 . | . 7 . | . . .
6 . . | 1 9 5 | . . .
. 9 8 | . . . | . 6 .
------+-------+------
8 . . | . 6 . | . . 3
4 . . | 8 . 3 | . . 1
7 . . | . 2 . | . . 6
------+-------+------
. 6 . | . . . | 2 8 .
. . . | 4 1 9 | . . 5
. . . | . 8 . | . 7 9

Output:
5 3 4 | 6 7 8 | 9 1 2
6 7 2 | 1 9 5 | 3 4 8
1 9 8 | 3 4 2 | 5 6 7
------+-------+------
8 5 9 | 7 6 1 | 4 2 3
4 2 6 | 8 5 3 | 7 9 1
7 1 3 | 9 2 4 | 8 5 6
------+-------+------
9 6 1 | 5 3 7 | 2 8 4
2 8 7 | 4 1 9 | 6 3 5
3 4 5 | 2 8 6 | 1 7 9
```

### How Sudoku Solver Works

**State:** Current empty cell being filled  
**Choice:** Try digits 1-9  
**Constraint:** No conflicts in row, column, or 3√ó3 box

**Pruning:** Check validity before placing digit!

### Implementation with Pruning

```cpp
class Solution {
private:
    bool isValid(vector<vector<char>>& board, int row, int col, char num) {
        // Check row
        for (int c = 0; c < 9; c++) {
            if (board[row][c] == num) return false;
        }
        
        // Check column
        for (int r = 0; r < 9; r++) {
            if (board[r][col] == num) return false;
        }
        
        // Check 3x3 box
        int boxRow = (row / 3) * 3;
        int boxCol = (col / 3) * 3;
        for (int r = 0; r < 3; r++) {
            for (int c = 0; c < 3; c++) {
                if (board[boxRow + r][boxCol + c] == num) {
                    return false;
                }
            }
        }
        
        return true;
    }
    
    bool backtrack(vector<vector<char>>& board) {
        // Find next empty cell
        for (int row = 0; row < 9; row++) {
            for (int col = 0; col < 9; col++) {
                if (board[row][col] != '.') continue;
                
                // Try each digit 1-9
                for (char num = '1'; num <= '9'; num++) {
                    // Pruning: check if valid before recursing
                    if (!isValid(board, row, col, num)) continue;
                    
                    // Place digit
                    board[row][col] = num;
                    
                    // Recurse
                    if (backtrack(board)) {
                        return true;  // Solution found!
                    }
                    
                    // Backtrack
                    board[row][col] = '.';
                }
                
                // No digit works, backtrack
                return false;
            }
        }
        
        // No empty cells, solved!
        return true;
    }
    
public:
    void solveSudoku(vector<vector<char>>& board) {
        backtrack(board);
    }
};
```

### Optimized Implementation (Bitmasking)

**Idea:** Use bitmasks to track used digits in rows/cols/boxes.

```cpp
class Solution {
private:
    int rows[9];     // rows[r] = bitmask of used digits in row r
    int cols[9];     // cols[c] = bitmask of used digits in col c
    int boxes[9];    // boxes[b] = bitmask of used digits in box b
    
    int getBox(int r, int c) {
        return (r / 3) * 3 + (c / 3);
    }
    
    bool isValid(int row, int col, int num) {
        int mask = 1 << num;
        return !(rows[row] & mask) && 
               !(cols[col] & mask) && 
               !(boxes[getBox(row, col)] & mask);
    }
    
    void place(int row, int col, int num) {
        int mask = 1 << num;
        rows[row] |= mask;
        cols[col] |= mask;
        boxes[getBox(row, col)] |= mask;
    }
    
    void remove(int row, int col, int num) {
        int mask = 1 << num;
        rows[row] &= ~mask;
        cols[col] &= ~mask;
        boxes[getBox(row, col)] &= ~mask;
    }
    
    bool backtrack(vector<vector<char>>& board, int pos) {
        if (pos == 81) return true;  // All cells filled
        
        int row = pos / 9;
        int col = pos % 9;
        
        if (board[row][col] != '.') {
            return backtrack(board, pos + 1);  // Skip filled cell
        }
        
        // Try each digit
        for (int num = 1; num <= 9; num++) {
            if (!isValid(row, col, num)) continue;
            
            board[row][col] = '0' + num;
            place(row, col, num);
            
            if (backtrack(board, pos + 1)) {
                return true;
            }
            
            board[row][col] = '.';
            remove(row, col, num);
        }
        
        return false;
    }
    
public:
    void solveSudoku(vector<vector<char>>& board) {
        // Initialize bitmasks
        memset(rows, 0, sizeof(rows));
        memset(cols, 0, sizeof(cols));
        memset(boxes, 0, sizeof(boxes));
        
        // Mark existing digits
        for (int r = 0; r < 9; r++) {
            for (int c = 0; c < 9; c++) {
                if (board[r][c] != '.') {
                    int num = board[r][c] - '0';
                    place(r, c, num);
                }
            }
        }
        
        backtrack(board, 0);
    }
};
```

**Time:** O(9^m) where m = empty cells (with pruning, much faster in practice)  
**Space:** O(1) - constant extra space for bitmasks

### Pruning Strategies

**1. Early validation (current implementation):**
```cpp
if (!isValid(row, col, num)) continue;  // Skip invalid digits
```

**2. Most constrained first:**
```cpp
// Find cell with fewest valid options
int minOptions = 10;
int bestRow, bestCol;

for (int r = 0; r < 9; r++) {
    for (int c = 0; c < 9; c++) {
        if (board[r][c] != '.') continue;
        
        int options = countValidOptions(r, c);
        if (options < minOptions) {
            minOptions = options;
            bestRow = r;
            bestCol = c;
        }
    }
}
```

**3. Constraint propagation:**
- If a cell has only 1 valid option, fill it immediately
- If a digit has only 1 valid position in row/col/box, place it

---

## State Design

### What is State?

**State:** All information needed to make decisions and backtrack.

**Components:**
1. **Current choices:** What we've selected so far
2. **Available choices:** What we can still select
3. **Constraints:** What's forbidden
4. **Progress:** How close to solution

### State Design Examples

#### Example 1: Subsets
```cpp
State {
    vector<int> current;  // Current subset
    int start;            // Next index to consider
}
```

#### Example 2: Permutations
```cpp
State {
    vector<int> current;      // Current permutation
    vector<bool> used;        // Which elements used
    int position;             // Current position in permutation
}
```

#### Example 3: N-Queens
```cpp
State {
    vector<string> board;     // Current board
    int row;                  // Current row
    vector<bool> cols;        // Used columns
    vector<bool> diag1;       // Used diagonals
    vector<bool> diag2;       // Used anti-diagonals
}
```

#### Example 4: Sudoku
```cpp
State {
    vector<vector<char>> board;  // Current board
    int rows[9];                 // Bitmask of used digits per row
    int cols[9];                 // Bitmask of used digits per col
    int boxes[9];                // Bitmask of used digits per box
    int pos;                     // Current cell index
}
```

### State Design Principles

**1. Minimal but sufficient:**
- Include only what's needed
- Don't duplicate information
- Use references when possible

**2. Easy to modify and restore:**
```cpp
// Good: Single operation to modify/restore
current.push_back(x);
// ... recurse ...
current.pop_back();

// Bad: Complex state that's hard to restore
State s = current;
// ... modify many fields ...
// ... recurse ...
current = s;  // Expensive copy!
```

**3. Use data structures wisely:**
- **Array/Vector:** For ordered sequences
- **Set:** For uniqueness checking
- **Bitmask:** For boolean flags (fast!)
- **HashMap:** For counting/mapping

**4. Pass by reference vs value:**
```cpp
// Pass by reference: modify in-place
void backtrack(vector<int>& current, ...) {
    current.push_back(x);
    backtrack(current, ...);
    current.pop_back();
}

// Pass by value: implicit copy
void backtrack(vector<int> current, ...) {
    current.push_back(x);  // Modifies copy
    backtrack(current, ...);
    // No need to backtrack, copy is discarded!
}
```

---

## Visitation Strategies

### Strategy 1: DFS (Depth-First Search)

**Concept:** Explore one path completely before trying alternatives.

**Implementation:** Recursion or explicit stack.

```cpp
void dfs(state) {
    if (is_solution(state)) {
        record(state);
        return;
    }
    
    for (each choice) {
        make_choice(state);
        dfs(state);
        undo_choice(state);
    }
}
```

**Pros:**
- Simple to implement with recursion
- Memory efficient (O(depth))
- Finds solutions quickly if tree is deep

**Cons:**
- May get stuck in deep branches
- Not optimal for finding shortest path

### Strategy 2: BFS (Breadth-First Search)

**Concept:** Explore all options at current level before going deeper.

**Implementation:** Queue.

```cpp
void bfs() {
    queue<State> q;
    q.push(initial_state);
    
    while (!q.empty()) {
        State current = q.front();
        q.pop();
        
        if (is_solution(current)) {
            record(current);
            continue;
        }
        
        for (each choice) {
            State next = current;
            make_choice(next);
            q.push(next);
        }
    }
}
```

**Pros:**
- Finds shortest path
- Explores all levels systematically

**Cons:**
- Memory intensive (O(width))
- Slower for deep solutions

### Strategy 3: Iterative Deepening

**Concept:** DFS with increasing depth limit.

```cpp
void iterativeDeepening(int maxDepth) {
    for (int depth = 0; depth <= maxDepth; depth++) {
        if (dfsLimited(initial_state, 0, depth)) {
            return;  // Solution found
        }
    }
}

bool dfsLimited(State state, int currentDepth, int limit) {
    if (currentDepth > limit) return false;
    
    if (is_solution(state)) return true;
    
    for (each choice) {
        make_choice(state);
        if (dfsLimited(state, currentDepth + 1, limit)) {
            return true;
        }
        undo_choice(state);
    }
    
    return false;
}
```

**Pros:**
- Combines benefits of DFS and BFS
- Memory efficient like DFS
- Finds shortest path like BFS

### Strategy 4: Best-First Search (Heuristic)

**Concept:** Explore most promising states first.

```cpp
void bestFirstSearch() {
    priority_queue<State> pq;  // Ordered by heuristic
    pq.push(initial_state);
    
    while (!pq.empty()) {
        State current = pq.top();
        pq.pop();
        
        if (is_solution(current)) {
            record(current);
            return;
        }
        
        for (each choice) {
            State next = current;
            make_choice(next);
            next.priority = heuristic(next);
            pq.push(next);
        }
    }
}
```

**Example heuristics:**
- Sudoku: Cells with fewest options
- N-Queens: Rows with most conflicts
- Pathfinding: Distance to goal (A*)

---

## Early Exit & Pruning

### What is Pruning?

**Pruning:** Stop exploring paths that can't lead to valid solutions.

**Types:**
1. **Constraint pruning:** Violates problem constraints
2. **Optimality pruning:** Can't improve current best
3. **Redundancy pruning:** Already explored equivalent state

### Pruning Techniques

#### 1. Constraint Checking

**Check validity BEFORE recursing:**

```cpp
void backtrack(state) {
    // Early exit: invalid state
    if (!is_valid(state)) return;  // PRUNE!
    
    if (is_solution(state)) {
        record(state);
        return;
    }
    
    for (each choice) {
        make_choice(state);
        backtrack(state);
        undo_choice(state);
    }
}
```

**Example: N-Queens**
```cpp
for (int col = 0; col < n; col++) {
    if (!isSafe(row, col, n)) continue;  // PRUNE!
    // ... rest of logic ...
}
```

#### 2. Bound Checking (Branch and Bound)

**For optimization problems:**

```cpp
int best = INT_MAX;

void backtrack(state, currentCost) {
    // Pruning: can't beat current best
    if (currentCost >= best) return;  // PRUNE!
    
    if (is_solution(state)) {
        best = min(best, currentCost);
        return;
    }
    
    for (each choice) {
        make_choice(state);
        backtrack(state, currentCost + choice_cost);
        undo_choice(state);
    }
}
```

#### 3. Duplicate Detection

**Skip already explored states:**

```cpp
void backtrack(state, visited) {
    if (visited.count(state)) return;  // PRUNE!
    visited.insert(state);
    
    // ... rest of logic ...
}
```

**Example: Permutations with duplicates**
```cpp
for (int i = 0; i < nums.size(); i++) {
    // Skip duplicates at same level
    if (i > 0 && nums[i] == nums[i-1] && !used[i-1]) {
        continue;  // PRUNE!
    }
    // ... rest of logic ...
}
```

#### 4. Ordering Choices (Most Constrained First)

**Process most constrained choices first to fail fast:**

```cpp
// Sudoku: Choose cell with fewest options
int minOptions = 10;
int bestRow, bestCol;

for (int r = 0; r < 9; r++) {
    for (int c = 0; c < 9; c++) {
        if (board[r][c] != '.') continue;
        
        int options = countValid(r, c);
        if (options < minOptions) {
            minOptions = options;
            bestRow = r;
            bestCol = c;
        }
    }
}

// Fill most constrained cell first
fillCell(bestRow, bestCol);
```

#### 5. Symmetry Breaking

**Eliminate symmetric solutions:**

```cpp
// N-Queens: Only place first queen in first half of first row
void solveNQueens(int n) {
    for (int col = 0; col < (n + 1) / 2; col++) {
        // Place first queen at (0, col)
        // ... backtrack ...
    }
    // This eliminates mirror symmetric solutions
}
```

### Early Exit Patterns

#### Pattern 1: Find First Solution

```cpp
bool backtrack(state) {
    if (is_solution(state)) {
        record(state);
        return true;  // EARLY EXIT!
    }
    
    for (each choice) {
        make_choice(state);
        if (backtrack(state)) {
            return true;  // Propagate exit
        }
        undo_choice(state);
    }
    
    return false;
}
```

#### Pattern 2: Find All Solutions (Count Only)

```cpp
int count = 0;

void backtrack(state) {
    if (is_solution(state)) {
        count++;
        return;  // Continue searching
    }
    
    for (each choice) {
        make_choice(state);
        backtrack(state);
        undo_choice(state);
    }
}
```

#### Pattern 3: Find Optimal Solution

```cpp
int best = INT_MAX;
vector<int> bestSolution;

void backtrack(state, cost) {
    // Pruning
    if (cost >= best) return;
    
    if (is_solution(state)) {
        if (cost < best) {
            best = cost;
            bestSolution = state;
        }
        return;
    }
    
    for (each choice) {
        make_choice(state);
        backtrack(state, cost + choice_cost);
        undo_choice(state);
    }
}
```

### Pruning Impact

**Example: Sudoku without pruning**
```
Try all 9 digits for each of 81 cells: 9^81 ‚âà 2√ó10^77 operations
```

**Example: Sudoku with constraint pruning**
```
Average 3-4 valid options per cell: 4^m where m ‚âà 40-50 empty cells
4^50 ‚âà 10^30 operations (still huge but way better!)
```

**Example: Sudoku with advanced pruning**
```
Most constrained first + constraint propagation:
Solves typical puzzle in < 10,000 operations!
```

---

## Advanced Patterns

### Pattern 1: Combination Sum with Target

**Find all unique combinations summing to target.**

```cpp
void backtrack(vector<int>& candidates, int target, int start,
               vector<int>& current, vector<vector<int>>& result) {
    if (target == 0) {
        result.push_back(current);
        return;
    }
    
    for (int i = start; i < candidates.size(); i++) {
        // Pruning: skip if exceeds target
        if (candidates[i] > target) break;  // Assumes sorted!
        
        // Skip duplicates
        if (i > start && candidates[i] == candidates[i-1]) continue;
        
        current.push_back(candidates[i]);
        backtrack(candidates, target - candidates[i], i + 1, current, result);
        current.pop_back();
    }
}

vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
    sort(candidates.begin(), candidates.end());  // Sort for pruning
    vector<vector<int>> result;
    vector<int> current;
    backtrack(candidates, target, 0, current, result);
    return result;
}
```

**Time:** O(2^n) worst case, much better with pruning

### Pattern 2: Palindrome Partitioning

**Partition string into palindromic substrings.**

```cpp
class Solution {
private:
    bool isPalindrome(string& s, int left, int right) {
        while (left < right) {
            if (s[left++] != s[right--]) return false;
        }
        return true;
    }
    
    void backtrack(string& s, int start, vector<string>& current,
                   vector<vector<string>>& result) {
        if (start == s.length()) {
            result.push_back(current);
            return;
        }
        
        for (int end = start; end < s.length(); end++) {
            // Pruning: only recurse if substring is palindrome
            if (!isPalindrome(s, start, end)) continue;
            
            current.push_back(s.substr(start, end - start + 1));
            backtrack(s, end + 1, current, result);
            current.pop_back();
        }
    }
    
public:
    vector<vector<string>> partition(string s) {
        vector<vector<string>> result;
        vector<string> current;
        backtrack(s, 0, current, result);
        return result;
    }
};
```

**Example:**
```
s = "aab"

backtrack(start=0, current=[])
  end=0: "a" is palindrome
    backtrack(start=1, current=["a"])
      end=1: "a" is palindrome
        backtrack(start=2, current=["a","a"])
          end=2: "b" is palindrome
            backtrack(start=3, current=["a","a","b"])
              Found solution: ["a","a","b"] ‚úì
      end=2: "ab" not palindrome, skip
  end=1: "aa" is palindrome
    backtrack(start=2, current=["aa"])
      end=2: "b" is palindrome
        backtrack(start=3, current=["aa","b"])
          Found solution: ["aa","b"] ‚úì
  end=2: "aab" not palindrome, skip

Result: [["a","a","b"], ["aa","b"]]
```

### Pattern 3: Word Search

**Find if word exists in board.**

```cpp
class Solution {
private:
    bool backtrack(vector<vector<char>>& board, string& word, int idx,
                   int row, int col, vector<vector<bool>>& visited) {
        // Found word
        if (idx == word.length()) return true;
        
        // Out of bounds or visited or wrong character
        if (row < 0 || row >= board.size() || 
            col < 0 || col >= board[0].size() ||
            visited[row][col] || board[row][col] != word[idx]) {
            return false;
        }
        
        // Mark visited
        visited[row][col] = true;
        
        // Try all 4 directions
        int dx[] = {0, 0, 1, -1};
        int dy[] = {1, -1, 0, 0};
        
        for (int d = 0; d < 4; d++) {
            int newRow = row + dx[d];
            int newCol = col + dy[d];
            
            if (backtrack(board, word, idx + 1, newRow, newCol, visited)) {
                return true;  // Early exit
            }
        }
        
        // Backtrack
        visited[row][col] = false;
        return false;
    }
    
public:
    bool exist(vector<vector<char>>& board, string word) {
        int m = board.size(), n = board[0].size();
        vector<vector<bool>> visited(m, vector<bool>(n, false));
        
        // Try starting from each cell
        for (int r = 0; r < m; r++) {
            for (int c = 0; c < n; c++) {
                if (backtrack(board, word, 0, r, c, visited)) {
                    return true;
                }
            }
        }
        
        return false;
    }
};
```

### Pattern 4: Generate Parentheses

**Generate all valid combinations of n pairs of parentheses.**

```cpp
void backtrack(int n, int open, int close, string current,
               vector<string>& result) {
    // Base case: used all parentheses
    if (current.length() == 2 * n) {
        result.push_back(current);
        return;
    }
    
    // Add opening parenthesis (if haven't used all)
    if (open < n) {
        backtrack(n, open + 1, close, current + '(', result);
    }
    
    // Add closing parenthesis (only if valid)
    if (close < open) {
        backtrack(n, open, close + 1, current + ')', result);
    }
}

vector<string> generateParenthesis(int n) {
    vector<string> result;
    backtrack(n, 0, 0, "", result);
    return result;
}
```

**Trace (n=3):**
```
backtrack(open=0, close=0, current="")
  Add '(': backtrack(1, 0, "(")
    Add '(': backtrack(2, 0, "((")
      Add '(': backtrack(3, 0, "(((")
        Add ')': backtrack(3, 1, "((()") 
          Add ')': backtrack(3, 2, "((())") 
            Add ')': backtrack(3, 3, "((()))") ‚úì
      Add ')': backtrack(2, 1, "(()") 
        Add '(': backtrack(3, 1, "(()(") 
          Add ')': backtrack(3, 2, "(()()") 
            Add ')': backtrack(3, 3, "(()())") ‚úì
        Add ')': backtrack(2, 2, "(())") 
          Add '(': backtrack(3, 2, "(())(") 
            Add ')': backtrack(3, 3, "(())()") ‚úì
    Add ')': backtrack(1, 1, "()")
      ... similar ...

Result: ["((()))", "(()())", "(())()", "()(())", "()()()"]
```

**Time:** O(4^n / ‚àön) - Catalan number

### Pattern 5: Letter Combinations of Phone Number

**Generate all letter combinations for phone digits.**

```cpp
class Solution {
private:
    vector<string> mapping = {
        "",     // 0
        "",     // 1
        "abc",  // 2
        "def",  // 3
        "ghi",  // 4
        "jkl",  // 5
        "mno",  // 6
        "pqrs", // 7
        "tuv",  // 8
        "wxyz"  // 9
    };
    
    void backtrack(string& digits, int idx, string& current,
                   vector<string>& result) {
        if (idx == digits.length()) {
            result.push_back(current);
            return;
        }
        
        int digit = digits[idx] - '0';
        string letters = mapping[digit];
        
        for (char c : letters) {
            current.push_back(c);
            backtrack(digits, idx + 1, current, result);
            current.pop_back();
        }
    }
    
public:
    vector<string> letterCombinations(string digits) {
        if (digits.empty()) return {};
        
        vector<string> result;
        string current;
        backtrack(digits, 0, current, result);
        return result;
    }
};
```

**Example:**
```
digits = "23"

Mapping: 2‚Üí"abc", 3‚Üí"def"

backtrack(idx=0, current="")
  c='a': backtrack(idx=1, current="a")
    c='d': backtrack(idx=2, current="ad") ‚Üí add "ad" ‚úì
    c='e': backtrack(idx=2, current="ae") ‚Üí add "ae" ‚úì
    c='f': backtrack(idx=2, current="af") ‚Üí add "af" ‚úì
  c='b': backtrack(idx=1, current="b")
    c='d': backtrack(idx=2, current="bd") ‚Üí add "bd" ‚úì
    c='e': backtrack(idx=2, current="be") ‚Üí add "be" ‚úì
    c='f': backtrack(idx=2, current="bf") ‚Üí add "bf" ‚úì
  c='c': backtrack(idx=1, current="c")
    c='d': backtrack(idx=2, current="cd") ‚Üí add "cd" ‚úì
    c='e': backtrack(idx=2, current="ce") ‚Üí add "ce" ‚úì
    c='f': backtrack(idx=2, current="cf") ‚Üí add "cf" ‚úì

Result: ["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

---

## Summary Tables

### Backtracking Patterns

| Problem Type | State | Choices | Base Case |
|-------------|-------|---------|-----------|
| Subsets | Current subset | Add/skip element | Processed all elements |
| Permutations | Current permutation | Unused elements | Permutation complete |
| Combinations | Current combo | Next elements | Target sum reached |
| N-Queens | Board + row | Columns | All queens placed |
| Sudoku | Board + cell | Digits 1-9 | All cells filled |

### Time Complexities

| Problem | Without Pruning | With Pruning | Typical |
|---------|----------------|--------------|---------|
| Subsets | O(2^n √ó n) | O(2^n √ó n) | O(2^n √ó n) |
| Permutations | O(n! √ó n) | O(n! √ó n) | O(n! √ó n) |
| N-Queens | O(n^n) | O(N!) | O(N!) |
| Sudoku | O(9^81) | O(9^m) | ~O(1) with good heuristics |
| Combination Sum | O(2^n √ó n) | Much better | Depends on target |

### Pruning Strategies

| Strategy | When to Use | Example |
|----------|-------------|---------|
| Constraint check | Invalid state | N-Queens: isSafe() |
| Bound check | Optimization problem | Branch and bound |
| Duplicate skip | Repeated states | Permutations with dups |
| Early termination | First solution | Sudoku solver |
| Heuristic ordering | Complex search | Most constrained first |

### State Design Choices

| Data Structure | Use Case | Pros | Cons |
|---------------|----------|------|------|
| vector<int> | Sequences | Easy to modify | O(1) copy needed |
| set<int> | Uniqueness | No duplicates | O(log n) operations |
| vector<bool> | Flags | Fast, compact | Need index mapping |
| Bitmask (int) | Boolean flags | Very fast | Limited to 32/64 bits |
| unordered_set | Fast lookup | O(1) average | More memory |

---

## Practice Problems

### Subsets & Combinations
- [ ] Subsets
- [ ] Subsets II (with duplicates)
- [ ] Combination Sum I, II, III
- [ ] Generate Parentheses
- [ ] Letter Combinations of Phone Number

### Permutations
- [ ] Permutations
- [ ] Permutations II (with duplicates)
- [ ] Next Permutation
- [ ] Permutation Sequence
- [ ] Beautiful Arrangement

### Board Problems
- [ ] N-Queens
- [ ] N-Queens II (count only)
- [ ] Sudoku Solver
- [ ] Word Search
- [ ] Word Search II (with Trie)

### Partitioning
- [ ] Palindrome Partitioning
- [ ] Partition Equal Subset Sum
- [ ] Partition to K Equal Sum Subsets
- [ ] Split Array into Fibonacci Sequence

### Advanced
- [ ] Expression Add Operators
- [ ] Remove Invalid Parentheses
- [ ] Robot Room Cleaner
- [ ] Verbal Arithmetic Puzzle
- [ ] Maximum Length of a Concatenated String

---

## Key Takeaways

1. **Backtracking = Choose, Explore, Unchoose** - always restore state
2. **Pruning is critical** - check validity BEFORE recursing
3. **State design matters** - minimal but sufficient information
4. **Early exit** - return true/false to propagate solution found
5. **Use visited set/array** - avoid revisiting states
6. **Sort when needed** - enables duplicate skipping and pruning
7. **Most constrained first** - fail fast, reduce search space
8. **Bitmasks for speed** - when dealing with boolean flags
9. **Draw the tree** - visualize recursion to understand flow
10. **Base case is crucial** - prevents infinite recursion

Master these recursion and backtracking patterns and you'll efficiently solve complex combinatorial problems! üöÄ
