# Heap & Priority Queue - Complete Guide

## Table of Contents
1. [Heap Fundamentals](#heap-fundamentals)
2. [Min Heap vs Max Heap](#min-heap-vs-max-heap)
3. [Priority Queue in C++](#priority-queue-in-c)
4. [Custom Comparators](#custom-comparators)
5. [Heap Operations](#heap-operations)
6. [Top-K Problems](#top-k-problems)
7. [Running Median](#running-median)
8. [Merge K Lists](#merge-k-lists)
9. [Scheduling Problems](#scheduling-problems)
10. [Advanced Patterns](#advanced-patterns)
11. [Common Problems](#common-problems)

---

## Heap Fundamentals

### What is a Heap?

**Heap:** A complete binary tree where each node satisfies the heap property.

**Heap Property:**
- **Min Heap:** Parent ‚â§ Children (smallest at root)
- **Max Heap:** Parent ‚â• Children (largest at root)

**Visual:**
```
Max Heap:              Min Heap:
    50                     1
   /  \                   / \
  30   40                2   3
 / \   /               / \ /
10 20 35              4  5 6
```

### Why Heap?

**Advantages:**
‚úÖ **O(1) access to min/max** - Root is always min/max  
‚úÖ **O(log n) insert/delete** - Height = log n  
‚úÖ **O(n) build from array** - Heapify is linear!  
‚úÖ **Space efficient** - Array implementation (no pointers)

**Use cases:**
- Priority queues
- Top-K problems
- Running median
- Dijkstra's algorithm
- Heap sort

### Heap as Array

**Complete binary tree ‚Üí Array representation:**

```
Index formula:
  Parent of i:     (i - 1) / 2
  Left child of i:  2*i + 1
  Right child of i: 2*i + 2

Max Heap:
       50
      /  \
    30    40
   / \    /
  10 20  35

Array: [50, 30, 40, 10, 20, 35]
Index:  0   1   2   3   4   5

Relationships:
  50 (index 0):
    Left child: index 1 (30) = 2*0+1
    Right child: index 2 (40) = 2*0+2
  
  30 (index 1):
    Parent: index 0 (50) = (1-1)/2
    Left child: index 3 (10) = 2*1+1
    Right child: index 4 (20) = 2*1+2
```

**Why complete binary tree?**
- No gaps in array
- Space efficient
- Easy parent/child calculation

---

## Min Heap vs Max Heap

### Max Heap

**Property:** Parent ‚â• All children

```
       100
      /   \
    80     90
   / \    / \
  60 70  50 40

Root = 100 (maximum)
```

**Operations:**
- `getMax()`: O(1) - Return root
- `insert(x)`: O(log n) - Add and bubble up
- `deleteMax()`: O(log n) - Remove root and bubble down

**Use cases:**
- Find K largest elements
- Scheduling (highest priority first)
- Max heapify for heap sort

### Min Heap

**Property:** Parent ‚â§ All children

```
        1
      /   \
     3     2
    / \   / \
   7  5  6  4

Root = 1 (minimum)
```

**Operations:**
- `getMin()`: O(1) - Return root
- `insert(x)`: O(log n) - Add and bubble up
- `deleteMin()`: O(log n) - Remove root and bubble down

**Use cases:**
- Find K smallest elements
- Dijkstra's shortest path
- Merge K sorted lists

### Key Difference

| Operation | Max Heap | Min Heap |
|-----------|----------|----------|
| Root | Maximum | Minimum |
| Parent relation | Parent ‚â• Child | Parent ‚â§ Child |
| Extract | Largest | Smallest |
| Top-K largest | Keep min heap size K | ‚ùå |
| Top-K smallest | ‚ùå | Keep min heap size K |

**Trick:** To find K largest with min heap:
```
Keep min heap of size K
If new element > heap.top(), remove top and add new
Smallest in heap = Kth largest overall
```

---

## Priority Queue in C++

### Default Priority Queue (Max Heap)

```cpp
#include <queue>
using namespace std;

priority_queue<int> maxHeap;  // Default is max heap

// Operations
maxHeap.push(10);      // Insert: O(log n)
maxHeap.push(30);
maxHeap.push(20);

maxHeap.top();         // Access max: O(1) ‚Üí 30
maxHeap.pop();         // Remove max: O(log n)
maxHeap.size();        // Size: O(1) ‚Üí 2
maxHeap.empty();       // Check empty: O(1) ‚Üí false
```

**Internal:**
```
After push(10): [10]
After push(30): [30, 10]
After push(20): [30, 10, 20] (max heap property maintained)

Heap structure:
    30
   /  \
  10  20
```

### Min Heap

**Use `greater<int>` comparator:**

```cpp
priority_queue<int, vector<int>, greater<int>> minHeap;

minHeap.push(10);
minHeap.push(30);
minHeap.push(20);

minHeap.top();  // Access min: O(1) ‚Üí 10
```

**Syntax breakdown:**
```cpp
priority_queue<Type, Container, Comparator>
              ‚Üë       ‚Üë           ‚Üë
              int   vector<int>  greater<int>
              
Default max heap:
  priority_queue<int> 
  = priority_queue<int, vector<int>, less<int>>
  
Min heap:
  priority_queue<int, vector<int>, greater<int>>
```

### Common Operations

```cpp
priority_queue<int> pq;

// Check if empty before accessing
if (!pq.empty()) {
    int top = pq.top();  // Don't pop yet
    pq.pop();            // Now remove
}

// Size
int size = pq.size();

// No direct access to middle elements!
// Can only access top (max/min)

// Iteration (destructive - empties heap)
while (!pq.empty()) {
    cout << pq.top() << " ";
    pq.pop();
}
```

**No iteration without destruction!**
```cpp
// If you need to iterate and keep heap:
priority_queue<int> temp = pq;  // Copy
while (!temp.empty()) {
    cout << temp.top() << " ";
    temp.pop();
}
// pq still intact
```

---

## Custom Comparators

### Custom Comparator for Pairs

**Problem:** Max heap by first element, min by second if tie.

**Method 1: Custom struct with operator<**
```cpp
struct Pair {
    int first, second;
    
    // Define comparison (note: reversed for max heap!)
    bool operator<(const Pair& other) const {
        if (first != other.first) {
            return first < other.first;  // Max heap by first
        }
        return second > other.second;    // Min by second
    }
};

priority_queue<Pair> pq;
pq.push({3, 10});
pq.push({3, 5});
pq.push({5, 20});

// Top: {5, 20} ‚Üí largest first
// If first same, smallest second
```

**Why reversed?** 
```
priority_queue uses less<T> internally:
  If a < b, then b has higher priority (goes to top)
  
For max heap behavior (larger first):
  Return first < other.first
  This makes larger values have higher priority
```

**Method 2: Lambda comparator**
```cpp
auto cmp = [](const pair<int,int>& a, const pair<int,int>& b) {
    if (a.first != b.first) {
        return a.first < b.first;  // Max by first
    }
    return a.second > b.second;    // Min by second
};

priority_queue<pair<int,int>, vector<pair<int,int>>, decltype(cmp)> pq(cmp);

pq.push({3, 10});
pq.push({3, 5});
pq.push({5, 20});
```

**Method 3: Comparator class (functor)**
```cpp
struct ComparePair {
    bool operator()(const pair<int,int>& a, const pair<int,int>& b) {
        if (a.first != b.first) {
            return a.first < b.first;
        }
        return a.second > b.second;
    }
};

priority_queue<pair<int,int>, vector<pair<int,int>>, ComparePair> pq;
```

### Min Heap with Custom Type

```cpp
struct Task {
    int priority;
    string name;
};

// Min heap by priority
struct CompareTask {
    bool operator()(const Task& a, const Task& b) {
        return a.priority > b.priority;  // Min heap (reverse!)
    }
};

priority_queue<Task, vector<Task>, CompareTask> taskQueue;

taskQueue.push({1, "High priority"});
taskQueue.push({3, "Low priority"});
taskQueue.push({2, "Medium priority"});

// Top: {1, "High priority"} (smallest priority)
```

### Comparator Cheat Sheet

| Heap Type | Comparator | Logic |
|-----------|------------|-------|
| Max heap (int) | `less<int>` | Default |
| Min heap (int) | `greater<int>` | Reverse |
| Max by field | `return a.field < b.field` | Seems backward! |
| Min by field | `return a.field > b.field` | Seems backward! |

**Remember:** Comparator returns true if **first argument has LOWER priority**.

---

## Heap Operations

### Insert (Bubble Up)

**Add element and restore heap property:**

```cpp
void insert(vector<int>& heap, int val) {
    heap.push_back(val);  // Add at end
    
    int i = heap.size() - 1;
    
    // Bubble up
    while (i > 0) {
        int parent = (i - 1) / 2;
        
        if (heap[i] > heap[parent]) {  // Max heap
            swap(heap[i], heap[parent]);
            i = parent;
        } else {
            break;
        }
    }
}
```

**How it works:**
```
Max heap: [50, 30, 40, 10, 20]
Insert 60:

Step 1: Add to end
  [50, 30, 40, 10, 20, 60]
         0   1   2   3   4   5
  
  Tree:
      50
     /  \
   30    40
  / \    /
 10 20  60  ‚Üê New element

Step 2: Compare with parent (index 2)
  60 > 40, swap
  [50, 30, 60, 10, 20, 40]
  
  Tree:
      50
     /  \
   30    60  ‚Üê Moved up
  / \    /
 10 20  40

Step 3: Compare with parent (index 0)
  60 > 50, swap
  [60, 30, 50, 10, 20, 40]
  
  Tree:
      60  ‚Üê New root
     /  \
   30    50
  / \    /
 10 20  40

Done! 60 is at root.
```

**Time:** O(log n) - Height of tree

### Delete Max/Min (Bubble Down)

**Remove root and restore heap property:**

```cpp
void deleteMax(vector<int>& heap) {
    if (heap.empty()) return;
    
    // Replace root with last element
    heap[0] = heap.back();
    heap.pop_back();
    
    int i = 0;
    int n = heap.size();
    
    // Bubble down
    while (true) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        
        // Find largest among root, left, right
        if (left < n && heap[left] > heap[largest]) {
            largest = left;
        }
        if (right < n && heap[right] > heap[largest]) {
            largest = right;
        }
        
        // If largest is not root, swap and continue
        if (largest != i) {
            swap(heap[i], heap[largest]);
            i = largest;
        } else {
            break;
        }
    }
}
```

**How it works:**
```
Max heap: [60, 30, 50, 10, 20, 40]

Delete max (60):

Step 1: Replace root with last element
  [40, 30, 50, 10, 20]
   ‚Üë was last element
  
  Tree:
      40  ‚Üê Violates heap property!
     /  \
   30    50
  / \
 10 20

Step 2: Compare with children (30, 50)
  Largest child = 50 > 40
  Swap with 50
  [50, 30, 40, 10, 20]
  
  Tree:
      50  ‚Üê Swapped
     /  \
   30    40
  / \
 10 20

Step 3: Compare 40 with its children
  40 has no children
  Done!

Final: [50, 30, 40, 10, 20]
```

**Time:** O(log n)

### Heapify (Build Heap)

**Convert array to heap in O(n):**

```cpp
void heapify(vector<int>& arr, int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    
    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }
    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }
    
    if (largest != i) {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);  // Recursively heapify affected subtree
    }
}

void buildHeap(vector<int>& arr) {
    int n = arr.size();
    
    // Start from last non-leaf node
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }
}
```

**How it works:**
```
Array: [4, 10, 3, 5, 1]

Tree (not a heap):
      4
     / \
    10  3
   / \
  5   1

Last non-leaf: index (5/2 - 1) = 1 (node 10)

Step 1: Heapify node at index 1 (10)
  Children: 5, 1
  10 > 5, 10 > 1, no swap needed

Step 2: Heapify node at index 0 (4)
  Children: 10, 3
  10 > 4, swap
  [10, 4, 3, 5, 1]
  
  Tree:
      10
     / \
    4   3
   / \
  5   1
  
  Now heapify affected subtree (4):
    Children: 5, 1
    5 > 4, swap
    [10, 5, 3, 4, 1]
    
  Tree:
      10
     / \
    5   3
   / \
  4   1

Done! Max heap property satisfied.
```

**Why O(n)?**
```
Leaves (50% of nodes): 0 swaps
Level above leaves (25%): max 1 swap each
Next level (12.5%): max 2 swaps each
...

Total: n/2*0 + n/4*1 + n/8*2 + ... = O(n)
```

---

## Top-K Problems

### Pattern 1: K Largest Elements

**Use min heap of size K!**

```cpp
vector<int> findKLargest(vector<int>& nums, int k) {
    priority_queue<int, vector<int>, greater<int>> minHeap;
    
    for (int num : nums) {
        minHeap.push(num);
        
        if (minHeap.size() > k) {
            minHeap.pop();  // Remove smallest
        }
    }
    
    // All elements in heap are K largest
    vector<int> result;
    while (!minHeap.empty()) {
        result.push_back(minHeap.top());
        minHeap.pop();
    }
    
    return result;
}
```

**How it works:**
```
nums = [3, 1, 5, 12, 2, 11], k = 3
Find 3 largest

Process 3:
  minHeap: [3]

Process 1:
  minHeap: [1, 3]

Process 5:
  minHeap: [1, 3, 5]

Process 12:
  minHeap: [1, 3, 5, 12]
  Size > 3, pop min (1)
  minHeap: [3, 5, 12]

Process 2:
  minHeap: [2, 3, 5, 12]
  Size > 3, pop min (2)
  minHeap: [3, 5, 12]

Process 11:
  minHeap: [3, 5, 11, 12]
  Size > 3, pop min (3)
  minHeap: [5, 11, 12]

Result: [5, 11, 12] ‚úì (3 largest)
```

**Why min heap for K largest?**
```
Min heap keeps smallest of K largest at top
Easy to evict when new larger element arrives

Example: K=3, current heap [5, 11, 12]
  New element 8:
    8 > 5 (top), so 8 should be in K largest
    Remove 5, add 8
    New heap: [8, 11, 12]
```

**Time:** O(n log k), **Space:** O(k)

### Pattern 2: K Smallest Elements

**Use max heap of size K!**

```cpp
vector<int> findKSmallest(vector<int>& nums, int k) {
    priority_queue<int> maxHeap;  // Default max heap
    
    for (int num : nums) {
        maxHeap.push(num);
        
        if (maxHeap.size() > k) {
            maxHeap.pop();  // Remove largest
        }
    }
    
    vector<int> result;
    while (!maxHeap.empty()) {
        result.push_back(maxHeap.top());
        maxHeap.pop();
    }
    
    return result;
}
```

### Pattern 3: Kth Largest Element

**QuickSelect is O(n) average, but heap is simpler:**

```cpp
int findKthLargest(vector<int>& nums, int k) {
    priority_queue<int, vector<int>, greater<int>> minHeap;
    
    for (int num : nums) {
        minHeap.push(num);
        if (minHeap.size() > k) {
            minHeap.pop();
        }
    }
    
    return minHeap.top();  // Kth largest
}
```

**Example:**
```
nums = [3, 2, 1, 5, 6, 4], k = 2
Find 2nd largest

After processing all:
  minHeap: [5, 6] (2 largest elements)
  Top = 5 = 2nd largest ‚úì
```

### Pattern 4: Top K Frequent Elements

**Use heap with frequency:**

```cpp
vector<int> topKFrequent(vector<int>& nums, int k) {
    // Count frequencies
    unordered_map<int, int> freq;
    for (int num : nums) {
        freq[num]++;
    }
    
    // Min heap of pairs (frequency, value)
    auto cmp = [](pair<int,int>& a, pair<int,int>& b) {
        return a.first > b.first;  // Min heap by frequency
    };
    priority_queue<pair<int,int>, vector<pair<int,int>>, decltype(cmp)> minHeap(cmp);
    
    for (auto& [num, count] : freq) {
        minHeap.push({count, num});
        if (minHeap.size() > k) {
            minHeap.pop();
        }
    }
    
    // Extract values
    vector<int> result;
    while (!minHeap.empty()) {
        result.push_back(minHeap.top().second);
        minHeap.pop();
    }
    
    return result;
}
```

**Example:**
```
nums = [1,1,1,2,2,3], k = 2

Frequency map:
  1 ‚Üí 3
  2 ‚Üí 2
  3 ‚Üí 1

Process (3, 1):
  minHeap: [(3, 1)]

Process (2, 2):
  minHeap: [(2, 2), (3, 1)]

Process (1, 3):
  minHeap: [(1, 3), (2, 2), (3, 1)]
  Size > 2, pop (1, 3)
  minHeap: [(2, 2), (3, 1)]

Result: [2, 1] (2 most frequent) ‚úì
```

**Time:** O(n log k), **Space:** O(n)

---

## Running Median

### Two Heap Approach

**Key insight:** Split numbers into two halves.

```
Small half (max heap)  |  Large half (min heap)
[smaller numbers]      |  [larger numbers]
```

**Median:**
- If sizes equal: `(maxHeap.top() + minHeap.top()) / 2`
- If odd: `maxHeap.top()` (keep maxHeap larger by 1)

```cpp
class MedianFinder {
private:
    priority_queue<int> maxHeap;  // Smaller half
    priority_queue<int, vector<int>, greater<int>> minHeap;  // Larger half
    
public:
    void addNum(int num) {
        // Add to maxHeap first
        maxHeap.push(num);
        
        // Balance: ensure all in maxHeap ‚â§ all in minHeap
        minHeap.push(maxHeap.top());
        maxHeap.pop();
        
        // Maintain size: maxHeap has ‚â• minHeap
        if (maxHeap.size() < minHeap.size()) {
            maxHeap.push(minHeap.top());
            minHeap.pop();
        }
    }
    
    double findMedian() {
        if (maxHeap.size() > minHeap.size()) {
            return maxHeap.top();
        } else {
            return (maxHeap.top() + minHeap.top()) / 2.0;
        }
    }
};
```

**How it works:**
```
Add numbers: [5, 15, 1, 3]

Add 5:
  maxHeap.push(5): maxHeap = [5]
  Balance: minHeap.push(5), maxHeap = []
           minHeap = [5]
  Size fix: maxHeap.push(5), maxHeap = [5]
            minHeap = []
  
  State: maxHeap = [5], minHeap = []
  Median = 5

Add 15:
  maxHeap.push(15): maxHeap = [15, 5]
  Balance: minHeap.push(15), maxHeap = [5]
           minHeap = [15]
  Sizes equal (1, 1)
  
  State: maxHeap = [5], minHeap = [15]
  Median = (5 + 15) / 2 = 10

Add 1:
  maxHeap.push(1): maxHeap = [5, 1]
  Balance: minHeap.push(5), maxHeap = [1]
           minHeap = [5, 15]
  Size fix: maxHeap.push(5), maxHeap = [5, 1]
            minHeap = [15]
  
  State: maxHeap = [5, 1], minHeap = [15]
  Median = 5

Add 3:
  maxHeap.push(3): maxHeap = [5, 1, 3]
  Balance: minHeap.push(5), maxHeap = [3, 1]
           minHeap = [5, 15]
  Sizes equal (2, 2)
  
  State: maxHeap = [3, 1], minHeap = [5, 15]
  Median = (3 + 5) / 2 = 4

Sorted: [1, 3, 5, 15]
        ‚Üë  ‚Üë
     maxHeap.top = 3, minHeap.top = 5
     Median = (3 + 5) / 2 = 4 ‚úì
```

**Visual:**
```
After adding [5, 15, 1, 3]:

maxHeap (max heap):     minHeap (min heap):
      3                       5
     /                         \
    1                          15

Smaller half: [1, 3]    Larger half: [5, 15]
Max of small = 3        Min of large = 5
Median = (3 + 5) / 2 = 4
```

**Invariants:**
1. `maxHeap.size() == minHeap.size()` OR `maxHeap.size() == minHeap.size() + 1`
2. All elements in maxHeap ‚â§ all elements in minHeap
3. `maxHeap.top()` is the middle element (or left middle if even)

**Time:** 
- `addNum()`: O(log n)
- `findMedian()`: O(1)

**Space:** O(n)

---

## Merge K Lists

### Merge K Sorted Lists

**Use min heap to track smallest from each list:**

```cpp
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

ListNode* mergeKLists(vector<ListNode*>& lists) {
    // Min heap by value
    auto cmp = [](ListNode* a, ListNode* b) {
        return a->val > b->val;
    };
    priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> minHeap(cmp);
    
    // Add first node from each list
    for (ListNode* list : lists) {
        if (list) {
            minHeap.push(list);
        }
    }
    
    ListNode* dummy = new ListNode(0);
    ListNode* curr = dummy;
    
    while (!minHeap.empty()) {
        ListNode* node = minHeap.top();
        minHeap.pop();
        
        curr->next = node;
        curr = curr->next;
        
        // Add next node from same list
        if (node->next) {
            minHeap.push(node->next);
        }
    }
    
    return dummy->next;
}
```

**How it works:**
```
Lists:
  1 ‚Üí 4 ‚Üí 5
  1 ‚Üí 3 ‚Üí 4
  2 ‚Üí 6

Initial heap: [1, 1, 2] (heads of each list)

Step 1: Pop 1 (from list 1)
  Add to result: 1
  Push next from list 1: 4
  Heap: [1, 2, 4]

Step 2: Pop 1 (from list 2)
  Add to result: 1 ‚Üí 1
  Push next from list 2: 3
  Heap: [2, 3, 4]

Step 3: Pop 2
  Add to result: 1 ‚Üí 1 ‚Üí 2
  Push next: 6
  Heap: [3, 4, 6]

Step 4: Pop 3
  Add to result: 1 ‚Üí 1 ‚Üí 2 ‚Üí 3
  Push next: 4
  Heap: [4, 4, 6]

Step 5: Pop 4 (from list 1)
  Add to result: 1 ‚Üí 1 ‚Üí 2 ‚Üí 3 ‚Üí 4
  Push next: 5
  Heap: [4, 5, 6]

Step 6: Pop 4 (from list 2)
  Add to result: 1 ‚Üí 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 4
  No next
  Heap: [5, 6]

Step 7: Pop 5
  Add to result: 1 ‚Üí 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 4 ‚Üí 5
  Heap: [6]

Step 8: Pop 6
  Result: 1 ‚Üí 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 4 ‚Üí 5 ‚Üí 6 ‚úì
```

**Why heap?**
- Always get minimum across all lists in O(log k)
- Better than comparing all k heads each time (O(k))

**Time:** O(N log k) where N = total nodes, k = number of lists  
**Space:** O(k) for heap

### Merge K Sorted Arrays

```cpp
vector<int> mergeKArrays(vector<vector<int>>& arrays) {
    // Heap element: (value, arrayIndex, elementIndex)
    auto cmp = [](const tuple<int,int,int>& a, const tuple<int,int,int>& b) {
        return get<0>(a) > get<0>(b);  // Min heap by value
    };
    priority_queue<tuple<int,int,int>, vector<tuple<int,int,int>>, decltype(cmp)> minHeap(cmp);
    
    // Add first element from each array
    for (int i = 0; i < arrays.size(); i++) {
        if (!arrays[i].empty()) {
            minHeap.push({arrays[i][0], i, 0});
        }
    }
    
    vector<int> result;
    
    while (!minHeap.empty()) {
        auto [val, arrayIdx, elemIdx] = minHeap.top();
        minHeap.pop();
        
        result.push_back(val);
        
        // Add next element from same array
        if (elemIdx + 1 < arrays[arrayIdx].size()) {
            minHeap.push({arrays[arrayIdx][elemIdx + 1], arrayIdx, elemIdx + 1});
        }
    }
    
    return result;
}
```

**Example:**
```
Arrays:
  [1, 4, 7]
  [2, 5, 8]
  [3, 6, 9]

Heap tracks: (value, array, index)

Initial: (1,0,0), (2,1,0), (3,2,0)
Pop (1,0,0): result=[1], push (4,0,1)
Pop (2,1,0): result=[1,2], push (5,1,1)
Pop (3,2,0): result=[1,2,3], push (6,2,1)
Pop (4,0,1): result=[1,2,3,4], push (7,0,2)
...
Final: [1,2,3,4,5,6,7,8,9]
```

---

## Scheduling Problems

### Pattern 1: Meeting Rooms II (Min Rooms)

**Find minimum conference rooms needed:**

```cpp
int minMeetingRooms(vector<vector<int>>& intervals) {
    if (intervals.empty()) return 0;
    
    // Sort by start time
    sort(intervals.begin(), intervals.end());
    
    // Min heap of end times
    priority_queue<int, vector<int>, greater<int>> minHeap;
    
    for (auto& interval : intervals) {
        int start = interval[0];
        int end = interval[1];
        
        // If earliest ending meeting finishes before this starts, reuse room
        if (!minHeap.empty() && minHeap.top() <= start) {
            minHeap.pop();
        }
        
        // Add this meeting's end time
        minHeap.push(end);
    }
    
    // Heap size = number of rooms needed
    return minHeap.size();
}
```

**How it works:**
```
Meetings: [[0,30], [5,10], [15,20]]

Sorted: [[0,30], [5,10], [15,20]]

Process [0,30]:
  Heap empty, can't reuse
  Add end time: minHeap = [30]
  Rooms = 1

Process [5,10]:
  Earliest end = 30 > 5 (start), can't reuse
  Add end time: minHeap = [10, 30]
  Rooms = 2

Process [15,20]:
  Earliest end = 10 ‚â§ 15 (start), can reuse! ‚úì
  Remove 10, add 20: minHeap = [20, 30]
  Rooms = 2

Answer: 2 rooms needed
```

**Visual timeline:**
```
Time:  0    5    10   15   20   30
Room1: [--------30---------]
Room2:      [--10--]  [--20--]
                ‚Üë Room freed, reused for [15,20]

Max overlap = 2 rooms
```

**Time:** O(n log n), **Space:** O(n)

### Pattern 2: Task Scheduler

**Schedule tasks with cooldown:**

```cpp
int leastInterval(vector<char>& tasks, int n) {
    // Count frequencies
    unordered_map<char, int> freq;
    for (char task : tasks) {
        freq[task]++;
    }
    
    // Max heap by frequency
    priority_queue<int> maxHeap;
    for (auto& [task, count] : freq) {
        maxHeap.push(count);
    }
    
    int time = 0;
    
    while (!maxHeap.empty()) {
        vector<int> temp;
        
        // Process up to (n+1) tasks in one cycle
        for (int i = 0; i <= n; i++) {
            if (!maxHeap.empty()) {
                int count = maxHeap.top();
                maxHeap.pop();
                
                if (count > 1) {
                    temp.push_back(count - 1);
                }
            }
        }
        
        // Add back remaining tasks
        for (int count : temp) {
            maxHeap.push(count);
        }
        
        // If heap empty, all tasks done
        time += maxHeap.empty() ? (temp.size() == 0 ? 0 : n + 1 - (n + 1 - temp.size())) : n + 1;
    }
    
    return time;
}
```

**Simpler formula-based approach:**
```cpp
int leastInterval(vector<char>& tasks, int n) {
    vector<int> freq(26, 0);
    for (char task : tasks) {
        freq[task - 'A']++;
    }
    
    sort(freq.rbegin(), freq.rend());
    
    int maxFreq = freq[0];
    int idleTime = (maxFreq - 1) * n;
    
    for (int i = 1; i < 26; i++) {
        idleTime -= min(freq[i], maxFreq - 1);
    }
    
    idleTime = max(0, idleTime);
    
    return tasks.size() + idleTime;
}
```

**How it works:**
```
tasks = ['A','A','A','B','B','B'], n = 2

Frequencies: A=3, B=3

Pattern (maxFreq = 3):
  A _ _ A _ _ A
  ‚Üë Fill gaps with other tasks
  
Add B:
  A B _ A B _ A B
  
All tasks used, 2 idle slots left
Actually optimal: A B idle A B idle A B

Time = 8 slots

Formula:
  maxFreq = 3
  (maxFreq - 1) * n = 2 * 2 = 4 (idle slots initially)
  Subtract B tasks: 4 - min(3, 2) = 4 - 2 = 2
  Total = 6 tasks + 2 idle = 8 ‚úì
```

**Time:** O(n), **Space:** O(1)

### Pattern 3: Process Tasks by Priority

```cpp
vector<int> processTasksByPriority(vector<int>& priority, vector<int>& arrival) {
    int n = priority.size();
    
    // (priority, index, arrival)
    auto cmp = [](const tuple<int,int,int>& a, const tuple<int,int,int>& b) {
        return get<0>(a) > get<0>(b);  // Min heap by priority
    };
    priority_queue<tuple<int,int,int>, vector<tuple<int,int,int>>, decltype(cmp)> pq(cmp);
    
    // Sort by arrival time
    vector<int> indices(n);
    iota(indices.begin(), indices.end(), 0);
    sort(indices.begin(), indices.end(), [&](int i, int j) {
        return arrival[i] < arrival[j];
    });
    
    vector<int> result;
    int time = 0;
    int idx = 0;
    
    while (idx < n || !pq.empty()) {
        // Add all tasks that have arrived
        while (idx < n && arrival[indices[idx]] <= time) {
            int i = indices[idx];
            pq.push({priority[i], i, arrival[i]});
            idx++;
        }
        
        if (pq.empty()) {
            // Jump to next arrival
            time = arrival[indices[idx]];
        } else {
            // Process highest priority task
            auto [pri, taskIdx, arr] = pq.top();
            pq.pop();
            result.push_back(taskIdx);
            time++;
        }
    }
    
    return result;
}
```

---

## Advanced Patterns

### Pattern 1: Sliding Window Maximum

**Use deque, but can also use heap with lazy deletion:**

```cpp
vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    priority_queue<pair<int,int>> maxHeap;  // (value, index)
    vector<int> result;
    
    for (int i = 0; i < nums.size(); i++) {
        maxHeap.push({nums[i], i});
        
        if (i >= k - 1) {
            // Remove elements outside window
            while (maxHeap.top().second <= i - k) {
                maxHeap.pop();
            }
            
            result.push_back(maxHeap.top().first);
        }
    }
    
    return result;
}
```

**Note:** Deque is better (O(n)), this is O(n log n).

### Pattern 2: Reorganize String

**No two same characters adjacent:**

```cpp
string reorganizeString(string s) {
    unordered_map<char, int> freq;
    for (char c : s) {
        freq[c]++;
    }
    
    // Max heap by frequency
    priority_queue<pair<int,char>> maxHeap;
    for (auto& [ch, count] : freq) {
        maxHeap.push({count, ch});
    }
    
    string result;
    pair<int,char> prev = {-1, '#'};
    
    while (!maxHeap.empty()) {
        auto [count, ch] = maxHeap.top();
        maxHeap.pop();
        
        result += ch;
        
        // Add previous character back if count > 0
        if (prev.first > 0) {
            maxHeap.push(prev);
        }
        
        prev = {count - 1, ch};
    }
    
    // Check if valid
    return result.size() == s.size() ? result : "";
}
```

**Example:**
```
s = "aab"

Frequencies: a=2, b=1
Heap: [(2,'a'), (1,'b')]

Step 1:
  Pop (2,'a'), add 'a'
  result = "a"
  prev = (1,'a')
  Heap: [(1,'b')]

Step 2:
  Pop (1,'b'), add 'b'
  Add prev (1,'a') back
  result = "ab"
  prev = (0,'b')
  Heap: [(1,'a')]

Step 3:
  Pop (1,'a'), add 'a'
  result = "aba" ‚úì
```

### Pattern 3: Ugly Number II

**Find nth ugly number (factors only 2, 3, 5):**

```cpp
int nthUglyNumber(int n) {
    priority_queue<long, vector<long>, greater<long>> minHeap;
    unordered_set<long> seen;
    
    minHeap.push(1);
    seen.insert(1);
    
    long ugly = 1;
    
    for (int i = 0; i < n; i++) {
        ugly = minHeap.top();
        minHeap.pop();
        
        // Generate new ugly numbers
        for (int factor : {2, 3, 5}) {
            long next = ugly * factor;
            if (seen.find(next) == seen.end()) {
                minHeap.push(next);
                seen.insert(next);
            }
        }
    }
    
    return ugly;
}
```

**Example:**
```
n = 10

Sequence: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12

i=0: ugly=1, add 2, 3, 5
i=1: ugly=2, add 4, 6, 10
i=2: ugly=3, add 6(dup), 9, 15
i=3: ugly=4, add 8, 12, 20
...
i=9: ugly=12 ‚úì
```

---

## Common Problems

### Problem 1: Last Stone Weight

```cpp
int lastStoneWeight(vector<int>& stones) {
    priority_queue<int> maxHeap(stones.begin(), stones.end());
    
    while (maxHeap.size() > 1) {
        int stone1 = maxHeap.top(); maxHeap.pop();
        int stone2 = maxHeap.top(); maxHeap.pop();
        
        if (stone1 != stone2) {
            maxHeap.push(stone1 - stone2);
        }
    }
    
    return maxHeap.empty() ? 0 : maxHeap.top();
}
```

### Problem 2: Kth Largest in Stream

```cpp
class KthLargest {
private:
    priority_queue<int, vector<int>, greater<int>> minHeap;
    int k;
    
public:
    KthLargest(int k, vector<int>& nums) : k(k) {
        for (int num : nums) {
            add(num);
        }
    }
    
    int add(int val) {
        minHeap.push(val);
        if (minHeap.size() > k) {
            minHeap.pop();
        }
        return minHeap.top();
    }
};
```

### Problem 3: Furthest Building

```cpp
int furthestBuilding(vector<int>& heights, int bricks, int ladders) {
    priority_queue<int, vector<int>, greater<int>> minHeap;
    
    for (int i = 0; i < heights.size() - 1; i++) {
        int climb = heights[i+1] - heights[i];
        if (climb <= 0) continue;
        
        minHeap.push(climb);
        
        if (minHeap.size() > ladders) {
            bricks -= minHeap.top();
            minHeap.pop();
        }
        
        if (bricks < 0) return i;
    }
    
    return heights.size() - 1;
}
```

---

## Summary Tables

### Min vs Max Heap

| Operation | Min Heap | Max Heap |
|-----------|----------|----------|
| Declaration | `priority_queue<int, vector<int>, greater<int>>` | `priority_queue<int>` |
| Top element | Minimum | Maximum |
| K largest | ‚úÖ Use min heap | ‚ùå |
| K smallest | ‚ùå | ‚úÖ Use max heap |
| Running min | ‚úÖ | ‚ùå |
| Running max | ‚ùå | ‚úÖ |

### Heap Operations

| Operation | Time | Note |
|-----------|------|------|
| `push()` | O(log n) | Bubble up |
| `pop()` | O(log n) | Bubble down |
| `top()` | O(1) | Access root |
| `size()` | O(1) | |
| `empty()` | O(1) | |
| Build heap | O(n) | Heapify |

### Common Patterns

| Problem Type | Heap Type | Size | Complexity |
|--------------|-----------|------|------------|
| K largest | Min heap | K | O(n log k) |
| K smallest | Max heap | K | O(n log k) |
| Running median | Two heaps | n | O(log n) per insert |
| Merge K lists | Min heap | K | O(N log k) |
| Task scheduling | Max heap (freq) | Varies | O(n log n) |
| Meeting rooms | Min heap (end time) | Active rooms | O(n log n) |

### Comparator Quick Reference

```cpp
// Max heap (default)
priority_queue<int> maxHeap;

// Min heap
priority_queue<int, vector<int>, greater<int>> minHeap;

// Custom: Max by first, min by second
auto cmp = [](pair<int,int>& a, pair<int,int>& b) {
    if (a.first != b.first) return a.first < b.first;
    return a.second > b.second;
};
priority_queue<pair<int,int>, vector<pair<int,int>>, decltype(cmp)> pq(cmp);
```

---

## Practice Problems

### Basic Heap
- [ ] Kth Largest Element in Array
- [ ] Top K Frequent Elements
- [ ] Kth Smallest Element in Sorted Matrix
- [ ] Last Stone Weight
- [ ] Kth Largest in Stream

### Two Heaps
- [ ] Find Median from Data Stream
- [ ] Sliding Window Median
- [ ] IPO (Maximize Capital)

### Merge
- [ ] Merge K Sorted Lists
- [ ] Smallest Range Covering Elements from K Lists
- [ ] Find K Pairs with Smallest Sums

### Scheduling
- [ ] Meeting Rooms II
- [ ] Task Scheduler
- [ ] Course Schedule III
- [ ] Single-Threaded CPU

### Advanced
- [ ] Reorganize String
- [ ] Rearrange String k Distance Apart
- [ ] Ugly Number II
- [ ] Super Ugly Number
- [ ] Furthest Building You Can Reach

---

## Key Takeaways

1. **K largest uses MIN heap** - Keep smallest of K largest at top for easy eviction
2. **K smallest uses MAX heap** - Keep largest of K smallest at top
3. **Running median uses TWO heaps** - Split into smaller (max heap) and larger (min heap)
4. **Merge K uses MIN heap** - Always get global minimum in O(log k)
5. **Comparator is reversed** - Return `a < b` for max heap behavior
6. **Heapify is O(n)** - Building heap from array is linear!
7. **Min heap: `greater<int>`** - Seems backward but that's the syntax
8. **Custom comparators** - Lambda, functor, or operator< override
9. **Lazy deletion** - Check index validity for sliding window
10. **Balance invariants** - Two heap median needs careful size management

Master these heap patterns and you'll efficiently handle priority-based problems! üî•

