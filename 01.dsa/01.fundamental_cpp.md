# C++ Fundamentals for Competitive Programming

## Table of Contents
1. [Tooling & Compilation](#tooling--compilation)
2. [Fast I/O](#fast-io)
3. [Debugging Techniques](#debugging-techniques)
4. [Templates](#templates)
5. [Lambdas](#lambdas)
6. [References & Move Semantics](#references--move-semantics)
7. [STL Containers Deep Dive](#stl-containers-deep-dive)
8. [Big-O Complexity](#big-o-complexity)
9. [Recurrences & Master Theorem](#recurrences--master-theorem)
10. [Memory Model](#memory-model)
11. [Integer Overflow](#integer-overflow)

---

## Tooling & Compilation

### g++ vs clang++

Both are C++ compilers. **g++** (GNU) is more common, **clang++** has better error messages.

### Basic Compilation

```bash
# Simple compilation
g++ solution.cpp -o solution

# Run the program
./solution
```

### Compilation Flags for CP

```bash
# Recommended flags for competitive programming
g++ -std=c++17 -O2 -Wall -Wextra -Wshadow -DLOCAL solution.cpp -o solution

# Explanation:
# -std=c++17     : Use C++17 standard (or c++20)
# -O2            : Optimization level 2 (faster code)
# -Wall -Wextra  : Show all warnings
# -Wshadow       : Warn about variable shadowing
# -DLOCAL        : Define LOCAL macro for debugging
```

### Debug vs Release Builds

```bash
# Debug build (with runtime checks, slower)
g++ -std=c++17 -g -fsanitize=address,undefined -D_GLIBCXX_DEBUG solution.cpp -o solution

# -g                          : Include debug symbols
# -fsanitize=address          : Detect memory errors
# -fsanitize=undefined        : Detect undefined behavior
# -D_GLIBCXX_DEBUG            : STL bounds checking

# Release build (for submission, fast)
g++ -std=c++17 -O2 solution.cpp -o solution
```

### Using a Makefile

```makefile
# Makefile
CXX = g++
CXXFLAGS = -std=c++17 -O2 -Wall -Wextra -Wshadow
DEBUGFLAGS = -g -fsanitize=address,undefined -D_GLIBCXX_DEBUG -DLOCAL

# Default target
solution: solution.cpp
	$(CXX) $(CXXFLAGS) solution.cpp -o solution

# Debug target
debug: solution.cpp
	$(CXX) $(DEBUGFLAGS) solution.cpp -o solution

# Clean
clean:
	rm -f solution

# Run with input
run: solution
	./solution < input.txt
```

```bash
# Usage
make              # Compile release
make debug        # Compile debug
make run          # Run with input.txt
make clean        # Remove executable
```

---

## Fast I/O

### Why Fast I/O Matters

**Problem:** `cin` and `cout` are slow because they synchronize with C's `scanf`/`printf` and flush after every operation.

**Solution:** Disable synchronization and tie.

### The Standard Fast I/O Setup

```cpp
int main() {
    ios_base::sync_with_stdio(false);  // Don't sync with C I/O
    cin.tie(NULL);                      // Don't flush cout before cin
    cout.tie(NULL);                     // Don't flush cout
    
    // Your code here
}
```

**What each line does:**
- `sync_with_stdio(false)`: Breaks sync between C++ streams and C streams. **Don't mix cin/cout with scanf/printf after this!**
- `cin.tie(NULL)`: Normally `cin` flushes `cout` before reading. We disable this.
- `cout.tie(NULL)`: Usually not needed, but some add it for consistency.

### Performance Comparison

```cpp
// SLOW (default)
int main() {
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) {
        int x;
        cin >> x;
        cout << x << "\n";
    }
}

// FAST
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) {
        int x;
        cin >> x;
        cout << x << "\n";
    }
}
```

**Speed difference:** Can be 3-10x faster for large inputs!

### endl vs "\n"

```cpp
// SLOW - flushes buffer every time
cout << x << endl;

// FAST - just adds newline
cout << x << "\n";
```

**Why:** `endl` = `"\n"` + flush. Flushing is expensive!

### Reading Entire Line

```cpp
string line;

// Method 1: getline (reads until newline)
getline(cin, line);

// Method 2: Read word by word
cin >> line;  // Stops at whitespace
```

### Reading Unknown Amount of Data

```cpp
int x;
while (cin >> x) {
    // Process x
}

// Or for multiple values per line
int a, b;
while (cin >> a >> b) {
    // Process a and b
}
```

---

## Debugging Techniques

### Debug Macro

```cpp
#ifdef LOCAL
    #define debug(x) cerr << #x << " = " << (x) << endl
    #define debug2(x, y) cerr << #x << " = " << (x) << ", " << #y << " = " << (y) << endl
#else
    #define debug(x)
    #define debug2(x, y)
#endif

int main() {
    int a = 5, b = 10;
    debug(a);           // Prints: a = 5
    debug2(a, b);       // Prints: a = 5, b = 10
    debug(a + b);       // Prints: a + b = 15
}
```

**How it works:**
- `#x` converts variable name to string
- Only compiles when `-DLOCAL` flag is used
- In submission, becomes empty (no overhead)

### Pretty Print for Containers

```cpp
#ifdef LOCAL
template<typename T>
void print_vector(const vector<T>& v) {
    cerr << "[ ";
    for (const auto& x : v) cerr << x << " ";
    cerr << "]\n";
}

template<typename T, typename U>
void print_pair(const pair<T, U>& p) {
    cerr << "(" << p.first << ", " << p.second << ")\n";
}

template<typename T>
void print_set(const set<T>& s) {
    cerr << "{ ";
    for (const auto& x : s) cerr << x << " ";
    cerr << "}\n";
}
#endif
```

### Assert for Testing

```cpp
#include <cassert>

int divide(int a, int b) {
    assert(b != 0);  // Program crashes if b == 0 (in debug mode)
    return a / b;
}

// Test cases
int main() {
    assert(divide(10, 2) == 5);
    assert(divide(7, 3) == 2);
    // assert(divide(10, 0));  // This would crash
}
```

### Trace Execution

```cpp
void solve() {
    cerr << "Starting solve()\n";
    
    int n;
    cin >> n;
    cerr << "Read n = " << n << "\n";
    
    vector<int> arr(n);
    cerr << "Created vector of size " << n << "\n";
    
    // ... rest of code
}
```

---

## Templates

### What are Templates?

Templates let you write **generic code** that works with any data type.

### Function Templates

```cpp
// Without template - need separate functions
int max_int(int a, int b) { return a > b ? a : b; }
double max_double(double a, double b) { return a > b ? a : b; }

// With template - one function for all types
template<typename T>
T max_value(T a, T b) {
    return a > b ? a : b;
}

int main() {
    cout << max_value(3, 5) << "\n";           // Uses int version
    cout << max_value(3.14, 2.71) << "\n";     // Uses double version
    cout << max_value('a', 'z') << "\n";       // Uses char version
}
```

**How it works:** Compiler generates a separate function for each type you use.

### Multiple Template Parameters

```cpp
template<typename T, typename U>
auto add(T a, U b) {
    return a + b;  // Return type deduced automatically
}

int main() {
    cout << add(5, 3.14) << "\n";      // int + double = double
    cout << add(2.5, 3) << "\n";       // double + int = double
}
```

### Class Templates

```cpp
template<typename T>
class Stack {
    vector<T> data;
    
public:
    void push(T val) { data.push_back(val); }
    T pop() { 
        T val = data.back(); 
        data.pop_back(); 
        return val; 
    }
    bool empty() { return data.empty(); }
};

int main() {
    Stack<int> s1;
    s1.push(10);
    s1.push(20);
    
    Stack<string> s2;
    s2.push("hello");
    s2.push("world");
}
```

### Common CP Template Shortcuts

```cpp
template<typename T>
using v = vector<T>;

template<typename T>
using vv = vector<vector<T>>;

// Usage
v<int> arr = {1, 2, 3};
vv<int> matrix(5, v<int>(5, 0));
```

---

## Lambdas

### What are Lambdas?

Anonymous functions you can define inline. Very useful for custom sorting and algorithms.

### Basic Syntax

```cpp
// Basic lambda
auto add = [](int a, int b) { return a + b; };
cout << add(3, 5) << "\n";  // 8

// Lambda with type inference
auto multiply = [](auto a, auto b) { return a * b; };
cout << multiply(3, 5) << "\n";      // 15
cout << multiply(2.5, 4.0) << "\n";  // 10.0
```

**Syntax:** `[capture](parameters) { body }`

### Capture Clause

Captures variables from surrounding scope.

```cpp
int x = 10;
int y = 20;

// [=] - capture all by value (copy)
auto f1 = [=]() { return x + y; };
cout << f1() << "\n";  // 30

// [&] - capture all by reference
auto f2 = [&]() { x = 100; };
f2();
cout << x << "\n";  // 100

// [x] - capture only x by value
auto f3 = [x]() { return x * 2; };

// [&y] - capture only y by reference
auto f4 = [&y]() { y = 50; };

// [x, &y] - x by value, y by reference
auto f5 = [x, &y]() { return x + y; };
```

### Lambdas in Sorting

```cpp
vector<int> arr = {3, 1, 4, 1, 5, 9, 2, 6};

// Sort descending
sort(arr.begin(), arr.end(), [](int a, int b) {
    return a > b;  // Return true if a should come before b
});

// Sort by absolute value
sort(arr.begin(), arr.end(), [](int a, int b) {
    return abs(a) < abs(b);
});

// Sort pairs by second element
vector<pair<int, int>> pairs = {{1, 5}, {2, 3}, {3, 8}};
sort(pairs.begin(), pairs.end(), [](auto a, auto b) {
    return a.second < b.second;
});
```

### Lambdas with STL Algorithms

```cpp
vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

// Count even numbers
int cnt = count_if(arr.begin(), arr.end(), [](int x) {
    return x % 2 == 0;
});

// Find first number > 5
auto it = find_if(arr.begin(), arr.end(), [](int x) {
    return x > 5;
});

// Transform (multiply by 2)
transform(arr.begin(), arr.end(), arr.begin(), [](int x) {
    return x * 2;
});

// Remove if odd
arr.erase(remove_if(arr.begin(), arr.end(), [](int x) {
    return x % 2 != 0;
}), arr.end());
```

### Recursive Lambdas

```cpp
// Need to use std::function for recursion
function<int(int)> factorial = [&](int n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
};

cout << factorial(5) << "\n";  // 120
```

---

## References & Move Semantics

### References (Basics)

A reference is an **alias** to an existing variable.

```cpp
int x = 10;
int& ref = x;  // ref is another name for x

ref = 20;      // Changes x to 20
cout << x;     // Prints 20
```

### Why Use References?

**1. Avoid Copies (Performance)**

```cpp
// BAD - copies entire vector
void process(vector<int> arr) {  // Copy!
    // Process...
}

// GOOD - no copy
void process(const vector<int>& arr) {  // Reference
    // Process...
}

// If you need to modify
void modify(vector<int>& arr) {
    arr[0] = 100;  // Modifies original
}
```

**2. Return Multiple Values**

```cpp
void get_min_max(const vector<int>& arr, int& min_val, int& max_val) {
    min_val = *min_element(arr.begin(), arr.end());
    max_val = *max_element(arr.begin(), arr.end());
}

int main() {
    vector<int> arr = {3, 1, 4, 1, 5, 9};
    int min_v, max_v;
    get_min_max(arr, min_v, max_v);
    cout << min_v << " " << max_v << "\n";  // 1 9
}
```

### Range-Based For Loops

```cpp
vector<int> arr = {1, 2, 3, 4, 5};

// BAD - copies each element
for (int x : arr) {
    cout << x << " ";
}

// GOOD - reference (no copy)
for (const int& x : arr) {
    cout << x << " ";
}

// If you need to modify
for (int& x : arr) {
    x *= 2;  // Modifies original array
}

// Auto with reference
for (const auto& x : arr) {
    cout << x << " ";
}
```

### Move Semantics (Light Introduction)

**Problem:** Sometimes we copy large objects when we don't need to.

```cpp
vector<int> create_large_vector() {
    vector<int> v(1000000);
    // Fill vector...
    return v;  // In old C++, this would copy!
}

int main() {
    vector<int> arr = create_large_vector();  // No copy in C++11+!
}
```

**How it works:** `std::move` transfers ownership instead of copying.

```cpp
vector<int> v1 = {1, 2, 3, 4, 5};
vector<int> v2 = v1;              // Copy (v1 still valid)
vector<int> v3 = std::move(v1);   // Move (v1 becomes empty)

cout << v1.size() << "\n";  // 0 (moved from)
cout << v3.size() << "\n";  // 5 (moved to)
```

**When to use:** Rarely needed in CP, but useful for:
- Passing large objects you won't use again
- Swapping without temporary copy

```cpp
// Efficient swap using move
void my_swap(string& a, string& b) {
    string temp = std::move(a);
    a = std::move(b);
    b = std::move(temp);
}
```

---

## STL Containers Deep Dive

### vector

**What:** Dynamic array that can grow/shrink.

**How it works:** 
- Stores elements in contiguous memory
- Doubles capacity when full
- Random access: O(1)

```cpp
#include <vector>

// Creation
vector<int> v1;              // Empty
vector<int> v2(10);          // 10 zeros
vector<int> v3(10, 5);       // 10 fives
vector<int> v4 = {1, 2, 3};  // Initializer list

// Access
v4[0] = 10;          // No bounds check (fast)
v4.at(0) = 10;       // Bounds check (safe)
int first = v4.front();
int last = v4.back();

// Modify
v4.push_back(4);     // Add to end - O(1) amortized
v4.pop_back();       // Remove from end - O(1)
v4.insert(v4.begin() + 2, 99);  // Insert at index 2 - O(n)
v4.erase(v4.begin() + 1);       // Erase at index 1 - O(n)
v4.clear();          // Remove all - O(n)

// Size
cout << v4.size() << "\n";      // Number of elements
cout << v4.capacity() << "\n";  // Allocated space
v4.resize(20);                  // Change size
v4.reserve(100);                // Reserve space (avoid reallocations)

// Iteration
for (int i = 0; i < v4.size(); i++) {
    cout << v4[i] << " ";
}
for (const auto& x : v4) {
    cout << x << " ";
}
```

**Time Complexity:**
- Access: O(1)
- Insert/Delete at end: O(1) amortized
- Insert/Delete at middle: O(n)
- Search: O(n)

### array

**What:** Fixed-size array (size known at compile time).

**Why use:** Faster than vector for fixed sizes, stack-allocated.

```cpp
#include <array>

array<int, 5> arr = {1, 2, 3, 4, 5};

arr[0] = 10;
arr.at(2) = 30;
cout << arr.size() << "\n";  // Always 5

// Can use STL algorithms
sort(arr.begin(), arr.end());
```

**vs C-style array:**
```cpp
// C-style
int arr1[5] = {1, 2, 3, 4, 5};

// STL array
array<int, 5> arr2 = {1, 2, 3, 4, 5};

// arr2 knows its size, can be passed to functions easily
```

### string

**What:** Dynamic array of characters with special string operations.

```cpp
#include <string>

// Creation
string s1 = "hello";
string s2(5, 'a');     // "aaaaa"
string s3(s1);         // Copy

// Access
s1[0] = 'H';           // "Hello"
char c = s1.front();   // 'H'

// Modify
s1 += " world";        // Concatenation
s1.push_back('!');     // Add char
s1.pop_back();         // Remove last
s1.insert(5, " there");  // Insert at position 5
s1.erase(5, 6);        // Erase 6 chars from position 5

// Substring
string sub = s1.substr(0, 5);  // From position 0, length 5

// Find
size_t pos = s1.find("world");  // Returns position or string::npos
if (pos != string::npos) {
    cout << "Found at " << pos << "\n";
}

// Compare
if (s1 == s2) { }     // Equality
if (s1 < s2) { }      // Lexicographic

// Convert
int num = stoi("123");           // String to int
long long ln = stoll("123456");  // String to long long
double d = stod("3.14");         // String to double
string str = to_string(123);     // Int to string

// Useful functions
s1.length();    // or s1.size()
s1.empty();
s1.clear();
reverse(s1.begin(), s1.end());
sort(s1.begin(), s1.end());
```

### pair & tuple

**pair:** Holds two values (can be different types).

```cpp
#include <utility>

pair<int, string> p1 = {1, "apple"};
pair<int, string> p2 = make_pair(2, "banana");

// Access
cout << p1.first << " " << p1.second << "\n";

// Comparison (compares first, then second)
pair<int, int> a = {1, 5};
pair<int, int> b = {1, 3};
cout << (a > b) << "\n";  // true (5 > 3)

// Common use: store pairs
vector<pair<int, int>> points = {{1, 2}, {3, 4}, {5, 6}};

// Sort pairs
sort(points.begin(), points.end());  // Sorts by first, then second
```

**tuple:** Holds multiple values (generalization of pair).

```cpp
#include <tuple>

tuple<int, string, double> t = {1, "apple", 3.14};

// Access
cout << get<0>(t) << "\n";  // 1
cout << get<1>(t) << "\n";  // "apple"
cout << get<2>(t) << "\n";  // 3.14

// C++17: structured bindings
auto [id, name, price] = t;
cout << id << " " << name << " " << price << "\n";

// Make tuple
auto t2 = make_tuple(5, "banana", 2.71);
```

### set & multiset

**set:** Stores unique elements in sorted order.

**How it works:** Implemented as Red-Black Tree (balanced BST).

```cpp
#include <set>

set<int> s;

// Insert
s.insert(5);      // O(log n)
s.insert(2);
s.insert(8);
s.insert(2);      // Ignored (already exists)

// Size
cout << s.size() << "\n";  // 3

// Check existence
if (s.count(5)) {          // O(log n)
    cout << "5 exists\n";
}
if (s.find(5) != s.end()) {
    cout << "5 exists\n";
}

// Delete
s.erase(5);               // O(log n)

// Iterate (always sorted)
for (auto x : s) {
    cout << x << " ";     // 2 8
}

// Lower/Upper bound
auto it1 = s.lower_bound(5);  // First element >= 5
auto it2 = s.upper_bound(5);  // First element > 5

// Range operations
s.erase(s.lower_bound(2), s.upper_bound(8));  // Erase range [2, 8]
```

**multiset:** Like set, but allows duplicates.

```cpp
#include <set>

multiset<int> ms;
ms.insert(5);
ms.insert(5);
ms.insert(5);
cout << ms.count(5) << "\n";  // 3

// Erase all occurrences
ms.erase(5);

// Erase one occurrence
ms.erase(ms.find(5));
```

**Time Complexity:**
- Insert: O(log n)
- Delete: O(log n)
- Search: O(log n)

### map & unordered_map

**map:** Stores key-value pairs, sorted by key.

**How it works:** Red-Black Tree (balanced BST).

```cpp
#include <map>

map<string, int> m;

// Insert
m["apple"] = 5;
m["banana"] = 3;
m.insert({"cherry", 7});

// Access
cout << m["apple"] << "\n";      // 5
cout << m["grape"] << "\n";      // 0 (creates if doesn't exist!)

// Safe access
if (m.count("apple")) {
    cout << m["apple"] << "\n";
}
if (m.find("apple") != m.end()) {
    cout << m["apple"] << "\n";
}

// Delete
m.erase("banana");

// Iterate (sorted by key)
for (auto [key, value] : m) {
    cout << key << " -> " << value << "\n";
}

// Size
cout << m.size() << "\n";
```

**unordered_map:** Hash table implementation.

```cpp
#include <unordered_map>

unordered_map<string, int> um;
um["apple"] = 5;
um["banana"] = 3;

// Much faster than map (O(1) average)
// But no ordering!

for (auto [key, value] : um) {
    cout << key << " -> " << value << "\n";  // Random order
}
```

**Time Complexity:**
| Operation | map | unordered_map |
|-----------|-----|---------------|
| Insert | O(log n) | O(1) average, O(n) worst |
| Delete | O(log n) | O(1) average, O(n) worst |
| Search | O(log n) | O(1) average, O(n) worst |
| Ordered | Yes | No |

**When to use:**
- Use `unordered_map` for better performance (usually)
- Use `map` when you need sorted keys or range queries

### priority_queue

**What:** Heap that always gives you the maximum element.

**How it works:** Implemented as binary heap.

```cpp
#include <queue>

// Max heap (default)
priority_queue<int> pq;
pq.push(5);
pq.push(2);
pq.push(8);
pq.push(1);

cout << pq.top() << "\n";  // 8 (maximum)
pq.pop();                  // Remove 8
cout << pq.top() << "\n";  // 5

// Min heap
priority_queue<int, vector<int>, greater<int>> min_pq;
min_pq.push(5);
min_pq.push(2);
min_pq.push(8);
cout << min_pq.top() << "\n";  // 2 (minimum)

// Custom comparator for pairs (sort by second element)
auto cmp = [](pair<int, int> a, pair<int, int> b) {
    return a.second > b.second;  // Min heap by second element
};
priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> custom_pq(cmp);
```

**Time Complexity:**
- Insert: O(log n)
- Get max/min: O(1)
- Remove max/min: O(log n)

### deque

**What:** Double-ended queue (can insert/delete from both ends).

**How it works:** Array of arrays (chunks).

```cpp
#include <deque>

deque<int> dq;

// Insert
dq.push_back(5);    // Add to end - O(1)
dq.push_front(2);   // Add to front - O(1)

// Access
cout << dq.front() << "\n";  // 2
cout << dq.back() << "\n";   // 5
cout << dq[0] << "\n";       // 2 (random access)

// Delete
dq.pop_front();     // O(1)
dq.pop_back();      // O(1)
```

**When to use:** When you need efficient insertions at both ends.

### stack

**What:** LIFO (Last In First Out) structure.

```cpp
#include <stack>

stack<int> st;

st.push(1);
st.push(2);
st.push(3);

cout << st.top() << "\n";  // 3
st.pop();                  // Remove 3
cout << st.top() << "\n";  // 2

cout << st.size() << "\n";
cout << st.empty() << "\n";
```

**All operations:** O(1)

### queue

**What:** FIFO (First In First Out) structure.

```cpp
#include <queue>

queue<int> q;

q.push(1);
q.push(2);
q.push(3);

cout << q.front() << "\n";  // 1
cout << q.back() << "\n";   // 3
q.pop();                    // Remove 1
cout << q.front() << "\n";  // 2

cout << q.size() << "\n";
cout << q.empty() << "\n";
```

**All operations:** O(1)

---

## Big-O Complexity

### What is Big-O?

Describes **how runtime grows** as input size grows, ignoring constants.

**Example:**
```cpp
// O(n) - linear
for (int i = 0; i < n; i++) {
    cout << i;
}

// Still O(n) - constants ignored
for (int i = 0; i < n; i++) {
    for (int j = 0; j < 10; j++) {  // 10 is constant
        cout << i + j;
    }
}

// O(nÂ²) - quadratic
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        cout << i + j;
    }
}
```

### Common Complexities (from best to worst)

| Notation | Name | Example |
|----------|------|---------|
| O(1) | Constant | Array access, arithmetic |
| O(log n) | Logarithmic | Binary search, balanced tree ops |
| O(n) | Linear | Single loop, linear search |
| O(n log n) | Linearithmic | Merge sort, heap sort |
| O(nÂ²) | Quadratic | Nested loops, bubble sort |
| O(nÂ³) | Cubic | Triple nested loops |
| O(2â¿) | Exponential | Recursive fibonacci (naive) |
| O(n!) | Factorial | All permutations |

### Visualization (for n = 1,000,000)

| Complexity | Operations | Time (approx) |
|------------|------------|---------------|
| O(1) | 1 | Instant |
| O(log n) | 20 | Instant |
| O(n) | 1,000,000 | 0.01s |
| O(n log n) | 20,000,000 | 0.2s |
| O(nÂ²) | 1,000,000,000,000 | Hours |
| O(2â¿) | 2^1000000 | Never |

### Rules for Calculating Complexity

**1. Drop constants**
```cpp
// O(3n) = O(n)
for (int i = 0; i < n; i++) { }
for (int i = 0; i < n; i++) { }
for (int i = 0; i < n; i++) { }
```

**2. Drop lower-order terms**
```cpp
// O(nÂ² + n + 100) = O(nÂ²)
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {  // O(nÂ²)
        // ...
    }
}
for (int i = 0; i < n; i++) { }    // O(n)
```

**3. Different inputs use different variables**
```cpp
// O(n + m), NOT O(n)
for (int i = 0; i < n; i++) { }
for (int i = 0; i < m; i++) { }

// O(n * m), NOT O(nÂ²)
for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
        // ...
    }
}
```

**4. Nested = Multiply**
```cpp
// O(nÂ²)
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        // ...
    }
}
```

**5. Sequential = Add**
```cpp
// O(n + m)
for (int i = 0; i < n; i++) { }
for (int i = 0; i < m; i++) { }
```

### Tricky Examples

**Example 1: Triangular loop**
```cpp
// O(nÂ²) - not O(n)!
for (int i = 0; i < n; i++) {
    for (int j = 0; j < i; j++) {  // j goes from 0 to i
        // ...
    }
}
// Total operations: 0 + 1 + 2 + ... + (n-1) = n(n-1)/2 = O(nÂ²)
```

**Example 2: Logarithmic**
```cpp
// O(log n)
for (int i = 1; i < n; i *= 2) {  // i doubles each time
    // ...
}
// Iterations: i = 1, 2, 4, 8, 16, ... until i >= n
// Number of iterations = logâ‚‚(n)
```

**Example 3: Two pointers**
```cpp
// O(n) - each pointer moves at most n times
int i = 0, j = n - 1;
while (i < j) {
    if (arr[i] + arr[j] > target) {
        j--;
    } else {
        i++;
    }
}
```

**Example 4: STL containers**
```cpp
set<int> s;
for (int i = 0; i < n; i++) {
    s.insert(i);  // O(log n) per insertion
}
// Total: O(n log n)

vector<int> v;
for (int i = 0; i < n; i++) {
    v.push_back(i);  // O(1) amortized per insertion
}
// Total: O(n)
```

### Space Complexity

Same notation, but for memory usage.

```cpp
// O(n) space
vector<int> arr(n);

// O(nÂ²) space
vector<vector<int>> matrix(n, vector<int>(n));

// O(1) space (constant)
int a, b, c;
```

---

## Recurrences & Master Theorem

### What are Recurrences?

Equations that define a function recursively. Common in divide-and-conquer algorithms.

### Common Recurrence Patterns

**1. Simple recursion**
```cpp
void countdown(int n) {
    if (n == 0) return;
    cout << n << " ";
    countdown(n - 1);
}
// T(n) = T(n-1) + O(1)
// Solution: T(n) = O(n)
```

**2. Binary recursion**
```cpp
int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n-1) + fibonacci(n-2);
}
// T(n) = T(n-1) + T(n-2) + O(1)
// Solution: T(n) = O(2â¿) - exponential!
```

**3. Divide and conquer**
```cpp
void merge_sort(int arr[], int l, int r) {
    if (l >= r) return;
    int mid = (l + r) / 2;
    merge_sort(arr, l, mid);      // T(n/2)
    merge_sort(arr, mid+1, r);    // T(n/2)
    merge(arr, l, mid, r);        // O(n)
}
// T(n) = 2T(n/2) + O(n)
// Solution: T(n) = O(n log n)
```

### Master Theorem (Simplified)

For recurrences of the form: **T(n) = aT(n/b) + O(n^c)**

Where:
- `a` = number of recursive calls
- `b` = factor by which problem size is divided
- `c` = exponent in the work done outside recursion

**Three cases:**

1. **If a < b^c**: T(n) = O(n^c)
   - Work done at root dominates

2. **If a = b^c**: T(n) = O(n^c log n)
   - Work is balanced across all levels

3. **If a > b^c**: T(n) = O(n^(log_b a))
   - Work at leaves dominates

### Examples with Master Theorem

**Example 1: Merge Sort**
```
T(n) = 2T(n/2) + O(n)
a = 2, b = 2, c = 1
b^c = 2^1 = 2
a = b^c â†’ Case 2
T(n) = O(n^1 log n) = O(n log n)
```

**Example 2: Binary Search**
```
T(n) = T(n/2) + O(1)
a = 1, b = 2, c = 0
b^c = 2^0 = 1
a = b^c â†’ Case 2
T(n) = O(n^0 log n) = O(log n)
```

**Example 3: Karatsuba Multiplication**
```
T(n) = 3T(n/2) + O(n)
a = 3, b = 2, c = 1
b^c = 2^1 = 2
a > b^c â†’ Case 3
T(n) = O(n^(logâ‚‚ 3)) â‰ˆ O(n^1.585)
```

**Example 4: Naive recursion**
```
T(n) = T(n/2) + O(nÂ²)
a = 1, b = 2, c = 2
b^c = 2^2 = 4
a < b^c â†’ Case 1
T(n) = O(nÂ²)
```

### Recursion Depth & Stack Overflow

```cpp
// Maximum recursion depth â‰ˆ 10^6 (depends on system)
void deep_recursion(int n) {
    if (n == 0) return;
    deep_recursion(n - 1);  // Each call uses stack space
}

// This will crash for large n
deep_recursion(1000000);  // Stack overflow!
```

**Solution:** Use iteration or tail recursion optimization.

---

## Memory Model

### Stack vs Heap

**Stack:**
- Fast allocation/deallocation
- Limited size (~8MB typically)
- Automatic cleanup
- Local variables live here

```cpp
void function() {
    int x = 5;           // Stack
    int arr[100];        // Stack
    vector<int> v(10);   // v itself on stack, data on heap
}  // All stack memory automatically freed
```

**Heap:**
- Slower allocation
- Much larger (~GB)
- Manual management (or smart pointers)
- Dynamic allocations

```cpp
int* ptr = new int[1000000];  // Heap allocation
delete[] ptr;                 // Must free manually

// Better: use vector (manages heap memory automatically)
vector<int> v(1000000);  // Heap, but automatic cleanup
```

### Memory Limits in CP

Typical constraints:
- **Stack:** ~8-16 MB
- **Heap:** 256-512 MB
- **Total:** 256-512 MB

```cpp
// Will work (heap)
vector<int> v(1e8);  // 400 MB on heap - might be OK

// Will crash (stack)
int arr[1e8];  // 400 MB on stack - stack overflow!

// Global arrays use static memory (similar to heap)
int global_arr[1e8];  // OK (global)

int main() {
    int local_arr[1e8];  // Crash! (stack)
}
```

### Memory Usage Calculation

```cpp
// Size in bytes
sizeof(int)          // 4
sizeof(long long)    // 8
sizeof(char)         // 1
sizeof(bool)         // 1
sizeof(double)       // 8

// Array
int arr[1000000];    // 1,000,000 * 4 = 4 MB

// 2D array
int matrix[1000][1000];  // 1000 * 1000 * 4 = 4 MB

// Vector
vector<int> v(1000000);  // 1,000,000 * 4 = 4 MB

// Set/Map (overhead per element ~32 bytes)
set<int> s;  // Each element ~32 bytes
```

---

## Integer Overflow

### The Problem

```cpp
int a = 1e9;      // 1,000,000,000
int b = 1e9;
int c = a * b;    // Overflow! Result is negative or wrong

cout << c << "\n";  // Garbage value
```

**Why:** `int` range is -2^31 to 2^31-1 (about Â±2.1 billion)
- `1e9 * 1e9 = 1e18` which exceeds `int` range

### Data Type Ranges

| Type | Bytes | Range |
|------|-------|-------|
| `int` | 4 | -2^31 to 2^31-1 (~Â±2.1e9) |
| `long long` | 8 | -2^63 to 2^63-1 (~Â±9.2e18) |
| `unsigned int` | 4 | 0 to 2^32-1 (~4.3e9) |
| `unsigned long long` | 8 | 0 to 2^64-1 (~1.8e19) |

### Solutions

**1. Use `long long`**
```cpp
long long a = 1e9;
long long b = 1e9;
long long c = a * b;  // OK - result fits in long long
```

**2. Cast before operation**
```cpp
int a = 1e9;
int b = 1e9;
long long c = (long long)a * b;  // Cast first!
```

**3. Be careful with intermediate results**
```cpp
// BAD
int n = 1e5;
int sum = n * (n + 1) / 2;  // n*(n+1) overflows!

// GOOD
long long sum = (long long)n * (n + 1) / 2;
```

### Common Overflow Scenarios

**1. Factorial**
```cpp
// 21! > 10^18 (long long max)
long long fact = 1;
for (int i = 1; i <= 25; i++) {
    fact *= i;  // Overflows at i=21
}
```

**2. Power**
```cpp
// 2^64 overflows
long long power = 1;
for (int i = 0; i < 64; i++) {
    power *= 2;  // Overflows
}
```

**3. Array indices**
```cpp
int n = 1e5;
long long sum = 0;
for (int i = 0; i < n; i++) {
    sum += i * i;  // i*i might overflow if i is int and large
}
```

**4. Modular arithmetic**
```cpp
const long long MOD = 1e9 + 7;

// BAD
long long ans = (a * b) % MOD;  // a*b might overflow first!

// GOOD
long long ans = ((a % MOD) * (b % MOD)) % MOD;
```

### Detecting Overflow

**Builtin functions (GCC):**
```cpp
long long a, b, result;

// Check if a * b overflows
if (__builtin_mul_overflow(a, b, &result)) {
    cout << "Overflow!\n";
} else {
    cout << "Result: " << result << "\n";
}
```

**Manual check:**
```cpp
// Check if a * b overflows long long
bool will_overflow(long long a, long long b) {
    if (a == 0 || b == 0) return false;
    return abs(a) > LLONG_MAX / abs(b);
}
```

### Safe Patterns

```cpp
// 1. Always use long long in CP (unless memory constrained)
#define int long long  // Risky but common in CP

// 2. Read as long long
long long n;
cin >> n;

// 3. Intermediate calculations
long long mid = l + (r - l) / 2;  // Instead of (l + r) / 2

// 4. Modular arithmetic
long long result = (1LL * a * b) % MOD;  // 1LL forces long long

// 5. Array size calculations
vector<int> v;
v.resize((long long)n * m);  // Cast when n*m might overflow
```

---

## Quick Reference: When to Use What

### Containers
- **Array access needed?** â†’ `vector` or `array`
- **Insert/delete at both ends?** â†’ `deque`
- **LIFO?** â†’ `stack`
- **FIFO?** â†’ `queue`
- **Always need max/min?** â†’ `priority_queue`
- **Sorted unique elements?** â†’ `set`
- **Sorted with duplicates?** â†’ `multiset`
- **Key-value pairs (sorted)?** â†’ `map`
- **Key-value pairs (fast)?** â†’ `unordered_map`

### Complexity Guidelines (n = input size)

| n | Max Complexity | Example Algorithms |
|---|----------------|-------------------|
| n â‰¤ 10 | O(n!) | Permutations |
| n â‰¤ 20 | O(2â¿) | Subset generation |
| n â‰¤ 500 | O(nÂ³) | Floyd-Warshall |
| n â‰¤ 5,000 | O(nÂ²) | DP, nested loops |
| n â‰¤ 100,000 | O(n log n) | Sorting, set/map |
| n â‰¤ 1,000,000 | O(n) | Linear scan, prefix sum |
| n > 1,000,000 | O(log n) or O(1) | Binary search, math |

---

## Complete Template for CP

```cpp
#include <bits/stdc++.h>
using namespace std;

// Type shortcuts
using ll = long long;
using ull = unsigned long long;
using ld = long double;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
using vi = vector<int>;
using vll = vector<ll>;
using vvi = vector<vi>;

// Macros
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define pb push_back
#define mp make_pair
#define fi first
#define se second
#define sz(x) (int)(x).size()

// Constants
const int MOD = 1e9 + 7;
const ll INF = 1e18;
const int MAXN = 2e5 + 5;

// Debug
#ifdef LOCAL
    #define debug(x) cerr << #x << " = " << (x) << endl
    #define debug2(x, y) cerr << #x << " = " << (x) << ", " << #y << " = " << (y) << endl
#else
    #define debug(x)
    #define debug2(x, y)
#endif

void solve() {
    // Your solution here
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    int t = 1;
    // cin >> t;  // Uncomment for multiple test cases
    
    while (t--) {
        solve();
    }
    
    return 0;
}
```

---

This covers all the fundamental C++ concepts you need for competitive programming! Practice using these concepts, and they'll become second nature. Good luck! ðŸš€
