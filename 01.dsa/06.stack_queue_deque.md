# Stack, Queue & Deque - Complete Guide

## Table of Contents
1. [Stack Fundamentals](#stack-fundamentals)
2. [Queue Fundamentals](#queue-fundamentals)
3. [Deque Fundamentals](#deque-fundamentals)
4. [Parentheses Problems](#parentheses-problems)
5. [Span Problems](#span-problems)
6. [Next Greater Element](#next-greater-element)
7. [Monotonic Stack](#monotonic-stack)
8. [Monotonic Deque](#monotonic-deque)
9. [Range Maximums & Sliding Window](#range-maximums--sliding-window)
10. [Advanced Patterns](#advanced-patterns)

---

## Stack Fundamentals

### What is a Stack?

**Concept:** LIFO (Last In First Out) data structure.

**Operations:**
- `push(x)` - Add element to top - O(1)
- `pop()` - Remove top element - O(1)
- `top()` - View top element - O(1)
- `empty()` - Check if empty - O(1)
- `size()` - Get number of elements - O(1)

**Visual:**
```
Push 1:     Push 2:     Push 3:     Pop:        Pop:
           
   ---         ---         ---         ---         
   | |         | |         |3|         | |         
   ---         ---         ---         ---         
   | |         |2|         |2|         |2|         
   ---         ---         ---         ---         
   |1|         |1|         |1|         |1|         
   ---         ---         ---         ---         
```

### C++ Implementation

```cpp
#include <stack>

stack<int> s;

// Push elements
s.push(1);
s.push(2);
s.push(3);

// Access top
cout << s.top() << "\n";  // 3

// Pop
s.pop();  // Removes 3
cout << s.top() << "\n";  // 2

// Check empty
if (!s.empty()) {
    cout << "Size: " << s.size() << "\n";
}

// Process all elements
while (!s.empty()) {
    cout << s.top() << " ";
    s.pop();
}
```

### When to Use Stack?

âœ… Reversing order  
âœ… Matching pairs (parentheses)  
âœ… Backtracking (DFS, undo operations)  
âœ… Expression evaluation  
âœ… Function call management  
âœ… Finding nearest smaller/greater elements

---

## Queue Fundamentals

### What is a Queue?

**Concept:** FIFO (First In First Out) data structure.

**Operations:**
- `push(x)` - Add to back - O(1)
- `pop()` - Remove from front - O(1)
- `front()` - View front element - O(1)
- `back()` - View back element - O(1)
- `empty()` - Check if empty - O(1)
- `size()` - Get number of elements - O(1)

**Visual:**
```
Push 1:     Push 2:     Push 3:     Pop:        
           
[1]         [1][2]      [1][2][3]   [2][3]      
 â†‘           â†‘     â†‘     â†‘     â†‘     â†‘   â†‘       
front       front back  front back  front back
```

### C++ Implementation

```cpp
#include <queue>

queue<int> q;

// Push elements
q.push(1);
q.push(2);
q.push(3);

// Access front and back
cout << q.front() << "\n";  // 1
cout << q.back() << "\n";   // 3

// Pop from front
q.pop();  // Removes 1
cout << q.front() << "\n";  // 2

// Process all elements
while (!q.empty()) {
    cout << q.front() << " ";
    q.pop();
}
```

### When to Use Queue?

âœ… Level-order traversal (BFS)  
âœ… Processing in arrival order  
âœ… Task scheduling  
âœ… Buffer/cache implementation  
âœ… Request handling

---

## Deque Fundamentals

### What is a Deque?

**Concept:** Double-Ended Queue - can insert/delete from both ends.

**Operations:**
- `push_back(x)` - Add to back - O(1)
- `push_front(x)` - Add to front - O(1)
- `pop_back()` - Remove from back - O(1)
- `pop_front()` - Remove from front - O(1)
- `front()` - View front - O(1)
- `back()` - View back - O(1)
- `operator[]` - Random access - O(1)

**Visual:**
```
push_back(1):    push_front(2):    push_back(3):
      [1]              [2][1]            [2][1][3]
       â†‘                â†‘   â†‘             â†‘     â†‘
     front            front back        front  back
```

### C++ Implementation

```cpp
#include <deque>

deque<int> dq;

// Insert at both ends
dq.push_back(1);   // [1]
dq.push_front(2);  // [2, 1]
dq.push_back(3);   // [2, 1, 3]

// Access
cout << dq.front() << "\n";  // 2
cout << dq.back() << "\n";   // 3
cout << dq[1] << "\n";       // 1 (random access!)

// Remove from both ends
dq.pop_front();  // [1, 3]
dq.pop_back();   // [1]

// Iterate
for (int x : dq) {
    cout << x << " ";
}
```

### When to Use Deque?

âœ… Sliding window maximum/minimum  
âœ… Maintain elements in sorted order with both-end access  
âœ… When need both stack and queue operations  
âœ… Palindrome checking  
âœ… Monotonic queue problems

---

## Parentheses Problems

### Pattern 1: Valid Parentheses

**Problem:** Check if parentheses are balanced.

**How it works:**
- For opening bracket: push to stack
- For closing bracket: check if matches top of stack
- At end, stack should be empty

```cpp
bool isValid(string s) {
    stack<char> st;
    
    for (char c : s) {
        if (c == '(' || c == '{' || c == '[') {
            st.push(c);  // Opening bracket
        } else {
            if (st.empty()) return false;  // No matching opening
            
            char top = st.top();
            st.pop();
            
            // Check if matching pair
            if (c == ')' && top != '(') return false;
            if (c == '}' && top != '{') return false;
            if (c == ']' && top != '[') return false;
        }
    }
    
    return st.empty();  // Should have matched all
}
```

**Detailed trace:**
```
s = "{[()]}"

c='{': Opening, push '{', stack = ['{']
c='[': Opening, push '[', stack = ['{', '[']
c='(': Opening, push '(', stack = ['{', '[', '(']
c=')': Closing, top='(', matches! pop, stack = ['{', '[']
c=']': Closing, top='[', matches! pop, stack = ['{']
c='}': Closing, top='{', matches! pop, stack = []

Stack empty âœ“ Valid!
```

**Invalid example:**
```
s = "{[(])}"

c='{': stack = ['{']
c='[': stack = ['{', '[']
c='(': stack = ['{', '[', '(']
c=']': top='(', NOT matching! âœ—

Return false
```

**Time:** O(n), **Space:** O(n)

### Pattern 2: Minimum Add to Make Valid

**Problem:** Count minimum additions to make parentheses valid.

```cpp
int minAddToMakeValid(string s) {
    int openCount = 0;   // Unmatched '('
    int closeCount = 0;  // Unmatched ')'
    
    for (char c : s) {
        if (c == '(') {
            openCount++;
        } else {  // c == ')'
            if (openCount > 0) {
                openCount--;  // Match with previous '('
            } else {
                closeCount++;  // No '(' to match, need to add one
            }
        }
    }
    
    return openCount + closeCount;
}
```

**Trace:**
```
s = "())"

c='(': openCount=1
c=')': openCount>0, match! openCount=0
c=')': openCount=0, no match, closeCount=1

Result: 0 + 1 = 1 (need to add one '(')
```

**Time:** O(n), **Space:** O(1)

### Pattern 3: Longest Valid Parentheses

**Problem:** Find length of longest valid parentheses substring.

```cpp
int longestValidParentheses(string s) {
    stack<int> st;
    st.push(-1);  // Base for valid substring
    int maxLen = 0;
    
    for (int i = 0; i < s.length(); i++) {
        if (s[i] == '(') {
            st.push(i);  // Push index of '('
        } else {
            st.pop();  // Try to match
            
            if (st.empty()) {
                st.push(i);  // No match, new base
            } else {
                // Calculate length of valid substring
                maxLen = max(maxLen, i - st.top());
            }
        }
    }
    
    return maxLen;
}
```

**Trace:**
```
s = "(()"

i=0, s[0]='(': push 0, stack=[-1, 0]
i=1, s[1]='(': push 1, stack=[-1, 0, 1]
i=2, s[2]=')': pop 1, stack=[-1, 0]
               maxLen = max(0, 2-0) = 2

Result: 2 (substring "()")
```

**Time:** O(n), **Space:** O(n)

### Pattern 4: Remove Invalid Parentheses

**Problem:** Remove minimum parentheses to make valid.

```cpp
string removeInvalid(string s) {
    stack<int> st;
    set<int> toRemove;
    
    // Find indices to remove
    for (int i = 0; i < s.length(); i++) {
        if (s[i] == '(') {
            st.push(i);
        } else if (s[i] == ')') {
            if (!st.empty()) {
                st.pop();  // Matched
            } else {
                toRemove.insert(i);  // Invalid ')'
            }
        }
    }
    
    // Remaining '(' are invalid
    while (!st.empty()) {
        toRemove.insert(st.top());
        st.pop();
    }
    
    // Build result
    string result;
    for (int i = 0; i < s.length(); i++) {
        if (!toRemove.count(i)) {
            result += s[i];
        }
    }
    
    return result;
}
```

**Time:** O(n), **Space:** O(n)

---

## Span Problems

### What is Span?

**Span:** For each element, count how many consecutive previous elements are â‰¤ current element.

**Example:**
```
arr  = [100, 80, 60, 70, 60, 75, 85]
span = [  1,  1,  1,  2,  1,  4,  6]

Explanation:
100: No previous elements â†’ span = 1
80:  80 < 100 â†’ span = 1
60:  60 < 80 < 100 â†’ span = 1
70:  70 > 60 â†’ span = 2 ([60, 70])
60:  60 < 70 â†’ span = 1
75:  75 > 60, 70, 60 â†’ span = 4 ([60, 70, 60, 75])
85:  85 > all previous â†’ span = 6
```

### Pattern 1: Stock Span Problem

**Problem:** Calculate span for each stock price.

**Naive approach:** O(nÂ²)
```cpp
vector<int> stockSpanNaive(vector<int>& prices) {
    int n = prices.size();
    vector<int> span(n);
    
    for (int i = 0; i < n; i++) {
        span[i] = 1;  // At least 1 (itself)
        
        // Count backwards while price[j] <= price[i]
        for (int j = i - 1; j >= 0 && prices[j] <= prices[i]; j--) {
            span[i]++;
        }
    }
    
    return span;
}
```

**Optimized with stack:** O(n)

**Key insight:** Use stack to remember previous higher elements!

```cpp
vector<int> stockSpan(vector<int>& prices) {
    int n = prices.size();
    vector<int> span(n);
    stack<int> st;  // Store indices
    
    for (int i = 0; i < n; i++) {
        // Pop elements that are <= current price
        while (!st.empty() && prices[st.top()] <= prices[i]) {
            st.pop();
        }
        
        // Calculate span
        if (st.empty()) {
            span[i] = i + 1;  // All previous elements are smaller
        } else {
            span[i] = i - st.top();  // Distance from last greater element
        }
        
        st.push(i);  // Push current index
    }
    
    return span;
}
```

**Detailed trace:**
```
prices = [100, 80, 60, 70, 60, 75, 85]

i=0 (100): stack=[], span[0] = 0+1 = 1, stack=[0]

i=1 (80): 100>80, stack=[0]
          span[1] = 1-0 = 1, stack=[0,1]

i=2 (60): 80>60, stack=[0,1]
          span[2] = 2-1 = 1, stack=[0,1,2]

i=3 (70): 60â‰¤70, pop 2, stack=[0,1]
          80>70, stack=[0,1]
          span[3] = 3-1 = 2, stack=[0,1,3]

i=4 (60): 70>60, stack=[0,1,3]
          span[4] = 4-3 = 1, stack=[0,1,3,4]

i=5 (75): 60â‰¤75, pop 4, stack=[0,1,3]
          70â‰¤75, pop 3, stack=[0,1]
          80>75, stack=[0,1]
          span[5] = 5-1 = 4, stack=[0,1,5]

i=6 (85): 75â‰¤85, pop 5, stack=[0,1]
          80â‰¤85, pop 1, stack=[0]
          100>85, stack=[0]
          span[6] = 6-0 = 6, stack=[0,6]

Result: [1, 1, 1, 2, 1, 4, 6]
```

**Why it works:**
- Stack maintains indices of prices in decreasing order
- When we pop elements â‰¤ current price, we're skipping over them
- The remaining top is the nearest greater element
- Distance from that element = span

**Time:** O(n) - Each element pushed/popped once  
**Space:** O(n)

### Pattern 2: Daily Temperatures

**Problem:** How many days until warmer temperature?

```cpp
vector<int> dailyTemperatures(vector<int>& temps) {
    int n = temps.size();
    vector<int> result(n, 0);
    stack<int> st;  // Store indices
    
    for (int i = 0; i < n; i++) {
        // Pop all days with lower temp
        while (!st.empty() && temps[st.top()] < temps[i]) {
            int prevDay = st.top();
            st.pop();
            result[prevDay] = i - prevDay;  // Days to wait
        }
        
        st.push(i);
    }
    
    return result;
}
```

**Trace:**
```
temps = [73, 74, 75, 71, 69, 72, 76, 73]

i=0 (73): stack=[], stack=[0]

i=1 (74): 73<74, pop 0
          result[0] = 1-0 = 1
          stack=[1]

i=2 (75): 74<75, pop 1
          result[1] = 2-1 = 1
          stack=[2]

i=3 (71): 75>71, stack=[2,3]

i=4 (69): 71>69, stack=[2,3,4]

i=5 (72): 69<72, pop 4, result[4] = 5-4 = 1
          71<72, pop 3, result[3] = 5-3 = 2
          75>72, stack=[2,5]

i=6 (76): 72<76, pop 5, result[5] = 6-5 = 1
          75<76, pop 2, result[2] = 6-2 = 4
          stack=[6]

i=7 (73): 76>73, stack=[6,7]

Result: [1, 1, 4, 2, 1, 1, 0, 0]
```

**Time:** O(n), **Space:** O(n)

---

## Next Greater Element

### Pattern 1: Next Greater Element I (Basic)

**Problem:** For each element, find next greater element to the right.

```cpp
vector<int> nextGreaterElement(vector<int>& arr) {
    int n = arr.size();
    vector<int> result(n, -1);
    stack<int> st;  // Store indices
    
    for (int i = 0; i < n; i++) {
        // Pop all elements smaller than current
        while (!st.empty() && arr[st.top()] < arr[i]) {
            int idx = st.top();
            st.pop();
            result[idx] = arr[i];  // Found next greater!
        }
        
        st.push(i);
    }
    
    return result;
}
```

**Trace:**
```
arr = [4, 5, 2, 10, 8]

i=0 (4): stack=[], stack=[0]

i=1 (5): 4<5, pop 0
         result[0] = 5
         stack=[1]

i=2 (2): 5>2, stack=[1,2]

i=3 (10): 2<10, pop 2, result[2] = 10
          5<10, pop 1, result[1] = 10
          stack=[3]

i=4 (8): 10>8, stack=[3,4]

Result: [5, 10, 10, -1, -1]
```

**Time:** O(n), **Space:** O(n)

### Pattern 2: Next Greater Element (Circular Array)

**Problem:** Array is circular, can wrap around.

```cpp
vector<int> nextGreaterCircular(vector<int>& arr) {
    int n = arr.size();
    vector<int> result(n, -1);
    stack<int> st;
    
    // Process array twice (circular)
    for (int i = 0; i < 2 * n; i++) {
        int idx = i % n;  // Wrap around
        
        while (!st.empty() && arr[st.top()] < arr[idx]) {
            result[st.top()] = arr[idx];
            st.pop();
        }
        
        if (i < n) {  // Only push in first iteration
            st.push(idx);
        }
    }
    
    return result;
}
```

**Example:**
```
arr = [1, 2, 1]

Normal: [2, -1, -1]
Circular: [2, -1, 2]  (last 1 can wrap to first 2)
```

**Time:** O(n), **Space:** O(n)

### Pattern 3: Previous Greater Element

**Problem:** Find nearest greater element to the left.

```cpp
vector<int> previousGreater(vector<int>& arr) {
    int n = arr.size();
    vector<int> result(n, -1);
    stack<int> st;  // Store values or indices
    
    for (int i = 0; i < n; i++) {
        // Pop all smaller or equal elements
        while (!st.empty() && st.top() <= arr[i]) {
            st.pop();
        }
        
        if (!st.empty()) {
            result[i] = st.top();
        }
        
        st.push(arr[i]);
    }
    
    return result;
}
```

**Time:** O(n), **Space:** O(n)

### Pattern 4: Next Smaller Element

**Problem:** Find next smaller element (just flip comparison).

```cpp
vector<int> nextSmaller(vector<int>& arr) {
    int n = arr.size();
    vector<int> result(n, -1);
    stack<int> st;
    
    for (int i = 0; i < n; i++) {
        // Pop all GREATER elements (opposite of next greater)
        while (!st.empty() && arr[st.top()] > arr[i]) {
            result[st.top()] = arr[i];
            st.pop();
        }
        
        st.push(i);
    }
    
    return result;
}
```

**Time:** O(n), **Space:** O(n)

---

## Monotonic Stack

### What is a Monotonic Stack?

**Definition:** Stack where elements are always in increasing or decreasing order.

**Two types:**
1. **Monotonic Increasing:** Each element â‰¥ previous
2. **Monotonic Decreasing:** Each element â‰¤ previous

### Building Monotonic Increasing Stack

```cpp
stack<int> buildMonotonicIncreasing(vector<int>& arr) {
    stack<int> st;
    
    for (int x : arr) {
        // Remove all elements greater than current
        while (!st.empty() && st.top() > x) {
            st.pop();
        }
        st.push(x);
    }
    
    return st;  // Bottom to top: increasing order
}
```

**Example:**
```
arr = [3, 1, 4, 1, 5]

x=3: stack = [3]
x=1: 3>1, pop â†’ stack = [1]
x=4: 1â‰¤4 â†’ stack = [1, 4]
x=1: 4>1, pop â†’ 1â‰¤1 â†’ stack = [1, 1]
x=5: 1â‰¤5 â†’ stack = [1, 1, 5]

Final stack (bottom to top): [1, 1, 5]
```

### Pattern 1: Largest Rectangle in Histogram

**Problem:** Find area of largest rectangle that can be formed.

**Key insight:** For each bar, find how far it can extend left and right (while remaining shortest).

```cpp
int largestRectangleArea(vector<int>& heights) {
    stack<int> st;
    int maxArea = 0;
    int n = heights.size();
    
    for (int i = 0; i <= n; i++) {
        int h = (i == n) ? 0 : heights[i];
        
        while (!st.empty() && heights[st.top()] > h) {
            int height = heights[st.top()];
            st.pop();
            
            int width = st.empty() ? i : i - st.top() - 1;
            maxArea = max(maxArea, height * width);
        }
        
        st.push(i);
    }
    
    return maxArea;
}
```

**Detailed trace:**
```
heights = [2, 1, 5, 6, 2, 3]

i=0 (2): stack = [0]

i=1 (1): heights[0]=2 > 1
         height=2, width=1 (from index 0 to 0)
         area = 2*1 = 2, maxArea = 2
         stack = [1]

i=2 (5): 1â‰¤5, stack = [1, 2]

i=3 (6): 5â‰¤6, stack = [1, 2, 3]

i=4 (2): heights[3]=6 > 2
         height=6, width=1 (from 3 to 3)
         area = 6*1 = 6, maxArea = 6
         stack = [1, 2]
         
         heights[2]=5 > 2
         height=5, width=2 (from 2 to 3)
         area = 5*2 = 10, maxArea = 10
         stack = [1]
         
         1â‰¤2, stack = [1, 4]

i=5 (3): 2â‰¤3, stack = [1, 4, 5]

i=6 (0): Process remaining:
         heights[5]=3 > 0
         height=3, width=2 (from 4 to 5)
         area = 3*2 = 6
         
         heights[4]=2 > 0
         height=2, width=4 (from 1 to 5)
         area = 2*4 = 8
         
         heights[1]=1 > 0
         height=1, width=6 (from 0 to 5)
         area = 1*6 = 6

Result: maxArea = 10
```

**Visual:**
```
heights = [2, 1, 5, 6, 2, 3]

    6
  5 â–ˆ
  â–ˆ â–ˆ
  â–ˆ â–ˆ   3
2 â–ˆ â–ˆ 2 â–ˆ
â–ˆ 1 â–ˆ â–ˆ â–ˆ
```
Largest rectangle: height=5, width=2, area=10

**Time:** O(n), **Space:** O(n)

### Pattern 2: Trapping Rain Water (Stack Approach)

```cpp
int trap(vector<int>& height) {
    stack<int> st;
    int water = 0;
    
    for (int i = 0; i < height.size(); i++) {
        while (!st.empty() && height[st.top()] < height[i]) {
            int bottom = st.top();
            st.pop();
            
            if (st.empty()) break;
            
            int distance = i - st.top() - 1;
            int bounded_height = min(height[i], height[st.top()]) - height[bottom];
            water += distance * bounded_height;
        }
        
        st.push(i);
    }
    
    return water;
}
```

**Time:** O(n), **Space:** O(n)

---

## Monotonic Deque

### What is a Monotonic Deque?

**Definition:** Deque maintained in monotonic order (increasing or decreasing).

**Advantage over stack:** Can remove from both ends!

**Use cases:**
- Sliding window maximum/minimum
- Range queries
- Optimization problems

### Pattern: Sliding Window Maximum

**Problem:** Find maximum in each window of size k.

**Naive approach:** O(n*k)
```cpp
vector<int> maxSlidingWindowNaive(vector<int>& arr, int k) {
    vector<int> result;
    
    for (int i = 0; i <= arr.size() - k; i++) {
        int maxVal = *max_element(arr.begin() + i, arr.begin() + i + k);
        result.push_back(maxVal);
    }
    
    return result;
}
```

**Optimized with monotonic deque:** O(n)

**Key insight:** Maintain deque with decreasing values!

```cpp
vector<int> maxSlidingWindow(vector<int>& arr, int k) {
    deque<int> dq;  // Store indices
    vector<int> result;
    
    for (int i = 0; i < arr.size(); i++) {
        // Remove elements outside window
        while (!dq.empty() && dq.front() <= i - k) {
            dq.pop_front();
        }
        
        // Remove smaller elements from back
        // (they can never be maximum)
        while (!dq.empty() && arr[dq.back()] < arr[i]) {
            dq.pop_back();
        }
        
        dq.push_back(i);
        
        // Add to result (window is full)
        if (i >= k - 1) {
            result.push_back(arr[dq.front()]);
        }
    }
    
    return result;
}
```

**Detailed trace:**
```
arr = [1, 3, -1, -3, 5, 3, 6, 7], k = 3

i=0 (1): dq = [0]

i=1 (3): 1<3, remove 0
         dq = [1]

i=2 (-1): 3>-1, keep both
          dq = [1, 2]
          Window [1,3,-1], max = arr[1] = 3
          result = [3]

i=3 (-3): 1 not outside (3-3=0)
          -1>-3, keep both
          dq = [1, 2, 3]
          Window [3,-1,-3], max = arr[1] = 3
          result = [3, 3]

i=4 (5): 1 outside (4-3=1), remove
         dq = [2, 3]
         -1<5, remove
         -3<5, remove
         dq = [4]
         Window [-1,-3,5], max = arr[4] = 5
         result = [3, 3, 5]

i=5 (3): 5>3, keep
         dq = [4, 5]
         Window [-3,5,3], max = arr[4] = 5
         result = [3, 3, 5, 5]

i=6 (6): 4 not outside
         3<6, remove
         5<6, remove
         dq = [6]
         Window [5,3,6], max = arr[6] = 6
         result = [3, 3, 5, 5, 6]

i=7 (7): 6 not outside
         6<7, remove
         dq = [7]
         Window [3,6,7], max = arr[7] = 7
         result = [3, 3, 5, 5, 6, 7]
```

**Invariant:** Deque always maintains indices in decreasing order of values!

**Why it works:**
- Front of deque = maximum in current window
- We remove smaller elements because they can't be max while larger exists
- We remove elements outside window from front

**Time:** O(n) - Each element added/removed once  
**Space:** O(k)

### Pattern: Sliding Window Minimum

**Problem:** Find minimum in each window (just flip comparison).

```cpp
vector<int> minSlidingWindow(vector<int>& arr, int k) {
    deque<int> dq;
    vector<int> result;
    
    for (int i = 0; i < arr.size(); i++) {
        // Remove outside window
        while (!dq.empty() && dq.front() <= i - k) {
            dq.pop_front();
        }
        
        // Remove larger elements (opposite of max)
        while (!dq.empty() && arr[dq.back()] > arr[i]) {
            dq.pop_back();
        }
        
        dq.push_back(i);
        
        if (i >= k - 1) {
            result.push_back(arr[dq.front()]);
        }
    }
    
    return result;
}
```

**Time:** O(n), **Space:** O(k)

---

## Range Maximums & Sliding Window

### Pattern 1: Maximum in All Subarrays of Size K

```cpp
vector<int> maxInSubarrays(vector<int>& arr, int k) {
    deque<int> dq;
    vector<int> result;
    
    for (int i = 0; i < arr.size(); i++) {
        // Remove elements outside current window
        if (!dq.empty() && dq.front() == i - k) {
            dq.pop_front();
        }
        
        // Maintain decreasing order
        while (!dq.empty() && arr[dq.back()] <= arr[i]) {
            dq.pop_back();
        }
        
        dq.push_back(i);
        
        // Start recording from index k-1
        if (i >= k - 1) {
            result.push_back(arr[dq.front()]);
        }
    }
    
    return result;
}
```

### Pattern 2: Shortest Subarray with Sum â‰¥ K

**Uses monotonic deque to optimize prefix sum approach.**

```cpp
int shortestSubarray(vector<int>& arr, int k) {
    int n = arr.size();
    vector<long long> prefix(n + 1, 0);
    
    // Build prefix sum
    for (int i = 0; i < n; i++) {
        prefix[i + 1] = prefix[i] + arr[i];
    }
    
    deque<int> dq;  // Monotonic increasing queue of indices
    int minLen = n + 1;
    
    for (int i = 0; i <= n; i++) {
        // Check if we found valid subarray
        while (!dq.empty() && prefix[i] - prefix[dq.front()] >= k) {
            minLen = min(minLen, i - dq.front());
            dq.pop_front();
        }
        
        // Maintain increasing order of prefix sums
        while (!dq.empty() && prefix[i] <= prefix[dq.back()]) {
            dq.pop_back();
        }
        
        dq.push_back(i);
    }
    
    return minLen == n + 1 ? -1 : minLen;
}
```

**Time:** O(n), **Space:** O(n)

### Pattern 3: Constrained Subsequence Sum

**Problem:** Max sum subsequence where consecutive elements are at most k apart.

```cpp
int constrainedSubsetSum(vector<int>& arr, int k) {
    int n = arr.size();
    vector<int> dp(n);
    deque<int> dq;  // Monotonic decreasing
    
    for (int i = 0; i < n; i++) {
        // Remove elements outside window
        while (!dq.empty() && dq.front() < i - k) {
            dq.pop_front();
        }
        
        // dp[i] = arr[i] + max(0, dp[j]) for j in [i-k, i-1]
        dp[i] = arr[i];
        if (!dq.empty()) {
            dp[i] += max(0, dp[dq.front()]);
        }
        
        // Maintain decreasing order
        while (!dq.empty() && dp[dq.back()] < dp[i]) {
            dq.pop_back();
        }
        
        dq.push_back(i);
    }
    
    return *max_element(dp.begin(), dp.end());
}
```

**Time:** O(n), **Space:** O(n)

---

## Advanced Patterns

### Pattern 1: Remove K Digits

**Problem:** Remove k digits to make smallest number.

```cpp
string removeKdigits(string num, int k) {
    string result;
    
    for (char digit : num) {
        // Remove larger digits from end
        while (!result.empty() && result.back() > digit && k > 0) {
            result.pop_back();
            k--;
        }
        result.push_back(digit);
    }
    
    // Remove remaining k digits from end
    while (k > 0) {
        result.pop_back();
        k--;
    }
    
    // Remove leading zeros
    int start = 0;
    while (start < result.size() && result[start] == '0') {
        start++;
    }
    
    result = result.substr(start);
    return result.empty() ? "0" : result;
}
```

**Trace:**
```
num = "1432219", k = 3

digit='1': result = "1"
digit='4': 1<4, result = "14"
digit='3': 4>3 and k>0, remove 4, k=2, result = "13"
digit='2': 3>2 and k>0, remove 3, k=1, result = "12"
digit='2': 2â‰¤2, result = "122"
digit='1': 2>1 and k>0, remove 2, k=0, result = "121"
digit='9': k=0, result = "1219"

Result: "1219"
```

**Time:** O(n), **Space:** O(n)

### Pattern 2: Decode String

**Problem:** Decode string like "3[a2[c]]" â†’ "accaccacc"

```cpp
string decodeString(string s) {
    stack<int> countStack;
    stack<string> stringStack;
    string current;
    int k = 0;
    
    for (char c : s) {
        if (isdigit(c)) {
            k = k * 10 + (c - '0');
        } else if (c == '[') {
            countStack.push(k);
            stringStack.push(current);
            current = "";
            k = 0;
        } else if (c == ']') {
            string decoded = stringStack.top();
            stringStack.pop();
            
            int count = countStack.top();
            countStack.pop();
            
            for (int i = 0; i < count; i++) {
                decoded += current;
            }
            
            current = decoded;
        } else {
            current += c;
        }
    }
    
    return current;
}
```

**Time:** O(maxK * n), **Space:** O(n)

### Pattern 3: Asteroid Collision

**Problem:** Asteroids moving left/right collide and destroy.

```cpp
vector<int> asteroidCollision(vector<int>& asteroids) {
    stack<int> st;
    
    for (int ast : asteroids) {
        bool destroyed = false;
        
        while (!st.empty() && ast < 0 && st.top() > 0) {
            // Collision: st.top() going right, ast going left
            if (st.top() < -ast) {
                st.pop();  // Right asteroid destroyed
                continue;
            } else if (st.top() == -ast) {
                st.pop();  // Both destroyed
            }
            destroyed = true;
            break;
        }
        
        if (!destroyed) {
            st.push(ast);
        }
    }
    
    // Convert stack to vector
    vector<int> result(st.size());
    for (int i = st.size() - 1; i >= 0; i--) {
        result[i] = st.top();
        st.pop();
    }
    
    return result;
}
```

**Example:**
```
asteroids = [5, 10, -5]

5: st = [5]
10: st = [5, 10]
-5: Collision with 10
    10 > 5, -5 destroyed
    st = [5, 10]

Result: [5, 10]
```

**Time:** O(n), **Space:** O(n)

### Pattern 4: Exclusive Time of Functions

**Problem:** Calculate execution time of each function with call stack.

```cpp
vector<int> exclusiveTime(int n, vector<string>& logs) {
    vector<int> result(n, 0);
    stack<int> st;  // Function IDs
    int prevTime = 0;
    
    for (const string& log : logs) {
        int id, timestamp;
        string type;
        
        // Parse log
        size_t pos1 = log.find(':');
        size_t pos2 = log.rfind(':');
        id = stoi(log.substr(0, pos1));
        type = log.substr(pos1 + 1, pos2 - pos1 - 1);
        timestamp = stoi(log.substr(pos2 + 1));
        
        if (type == "start") {
            if (!st.empty()) {
                result[st.top()] += timestamp - prevTime;
            }
            st.push(id);
            prevTime = timestamp;
        } else {
            result[st.top()] += timestamp - prevTime + 1;
            st.pop();
            prevTime = timestamp + 1;
        }
    }
    
    return result;
}
```

**Time:** O(n), **Space:** O(n)

---

## Summary Tables

### Stack vs Queue vs Deque

| Operation | Stack | Queue | Deque |
|-----------|-------|-------|-------|
| Insert at front | âœ— | âœ— | O(1) |
| Insert at back | O(1) | O(1) | O(1) |
| Remove from front | âœ— | O(1) | O(1) |
| Remove from back | O(1) | âœ— | O(1) |
| Access front | âœ— | O(1) | O(1) |
| Access back | O(1) | O(1) | O(1) |
| Random access | âœ— | âœ— | O(1) |

### Pattern Complexity

| Pattern | Time | Space | Key Idea |
|---------|------|-------|----------|
| Valid Parentheses | O(n) | O(n) | Match opening/closing |
| Stock Span | O(n) | O(n) | Monotonic stack |
| Next Greater | O(n) | O(n) | Pop smaller elements |
| Largest Rectangle | O(n) | O(n) | Heights as bars |
| Sliding Window Max | O(n) | O(k) | Monotonic deque |
| Trapping Rain Water | O(n) | O(n) | Calculate bounded height |

### When to Use Which Structure

| Use Case | Structure | Why |
|----------|-----------|-----|
| Undo/Redo | Stack | LIFO order |
| BFS | Queue | FIFO order |
| Matching pairs | Stack | Last opened, first closed |
| Sliding window max/min | Deque | Access both ends |
| Next greater/smaller | Stack | Monotonic property |
| Range queries | Monotonic Deque | Maintain order + window |
| Expression evaluation | Stack | Operator precedence |

---

## Practice Problems

### Stack Basics
- [ ] Valid Parentheses
- [ ] Min Stack
- [ ] Evaluate Reverse Polish Notation
- [ ] Basic Calculator
- [ ] Simplify Path

### Monotonic Stack
- [ ] Next Greater Element I & II
- [ ] Daily Temperatures
- [ ] Stock Span Problem
- [ ] Largest Rectangle in Histogram
- [ ] Maximal Rectangle

### Monotonic Deque
- [ ] Sliding Window Maximum
- [ ] Sliding Window Minimum
- [ ] Shortest Subarray with Sum â‰¥ K
- [ ] Constrained Subsequence Sum
- [ ] Jump Game VI

### Advanced
- [ ] Trapping Rain Water
- [ ] Remove K Digits
- [ ] Decode String
- [ ] Asteroid Collision
- [ ] Sum of Subarray Minimums

---

## Key Takeaways

1. **Stack = LIFO**, perfect for reversing and matching
2. **Queue = FIFO**, perfect for BFS and ordering
3. **Deque = Both ends**, perfect for sliding window
4. **Monotonic stack** solves next greater/smaller in O(n)
5. **Monotonic deque** solves sliding window max/min in O(n)
6. **Each element pushed/popped once** â†’ O(n) total
7. **Always check stack.empty()** before accessing top
8. **Use indices in stack** when need positions
9. **Parentheses = stack**, span/range problems = monotonic structure

Master these patterns and you'll efficiently solve 90% of stack/queue/deque problems! ðŸš€
