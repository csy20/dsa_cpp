# Two Pointer & Sliding Window Techniques

## Table of Contents
1. [Two Pointer Fundamentals](#two-pointer-fundamentals)
2. [Pair/Sum Problems](#pairsum-problems)
3. [Dedupe Runs](#dedupe-runs)
4. [Sliding Window Fundamentals](#sliding-window-fundamentals)
5. [Fixed Window](#fixed-window)
6. [Variable Window](#variable-window)
7. [Window with Counts](#window-with-counts)
8. [The "At Most K" Trick](#the-at-most-k-trick)
9. [Advanced Patterns](#advanced-patterns)

---

## Two Pointer Fundamentals

**Concept:** Use two pointers to traverse data structure, usually to reduce time complexity from O(nÂ²) to O(n).

### Common Patterns

1. **Opposite Ends** - Pointers move toward each other
2. **Same Direction** - Both move left to right
3. **Fast & Slow** - Different speeds

### When to Use Two Pointers

âœ… Array is sorted (or can be sorted)  
âœ… Need to find pairs/triplets with certain sum  
âœ… Need to partition/reorder elements  
âœ… Comparing elements from both ends  
âœ… Finding optimal window

---

## Pair/Sum Problems

### Pattern 1: Two Sum (Sorted Array)

**Problem:** Find two numbers that add up to target.

**How it works:**
- Start with pointers at both ends
- If sum is too small, move left pointer right (increase sum)
- If sum is too large, move right pointer left (decrease sum)
- If sum matches, found the pair

```cpp
vector<int> twoSum(vector<int>& arr, int target) {
    int left = 0;
    int right = arr.size() - 1;
    
    while (left < right) {
        int sum = arr[left] + arr[right];
        
        if (sum == target) {
            return {left, right};
        } else if (sum < target) {
            left++;   // Need larger sum
        } else {
            right--;  // Need smaller sum
        }
    }
    
    return {-1, -1};  // Not found
}
```

**Example trace:**
```
arr = [1, 2, 3, 4, 6, 8], target = 10
       L           R

sum = 1 + 8 = 9 < 10 â†’ left++

arr = [1, 2, 3, 4, 6, 8]
          L        R

sum = 2 + 8 = 10 âœ“ Found!
```

**Time:** O(n), **Space:** O(1)

### Pattern 2: Two Sum (All Pairs)

**Problem:** Find all unique pairs that sum to target.

```cpp
vector<pair<int, int>> twoSumAllPairs(vector<int>& arr, int target) {
    sort(arr.begin(), arr.end());  // Sort first
    
    vector<pair<int, int>> result;
    int left = 0;
    int right = arr.size() - 1;
    
    while (left < right) {
        int sum = arr[left] + arr[right];
        
        if (sum == target) {
            result.push_back({arr[left], arr[right]});
            
            // Skip duplicates
            int leftVal = arr[left];
            int rightVal = arr[right];
            while (left < right && arr[left] == leftVal) left++;
            while (left < right && arr[right] == rightVal) right--;
            
        } else if (sum < target) {
            left++;
        } else {
            right--;
        }
    }
    
    return result;
}
```

**Example:**
```
arr = [1, 1, 2, 3, 4, 4, 5, 6], target = 7
       L                    R

sum = 1 + 6 = 7 âœ“ â†’ pairs: [(1,6)]
Skip duplicates: left moves to first 2, right stays

arr = [1, 1, 2, 3, 4, 4, 5, 6]
             L           R

sum = 2 + 5 = 7 âœ“ â†’ pairs: [(1,6), (2,5)]

arr = [1, 1, 2, 3, 4, 4, 5, 6]
                L     R

sum = 3 + 4 = 7 âœ“ â†’ pairs: [(1,6), (2,5), (3,4)]
Skip duplicates at right: move past both 4s
```

**Time:** O(n log n), **Space:** O(1)

### Pattern 3: Three Sum

**Problem:** Find all unique triplets that sum to target.

**How it works:**
- Fix first element
- Use two-pointer on remaining elements
- Skip duplicates

```cpp
vector<vector<int>> threeSum(vector<int>& arr, int target) {
    sort(arr.begin(), arr.end());
    vector<vector<int>> result;
    int n = arr.size();
    
    for (int i = 0; i < n - 2; i++) {
        // Skip duplicates for first element
        if (i > 0 && arr[i] == arr[i - 1]) continue;
        
        // Two-pointer for remaining elements
        int left = i + 1;
        int right = n - 1;
        int remainingTarget = target - arr[i];
        
        while (left < right) {
            int sum = arr[left] + arr[right];
            
            if (sum == remainingTarget) {
                result.push_back({arr[i], arr[left], arr[right]});
                
                // Skip duplicates
                while (left < right && arr[left] == arr[left + 1]) left++;
                while (left < right && arr[right] == arr[right - 1]) right--;
                
                left++;
                right--;
                
            } else if (sum < remainingTarget) {
                left++;
            } else {
                right--;
            }
        }
    }
    
    return result;
}
```

**Example:**
```
arr = [-1, 0, 1, 2, -1, -4], target = 0
After sort: [-4, -1, -1, 0, 1, 2]

i = 0 (arr[i] = -4): Find two numbers that sum to 4
  No pairs found

i = 1 (arr[i] = -1): Find two numbers that sum to 1
  [-4, -1, -1, 0, 1, 2]
        i   L        R
  
  sum = 0 + 2 = 2 > 1 â†’ right--
  sum = 0 + 1 = 1 âœ“ â†’ triplet: [-1, 0, 1]
  
i = 2: Skip (duplicate -1)

i = 3 (arr[i] = 0): Find two numbers that sum to 0
  [-4, -1, -1, 0, 1, 2]
               i  L  R
  
  sum = 1 + 2 = 3 > 0 â†’ right--
  left >= right, done

Result: [[-1, 0, 1], [-1, -1, 2]]
```

**Time:** O(nÂ²), **Space:** O(1)

### Pattern 4: Pair with Given Difference

**Problem:** Find pair where arr[j] - arr[i] = k

```cpp
bool findPairWithDifference(vector<int>& arr, int k) {
    sort(arr.begin(), arr.end());
    
    int i = 0, j = 1;
    
    while (j < arr.size()) {
        int diff = arr[j] - arr[i];
        
        if (diff == k && i != j) {
            return true;
        } else if (diff < k) {
            j++;  // Need larger difference
        } else {
            i++;  // Need smaller difference
            if (i == j) j++;  // Keep i < j
        }
    }
    
    return false;
}
```

**Time:** O(n log n), **Space:** O(1)

### Pattern 5: Closest Pair Sum

**Problem:** Find pair whose sum is closest to target.

```cpp
pair<int, int> closestSum(vector<int>& arr, int target) {
    sort(arr.begin(), arr.end());
    
    int left = 0, right = arr.size() - 1;
    int minDiff = INT_MAX;
    pair<int, int> result;
    
    while (left < right) {
        int sum = arr[left] + arr[right];
        int diff = abs(sum - target);
        
        if (diff < minDiff) {
            minDiff = diff;
            result = {arr[left], arr[right]};
        }
        
        if (sum < target) {
            left++;
        } else if (sum > target) {
            right--;
        } else {
            break;  // Exact match, can't get closer
        }
    }
    
    return result;
}
```

**Time:** O(n log n), **Space:** O(1)

---

## Dedupe Runs

**Concept:** Remove consecutive duplicate elements efficiently.

### Pattern 1: Remove Duplicates (Sorted Array)

**How it works:**
- Read pointer scans array
- Write pointer marks position for next unique element
- Only copy when current differs from previous

```cpp
int removeDuplicates(vector<int>& arr) {
    if (arr.empty()) return 0;
    
    int writeIdx = 1;  // Next position for unique element
    
    for (int i = 1; i < arr.size(); i++) {
        if (arr[i] != arr[i - 1]) {  // Found new unique
            arr[writeIdx++] = arr[i];
        }
    }
    
    return writeIdx;  // New length
}
```

**Detailed trace:**
```
arr = [1, 1, 1, 2, 2, 3, 4, 4, 4]
       w  i

i=1: arr[1]=1 == arr[0]=1, skip
i=2: arr[2]=1 == arr[1]=1, skip

arr = [1, 1, 1, 2, 2, 3, 4, 4, 4]
       w        i

i=3: arr[3]=2 != arr[2]=1, arr[w]=2, w++
arr = [1, 2, 1, 2, 2, 3, 4, 4, 4]
          w     i

i=4: arr[4]=2 == arr[3]=2, skip

arr = [1, 2, 1, 2, 2, 3, 4, 4, 4]
          w           i

i=5: arr[5]=3 != arr[4]=2, arr[w]=3, w++
arr = [1, 2, 3, 2, 2, 3, 4, 4, 4]
             w        i

i=6: arr[6]=4 != arr[5]=3, arr[w]=4, w++
arr = [1, 2, 3, 4, 2, 3, 4, 4, 4]
                w        i

i=7: arr[7]=4 == arr[6]=4, skip
i=8: arr[8]=4 == arr[7]=4, skip

Result: [1, 2, 3, 4, ...], length = 4
```

**Time:** O(n), **Space:** O(1)

### Pattern 2: Remove Duplicates (Keep at Most K)

**Problem:** Keep at most K occurrences of each element.

```cpp
int removeDuplicatesKeepK(vector<int>& arr, int k) {
    if (arr.size() <= k) return arr.size();
    
    int writeIdx = k;
    
    for (int i = k; i < arr.size(); i++) {
        // Compare with k positions back
        if (arr[i] != arr[writeIdx - k]) {
            arr[writeIdx++] = arr[i];
        }
    }
    
    return writeIdx;
}
```

**Example (k=2):**
```
arr = [1, 1, 1, 2, 2, 2, 3, 3]
                w           i

i=2: arr[2]=1 == arr[0]=1 (writeIdx-k), skip
i=3: arr[3]=2 != arr[1]=1, arr[w]=2, w++
arr = [1, 1, 2, 2, 2, 2, 3, 3]
                   w        i

i=4: arr[4]=2 == arr[2]=2, skip
i=5: arr[5]=2 == arr[3]=2, skip
i=6: arr[6]=3 != arr[4]=2, arr[w]=3, w++
arr = [1, 1, 2, 2, 3, 2, 3, 3]
                      w     i

i=7: arr[7]=3 == arr[5]=2... wait, arr[5]=3 now!
     arr[7]=3 == arr[5]=3, skip

Result: [1, 1, 2, 2, 3, 3], length = 6
```

**Time:** O(n), **Space:** O(1)

### Pattern 3: Remove Consecutive Duplicates (Unsorted)

```cpp
string removeDuplicates(string s) {
    if (s.empty()) return s;
    
    int writeIdx = 0;
    
    for (int i = 0; i < s.length(); i++) {
        // Only write if different from previous written char
        if (writeIdx == 0 || s[i] != s[writeIdx - 1]) {
            s[writeIdx++] = s[i];
        }
    }
    
    s.resize(writeIdx);
    return s;
}
```

**Time:** O(n), **Space:** O(1)

### Pattern 4: Remove All Adjacent Duplicates (Stack Approach)

**Problem:** "abbaca" â†’ "ca" (remove all consecutive duplicates repeatedly)

```cpp
string removeAllDuplicates(string s) {
    string result;  // Acts as stack
    
    for (char c : s) {
        if (!result.empty() && result.back() == c) {
            result.pop_back();  // Remove matching character
        } else {
            result.push_back(c);
        }
    }
    
    return result;
}
```

**Trace:**
```
s = "abbaca"

i=0, c='a': result = "a"
i=1, c='b': result = "ab"
i=2, c='b': match! result = "a"
i=3, c='a': match! result = ""
i=4, c='c': result = "c"
i=5, c='a': result = "ca"

Result: "ca"
```

**Time:** O(n), **Space:** O(n)

---

## Sliding Window Fundamentals

**Concept:** Maintain a "window" of elements and slide it across array/string.

**Key Idea:**
- Expand window by moving right pointer
- Shrink window by moving left pointer
- Update answer based on current window

### Window Structure

```cpp
int left = 0;
for (int right = 0; right < n; right++) {
    // Add arr[right] to window
    
    while (/* window invalid */) {
        // Remove arr[left] from window
        left++;
    }
    
    // Update answer with current window [left, right]
}
```

---

## Fixed Window

**Concept:** Window size is constant (size = k).

**Pattern:** Add new element, remove old element, update answer.

### Pattern 1: Maximum Sum Subarray of Size K

```cpp
int maxSumFixedWindow(vector<int>& arr, int k) {
    if (arr.size() < k) return -1;
    
    // Calculate sum of first window
    int windowSum = 0;
    for (int i = 0; i < k; i++) {
        windowSum += arr[i];
    }
    
    int maxSum = windowSum;
    
    // Slide window
    for (int i = k; i < arr.size(); i++) {
        windowSum += arr[i];        // Add new element
        windowSum -= arr[i - k];    // Remove old element
        maxSum = max(maxSum, windowSum);
    }
    
    return maxSum;
}
```

**Trace:**
```
arr = [1, 3, 2, 6, -1, 4, 1, 8, 2], k = 3

Initial window: [1, 3, 2], sum = 6, max = 6

i=3: Add 6, remove 1 â†’ [3, 2, 6], sum = 11, max = 11
i=4: Add -1, remove 3 â†’ [2, 6, -1], sum = 7, max = 11
i=5: Add 4, remove 2 â†’ [6, -1, 4], sum = 9, max = 11
i=6: Add 1, remove 6 â†’ [-1, 4, 1], sum = 4, max = 11
i=7: Add 8, remove -1 â†’ [4, 1, 8], sum = 13, max = 13
i=8: Add 2, remove 4 â†’ [1, 8, 2], sum = 11, max = 13

Result: 13
```

**Time:** O(n), **Space:** O(1)

### Pattern 2: Average of Subarrays of Size K

```cpp
vector<double> averages(vector<int>& arr, int k) {
    vector<double> result;
    double windowSum = 0;
    
    for (int i = 0; i < arr.size(); i++) {
        windowSum += arr[i];
        
        if (i >= k - 1) {  // Window is full
            result.push_back(windowSum / k);
            windowSum -= arr[i - k + 1];  // Remove leftmost
        }
    }
    
    return result;
}
```

**Time:** O(n), **Space:** O(1) excluding output

### Pattern 3: First Negative in Every Window of Size K

```cpp
vector<int> firstNegative(vector<int>& arr, int k) {
    vector<int> result;
    deque<int> negatives;  // Stores indices of negative numbers
    
    for (int i = 0; i < arr.size(); i++) {
        // Add to window
        if (arr[i] < 0) {
            negatives.push_back(i);
        }
        
        // Remove elements outside window
        while (!negatives.empty() && negatives.front() <= i - k) {
            negatives.pop_front();
        }
        
        // Record answer
        if (i >= k - 1) {
            if (!negatives.empty()) {
                result.push_back(arr[negatives.front()]);
            } else {
                result.push_back(0);
            }
        }
    }
    
    return result;
}
```

**Time:** O(n), **Space:** O(k)

---

## Variable Window

**Concept:** Window size changes based on condition.

**Pattern:** Expand until invalid, then shrink until valid.

### Pattern 1: Longest Substring Without Repeating Characters

**How it works:**
- Expand window by adding characters
- If duplicate found, shrink from left until no duplicates
- Track maximum window size

```cpp
int longestSubstringNoDuplicates(string s) {
    unordered_set<char> window;
    int left = 0;
    int maxLen = 0;
    
    for (int right = 0; right < s.length(); right++) {
        // Shrink window while duplicate exists
        while (window.count(s[right])) {
            window.erase(s[left]);
            left++;
        }
        
        // Add current character
        window.insert(s[right]);
        
        // Update maximum
        maxLen = max(maxLen, right - left + 1);
    }
    
    return maxLen;
}
```

**Detailed trace:**
```
s = "abcabcbb"

right=0, char='a': window={'a'}, len=1, max=1
right=1, char='b': window={'a','b'}, len=2, max=2
right=2, char='c': window={'a','b','c'}, len=3, max=3

right=3, char='a': DUPLICATE!
  Remove s[0]='a', left=1, window={'b','c'}
  Add 'a', window={'a','b','c'}, len=3, max=3

right=4, char='b': DUPLICATE!
  Remove s[1]='b', left=2, window={'a','c'}
  Add 'b', window={'a','b','c'}, len=3, max=3

right=5, char='c': DUPLICATE!
  Remove s[2]='c', left=3, window={'a','b'}
  Add 'c', window={'a','b','c'}, len=3, max=3

right=6, char='b': DUPLICATE!
  Remove s[3]='a', left=4, window={'b','c'}
  Still duplicate!
  Remove s[4]='b', left=5, window={'c'}
  Add 'b', window={'b','c'}, len=2, max=3

right=7, char='b': DUPLICATE!
  Remove s[5]='c', left=6, window={'b'}
  Still duplicate!
  Remove s[6]='b', left=7, window={}
  Add 'b', window={'b'}, len=1, max=3

Result: 3 (substring "abc")
```

**Time:** O(n), **Space:** O(min(n, m)) where m = character set size

### Pattern 2: Smallest Subarray with Sum >= Target

```cpp
int minSubarraySum(vector<int>& arr, int target) {
    int left = 0;
    int sum = 0;
    int minLen = INT_MAX;
    
    for (int right = 0; right < arr.size(); right++) {
        sum += arr[right];
        
        // Shrink window while condition met
        while (sum >= target) {
            minLen = min(minLen, right - left + 1);
            sum -= arr[left];
            left++;
        }
    }
    
    return minLen == INT_MAX ? 0 : minLen;
}
```

**Trace:**
```
arr = [2, 1, 5, 2, 3, 2], target = 7

right=0: sum=2, < 7
right=1: sum=3, < 7
right=2: sum=8, >= 7!
  minLen=3 [2,1,5]
  Remove arr[0]=2, sum=6, left=1
  
right=3: sum=8, >= 7!
  minLen=3 [1,5,2]
  Remove arr[1]=1, sum=7, left=2
  Still >= 7!
  minLen=2 [5,2]
  Remove arr[2]=5, sum=2, left=3
  
right=4: sum=5, < 7
right=5: sum=7, >= 7!
  minLen=2 (unchanged, [2,3,2] has len=3)

Result: 2
```

**Time:** O(n), **Space:** O(1)

### Pattern 3: Maximum Length Subarray with Sum K

```cpp
int maxLengthSum(vector<int>& arr, int k) {
    int left = 0;
    int sum = 0;
    int maxLen = 0;
    
    for (int right = 0; right < arr.size(); right++) {
        sum += arr[right];
        
        // Shrink if sum exceeds k
        while (sum > k && left <= right) {
            sum -= arr[left];
            left++;
        }
        
        // Check if current sum equals k
        if (sum == k) {
            maxLen = max(maxLen, right - left + 1);
        }
    }
    
    return maxLen;
}
```

**Note:** This works for positive numbers only. For any numbers, use prefix sum + hashmap.

**Time:** O(n), **Space:** O(1)

---

## Window with Counts

**Concept:** Use hashmap/array to track element frequencies in window.

### Pattern 1: Longest Substring with K Distinct Characters

```cpp
int longestKDistinct(string s, int k) {
    unordered_map<char, int> freq;
    int left = 0;
    int maxLen = 0;
    
    for (int right = 0; right < s.length(); right++) {
        // Add character to window
        freq[s[right]]++;
        
        // Shrink while more than k distinct
        while (freq.size() > k) {
            freq[s[left]]--;
            if (freq[s[left]] == 0) {
                freq.erase(s[left]);
            }
            left++;
        }
        
        // Update maximum
        maxLen = max(maxLen, right - left + 1);
    }
    
    return maxLen;
}
```

**Trace:**
```
s = "araaci", k = 2

right=0, 'a': freq={'a':1}, distinct=1, len=1, max=1
right=1, 'r': freq={'a':1,'r':1}, distinct=2, len=2, max=2
right=2, 'a': freq={'a':2,'r':1}, distinct=2, len=3, max=3
right=3, 'a': freq={'a':3,'r':1}, distinct=2, len=4, max=4
right=4, 'c': freq={'a':3,'r':1,'c':1}, distinct=3 > k!
  Shrink: remove 'a', freq={'a':2,'r':1,'c':1}, left=1
  Still 3 > k!
  Shrink: remove 'r', freq={'a':2,'c':1}, left=2
  Now distinct=2, len=3, max=4
right=5, 'i': freq={'a':2,'c':1,'i':1}, distinct=3 > k!
  Shrink: remove 'a', freq={'a':1,'c':1,'i':1}, left=3
  Still 3 > k!
  Shrink: remove 'a', freq={'c':1,'i':1}, left=4
  Now distinct=2, len=2, max=4

Result: 4 (substring "araa")
```

**Time:** O(n), **Space:** O(k)

### Pattern 2: Minimum Window Substring (Hard!)

**Problem:** Find smallest substring of s containing all characters of t.

```cpp
string minWindow(string s, string t) {
    if (s.empty() || t.empty()) return "";
    
    // Count characters needed
    unordered_map<char, int> required;
    for (char c : t) {
        required[c]++;
    }
    
    int left = 0;
    int formed = 0;  // How many unique chars have desired frequency
    int requiredSize = required.size();
    
    unordered_map<char, int> windowCounts;
    int minLen = INT_MAX;
    int minLeft = 0;
    
    for (int right = 0; right < s.length(); right++) {
        char c = s[right];
        windowCounts[c]++;
        
        // Check if frequency matches
        if (required.count(c) && windowCounts[c] == required[c]) {
            formed++;
        }
        
        // Try to shrink window
        while (left <= right && formed == requiredSize) {
            // Update result
            if (right - left + 1 < minLen) {
                minLen = right - left + 1;
                minLeft = left;
            }
            
            // Remove from left
            char leftChar = s[left];
            windowCounts[leftChar]--;
            if (required.count(leftChar) && 
                windowCounts[leftChar] < required[leftChar]) {
                formed--;
            }
            left++;
        }
    }
    
    return minLen == INT_MAX ? "" : s.substr(minLeft, minLen);
}
```

**Time:** O(|s| + |t|), **Space:** O(|s| + |t|)

### Pattern 3: Permutation in String

**Problem:** Check if s2 contains permutation of s1.

```cpp
bool checkInclusion(string s1, string s2) {
    if (s1.length() > s2.length()) return false;
    
    vector<int> s1Count(26, 0);
    vector<int> windowCount(26, 0);
    
    // Count s1
    for (char c : s1) {
        s1Count[c - 'a']++;
    }
    
    // Sliding window
    for (int i = 0; i < s2.length(); i++) {
        windowCount[s2[i] - 'a']++;
        
        // Remove leftmost if window too large
        if (i >= s1.length()) {
            windowCount[s2[i - s1.length()] - 'a']--;
        }
        
        // Check if counts match
        if (i >= s1.length() - 1 && windowCount == s1Count) {
            return true;
        }
    }
    
    return false;
}
```

**Time:** O(|s1| + |s2|), **Space:** O(1) (fixed 26 characters)

---

## The "At Most K" Trick

**Key Insight:** "Exactly K" = "At Most K" - "At Most K-1"

This trick simplifies many problems!

### Problem: Subarrays with Exactly K Different Integers

**Naive approach:** Complex logic to maintain exactly K distinct.

**Smart approach:** Use the trick!

```cpp
// Helper: Count subarrays with at most K distinct
int atMostK(vector<int>& arr, int k) {
    unordered_map<int, int> freq;
    int left = 0;
    int count = 0;
    
    for (int right = 0; right < arr.size(); right++) {
        freq[arr[right]]++;
        
        // Shrink while more than k distinct
        while (freq.size() > k) {
            freq[arr[left]]--;
            if (freq[arr[left]] == 0) {
                freq.erase(arr[left]);
            }
            left++;
        }
        
        // All subarrays ending at right with at most k distinct
        count += right - left + 1;
    }
    
    return count;
}

// Main function
int exactlyK(vector<int>& arr, int k) {
    return atMostK(arr, k) - atMostK(arr, k - 1);
}
```

**Why it works:**
```
atMostK(k) counts: subarrays with 1, 2, ..., or k distinct
atMostK(k-1) counts: subarrays with 1, 2, ..., or k-1 distinct
Difference: subarrays with exactly k distinct
```

**Example:**
```
arr = [1, 2, 1, 2, 3], k = 2

atMostK(2):
  [1] âœ“
  [1,2] âœ“
  [2] âœ“
  [2,1] âœ“
  [1] âœ“
  [1,2] âœ“
  [2] âœ“
  [2,3] âœ“
  [3] âœ“
  ... many more
  
atMostK(1):
  [1] âœ“
  [2] âœ“
  [1] âœ“
  [2] âœ“
  [3] âœ“
  
Difference = exactly 2 distinct
```

**Detailed trace of atMostK(arr, 2):**
```
arr = [1, 2, 1, 2, 3]

right=0, arr[0]=1: freq={1:1}, distinct=1
  count += 0-0+1 = 1  (subarray: [1])

right=1, arr[1]=2: freq={1:1,2:1}, distinct=2
  count += 1-0+1 = 2  (subarrays: [2], [1,2])
  Total count = 3

right=2, arr[2]=1: freq={1:2,2:1}, distinct=2
  count += 2-0+1 = 3  (subarrays: [1], [2,1], [1,2,1])
  Total count = 6

right=3, arr[3]=2: freq={1:2,2:2}, distinct=2
  count += 3-0+1 = 4  (subarrays: [2], [1,2], [2,1,2], [1,2,1,2])
  Total count = 10

right=4, arr[4]=3: freq={1:2,2:2,3:1}, distinct=3 > k!
  Shrink: remove arr[0]=1, freq={1:1,2:2,3:1}, left=1
  Still 3 > k!
  Shrink: remove arr[1]=2, freq={1:1,2:1,3:1}, left=2
  Still 3 > k!
  Shrink: remove arr[2]=1, freq={2:1,3:1}, left=3
  Now distinct=2
  count += 4-3+1 = 2  (subarrays: [3], [2,3])
  Total count = 12
```

### Applications of "At Most K" Trick

**1. Longest substring with at most K distinct characters**
```cpp
int longestAtMostK(string s, int k) {
    unordered_map<char, int> freq;
    int left = 0, maxLen = 0;
    
    for (int right = 0; right < s.length(); right++) {
        freq[s[right]]++;
        
        while (freq.size() > k) {
            freq[s[left]]--;
            if (freq[s[left]] == 0) freq.erase(s[left]);
            left++;
        }
        
        maxLen = max(maxLen, right - left + 1);
    }
    
    return maxLen;
}

// Exactly k distinct:
int exactlyKDistinct(string s, int k) {
    return longestAtMostK(s, k) - longestAtMostK(s, k - 1);
}
```

**2. Binary subarrays with sum at most K**
```cpp
int atMostKSum(vector<int>& arr, int k) {
    int left = 0, sum = 0, count = 0;
    
    for (int right = 0; right < arr.size(); right++) {
        sum += arr[right];
        
        while (sum > k) {
            sum -= arr[left++];
        }
        
        count += right - left + 1;
    }
    
    return count;
}

// Exactly k:
int exactlyKSum(vector<int>& arr, int k) {
    return atMostKSum(arr, k) - atMostKSum(arr, k - 1);
}
```

**3. At most K replacements**
```cpp
// Longest substring with at most k replacements
int longestOnesWithKReplacements(string s, int k) {
    int left = 0, maxLen = 0;
    int zeros = 0;  // Count of zeros in window
    
    for (int right = 0; right < s.length(); right++) {
        if (s[right] == '0') zeros++;
        
        while (zeros > k) {
            if (s[left] == '0') zeros--;
            left++;
        }
        
        maxLen = max(maxLen, right - left + 1);
    }
    
    return maxLen;
}
```

---

## Advanced Patterns

### Pattern 1: Maximum of All Subarrays of Size K

**Problem:** For each window, find maximum element.

**Approach:** Use deque to maintain decreasing order.

```cpp
vector<int> maxSlidingWindow(vector<int>& arr, int k) {
    deque<int> dq;  // Stores indices
    vector<int> result;
    
    for (int i = 0; i < arr.size(); i++) {
        // Remove elements outside window
        while (!dq.empty() && dq.front() <= i - k) {
            dq.pop_front();
        }
        
        // Remove smaller elements (they're useless)
        while (!dq.empty() && arr[dq.back()] < arr[i]) {
            dq.pop_back();
        }
        
        dq.push_back(i);
        
        // Add to result
        if (i >= k - 1) {
            result.push_back(arr[dq.front()]);
        }
    }
    
    return result;
}
```

**Trace:**
```
arr = [1, 3, -1, -3, 5, 3, 6, 7], k = 3

i=0, arr[0]=1: dq=[0]
i=1, arr[1]=3: 3>1, remove 1, dq=[1]
i=2, arr[2]=-1: dq=[1,2], result=[3]
i=3, arr[3]=-3: dq=[1,2,3], result=[3,3]
i=4, arr[4]=5: 5>-1,-3, remove all, but 1 out of window
     dq=[4], result=[3,3,5]
i=5, arr[5]=3: 3<5, dq=[4,5], result=[3,3,5,5]
i=6, arr[6]=6: 6>3,5, remove all, but 4 out of window
     dq=[6], result=[3,3,5,5,6]
i=7, arr[7]=7: 7>6, dq=[7], result=[3,3,5,5,6,7]
```

**Time:** O(n), **Space:** O(k)

### Pattern 2: Fruits into Baskets

**Problem:** Pick maximum fruits with at most 2 types.

```cpp
int totalFruit(vector<int>& fruits) {
    unordered_map<int, int> basket;
    int left = 0, maxFruits = 0;
    
    for (int right = 0; right < fruits.size(); right++) {
        basket[fruits[right]]++;
        
        while (basket.size() > 2) {
            basket[fruits[left]]--;
            if (basket[fruits[left]] == 0) {
                basket.erase(fruits[left]);
            }
            left++;
        }
        
        maxFruits = max(maxFruits, right - left + 1);
    }
    
    return maxFruits;
}
```

**Time:** O(n), **Space:** O(1) (at most 3 types in map)

### Pattern 3: Longest Repeating Character Replacement

**Problem:** Make string with same characters by replacing at most K chars.

```cpp
int characterReplacement(string s, int k) {
    vector<int> count(26, 0);
    int left = 0, maxCount = 0, maxLen = 0;
    
    for (int right = 0; right < s.length(); right++) {
        count[s[right] - 'A']++;
        maxCount = max(maxCount, count[s[right] - 'A']);
        
        // Window size - most frequent char = replacements needed
        while (right - left + 1 - maxCount > k) {
            count[s[left] - 'A']--;
            left++;
        }
        
        maxLen = max(maxLen, right - left + 1);
    }
    
    return maxLen;
}
```

**Example:**
```
s = "AABABBA", k = 1

Window [AAB]: size=3, maxCount('A')=2, replacements=1 âœ“
Window [AABA]: size=4, maxCount('A')=3, replacements=1 âœ“
Window [AABAB]: size=5, maxCount('A')=3, replacements=2 âœ—
Shrink to [ABAB]: size=4, maxCount('A')=2, replacements=2 âœ—
Shrink to [BAB]: size=3, maxCount('B')=2, replacements=1 âœ“
...

Result: 4
```

**Time:** O(n), **Space:** O(1)

---

## Summary Tables

### Two Pointer Patterns

| Problem Type | Pointer Movement | Condition |
|--------------|------------------|-----------|
| Two Sum | Opposite ends | sum vs target |
| Three Sum | Fixed + opposite | Nested two sum |
| Pair difference | Same direction | diff vs k |
| Remove duplicates | Read + write | current vs previous |
| Partition | Both forward | compare to pivot |

### Sliding Window Patterns

| Problem Type | Window Type | Expand When | Shrink When |
|--------------|-------------|-------------|-------------|
| Fixed size K | Fixed | Always | Window > K |
| At most K distinct | Variable | Always | distinct > K |
| At least sum S | Variable | Always | sum >= S |
| Exact match | Variable | Always | Invalid state |

### Time Complexities

| Technique | Time | Space | Use Case |
|-----------|------|-------|----------|
| Two pointer (sorted) | O(n) | O(1) | Pair problems |
| Two pointer (unsorted) | O(n) | O(1) | Dedupe, partition |
| Fixed window | O(n) | O(1) | Size K problems |
| Variable window | O(n) | O(k) | String/subarray |
| Window with counts | O(n) | O(k) | Distinct elements |
| Deque window | O(n) | O(k) | Max/min in window |

---

## Key Patterns to Remember

1. **Two Sum Pattern:** Opposite pointers on sorted array
2. **Dedupe Pattern:** Read pointer ahead, write pointer behind
3. **Fixed Window:** Add right, remove left, slide forward
4. **Variable Window:** Expand until invalid, shrink until valid
5. **At Most K Trick:** exactly(k) = atMost(k) - atMost(k-1)
6. **Window Counts:** HashMap for frequencies, shrink when invalid

---

## Practice Problem Checklist

### Two Pointer
- [ ] Two Sum II
- [ ] Three Sum
- [ ] Remove Duplicates from Sorted Array
- [ ] Container With Most Water
- [ ] Trapping Rain Water

### Fixed Window
- [ ] Maximum Sum Subarray of Size K
- [ ] First Negative in Every Window
- [ ] Count Occurrences of Anagrams
- [ ] Maximum of All Subarrays of Size K

### Variable Window
- [ ] Longest Substring Without Repeating Characters
- [ ] Longest Substring with K Distinct Characters
- [ ] Minimum Window Substring
- [ ] Longest Repeating Character Replacement
- [ ] Fruits Into Baskets

### At Most K
- [ ] Subarrays with K Different Integers
- [ ] Binary Subarrays With Sum
- [ ] Count Number of Nice Subarrays

Master these patterns and you'll solve 90% of two-pointer and sliding window problems! ðŸš€
