# Hashing & Maps - Complete Guide

## Table of Contents
1. [Hash Table Fundamentals](#hash-table-fundamentals)
2. [unordered_map Basics](#unordered_map-basics)
3. [Counting Patterns](#counting-patterns)
4. [Deduplication](#deduplication)
5. [Grouping Patterns](#grouping-patterns)
6. [Collision Handling](#collision-handling)
7. [Custom Hash Functions](#custom-hash-functions)
8. [Performance Optimization](#performance-optimization)
9. [Common Pitfalls](#common-pitfalls)

---

## Hash Table Fundamentals

### What is a Hash Table?

**Concept:** A data structure that maps keys to values using a hash function.

**How it works:**

```
Key ‚Üí Hash Function ‚Üí Hash Code ‚Üí Index in Array ‚Üí Value

Example:
"apple" ‚Üí hash("apple") ‚Üí 12345 ‚Üí 12345 % 10 = 5 ‚Üí arr[5] = price of apple
```

**Core Operations:**
- Insert: O(1) average
- Lookup: O(1) average
- Delete: O(1) average

### Hash Function Requirements

A good hash function should:
1. **Deterministic** - Same input always gives same output
2. **Uniform distribution** - Spreads keys evenly across table
3. **Fast to compute** - O(1) time

### Basic Hash Function Example

```cpp
// Simple hash for integers
size_t hash_int(int key, size_t table_size) {
    return key % table_size;
}

// Simple hash for strings (naive)
size_t hash_string_naive(const string& key, size_t table_size) {
    size_t hash = 0;
    for (char c : key) {
        hash += c;  // Just sum ASCII values
    }
    return hash % table_size;
}

// Better string hash (polynomial rolling hash)
size_t hash_string_better(const string& key, size_t table_size) {
    const size_t prime = 31;
    size_t hash = 0;
    
    for (char c : key) {
        hash = hash * prime + c;
    }
    
    return hash % table_size;
}
```

**Why polynomial is better:**
```
Naive: "abc" = 97+98+99 = 294
       "bca" = 98+99+97 = 294  ‚ùå COLLISION!

Better: "abc" = 97*31¬≤ + 98*31 + 99 = 93554
        "bca" = 98*31¬≤ + 99*31 + 97 = 97364  ‚úÖ Different!
```

### Internal Structure (Simplified)

```cpp
// Simplified hash table visualization
class SimpleHashTable {
    struct Node {
        string key;
        int value;
        Node* next;  // For chaining (collision handling)
    };
    
    vector<Node*> buckets;  // Array of linked lists
    size_t table_size;
    
public:
    SimpleHashTable(size_t size) : table_size(size) {
        buckets.resize(size, nullptr);
    }
    
    void insert(const string& key, int value) {
        size_t index = hash(key) % table_size;
        
        // Create new node
        Node* newNode = new Node{key, value, buckets[index]};
        buckets[index] = newNode;  // Insert at head
    }
    
    int* find(const string& key) {
        size_t index = hash(key) % table_size;
        Node* current = buckets[index];
        
        // Traverse linked list at this bucket
        while (current != nullptr) {
            if (current->key == key) {
                return &current->value;
            }
            current = current->next;
        }
        
        return nullptr;  // Not found
    }
};
```

**Visual representation:**
```
Hash Table (size = 5):

buckets[0]: nullptr
buckets[1]: ["apple", 5] ‚Üí nullptr
buckets[2]: ["banana", 3] ‚Üí ["berry", 7] ‚Üí nullptr  (collision!)
buckets[3]: nullptr
buckets[4]: ["cherry", 2] ‚Üí nullptr
```

---

## unordered_map Basics

### Creation and Basic Operations

```cpp
#include <unordered_map>

// Creation
unordered_map<string, int> map;

// Insert
map["apple"] = 5;
map.insert({"banana", 3});
map.insert(make_pair("cherry", 7));
map.emplace("date", 9);  // Construct in-place (fastest)

// Access
int val = map["apple"];  // 5
int val2 = map["grape"];  // 0 (creates if doesn't exist!)

// Safe access
if (map.count("apple")) {
    cout << map["apple"] << "\n";
}

// Using find
auto it = map.find("apple");
if (it != map.end()) {
    cout << it->first << ": " << it->second << "\n";
}

// Update
map["apple"] += 2;  // Now 7
map["apple"]++;     // Now 8

// Delete
map.erase("apple");

// Size
cout << map.size() << "\n";

// Check empty
if (map.empty()) { }

// Clear all
map.clear();
```

### Iteration

```cpp
unordered_map<string, int> map = {{"a", 1}, {"b", 2}, {"c", 3}};

// Method 1: Range-based for (C++17)
for (auto& [key, value] : map) {
    cout << key << ": " << value << "\n";
}

// Method 2: Traditional
for (auto& pair : map) {
    cout << pair.first << ": " << pair.second << "\n";
}

// Method 3: Iterator
for (auto it = map.begin(); it != map.end(); ++it) {
    cout << it->first << ": " << it->second << "\n";
}

// Modify while iterating
for (auto& [key, value] : map) {
    value *= 2;  // Double all values
}
```

### map vs unordered_map

```cpp
#include <map>
#include <unordered_map>

map<int, string> ordered;              // Red-Black Tree
unordered_map<int, string> unordered;  // Hash Table
```

| Feature | map | unordered_map |
|---------|-----|---------------|
| Underlying | Red-Black Tree | Hash Table |
| Ordering | Sorted by key | No order |
| Search | O(log n) | O(1) average, O(n) worst |
| Insert | O(log n) | O(1) average, O(n) worst |
| Delete | O(log n) | O(1) average, O(n) worst |
| Memory | Less overhead | More overhead |
| Use When | Need sorted order | Need fast lookup |

---

## Counting Patterns

### Pattern 1: Frequency Counter

**Problem:** Count occurrences of each element.

```cpp
vector<int> countFrequency(vector<int>& arr) {
    unordered_map<int, int> freq;
    
    // Count occurrences
    for (int x : arr) {
        freq[x]++;
    }
    
    // Display results
    for (auto& [num, count] : freq) {
        cout << num << " appears " << count << " times\n";
    }
}
```

**How `freq[x]++` works:**
1. If `x` doesn't exist, `freq[x]` creates entry with value 0
2. Then increments to 1
3. If `x` exists, just increments existing value

**Example:**
```cpp
arr = [1, 2, 2, 3, 3, 3, 1]

Step by step:
x=1: freq = {1: 1}
x=2: freq = {1: 1, 2: 1}
x=2: freq = {1: 1, 2: 2}
x=3: freq = {1: 1, 2: 2, 3: 1}
x=3: freq = {1: 1, 2: 2, 3: 2}
x=3: freq = {1: 1, 2: 2, 3: 3}
x=1: freq = {1: 2, 2: 2, 3: 3}
```

### Pattern 2: Character Frequency

```cpp
unordered_map<char, int> charFrequency(const string& s) {
    unordered_map<char, int> freq;
    
    for (char c : s) {
        freq[c]++;
    }
    
    return freq;
}

// Find most frequent character
char mostFrequent(const string& s) {
    unordered_map<char, int> freq;
    
    for (char c : s) {
        freq[c]++;
    }
    
    char maxChar = s[0];
    int maxCount = 0;
    
    for (auto& [ch, count] : freq) {
        if (count > maxCount) {
            maxCount = count;
            maxChar = ch;
        }
    }
    
    return maxChar;
}
```

### Pattern 3: Two Sum (Classic Hash Pattern)

**Problem:** Find two numbers that sum to target.

**How it works:**
- As we iterate, store each number in map
- For current number `x`, check if `target - x` exists in map
- If yes, we found the pair!

```cpp
vector<int> twoSum(vector<int>& arr, int target) {
    unordered_map<int, int> seen;  // value ‚Üí index
    
    for (int i = 0; i < arr.size(); i++) {
        int complement = target - arr[i];
        
        // Check if complement exists
        if (seen.count(complement)) {
            return {seen[complement], i};
        }
        
        // Store current number
        seen[arr[i]] = i;
    }
    
    return {};  // Not found
}
```

**Trace:**
```
arr = [2, 7, 11, 15], target = 9

i=0, arr[0]=2:
  complement = 9-2 = 7
  seen = {}, 7 not found
  seen = {2: 0}

i=1, arr[1]=7:
  complement = 9-7 = 2
  seen = {2: 0}, 2 found! ‚úì
  return [0, 1]
```

**Time:** O(n), **Space:** O(n)

### Pattern 4: Subarray Sum Equals K

**Problem:** Count subarrays with sum = k.

**Key insight:** Use prefix sum + hashmap.

**How it works:**
- If `prefixSum[j] - prefixSum[i] = k`, then subarray from i+1 to j has sum k
- Rearranging: `prefixSum[i] = prefixSum[j] - k`
- Store prefix sums in map, check if `currentSum - k` exists

```cpp
int subarraySum(vector<int>& arr, int k) {
    unordered_map<int, int> prefixCount;  // sum ‚Üí count
    prefixCount[0] = 1;  // Empty prefix
    
    int currentSum = 0;
    int count = 0;
    
    for (int num : arr) {
        currentSum += num;
        
        // Check if (currentSum - k) exists
        if (prefixCount.count(currentSum - k)) {
            count += prefixCount[currentSum - k];
        }
        
        // Store current prefix sum
        prefixCount[currentSum]++;
    }
    
    return count;
}
```

**Detailed trace:**
```
arr = [1, 2, 3], k = 3

prefixCount = {0: 1}, currentSum = 0, count = 0

num=1:
  currentSum = 1
  Check for 1-3 = -2: not found
  prefixCount = {0: 1, 1: 1}

num=2:
  currentSum = 3
  Check for 3-3 = 0: found! count += 1 = 1
    (subarray [1,2] has sum 3)
  prefixCount = {0: 1, 1: 1, 3: 1}

num=3:
  currentSum = 6
  Check for 6-3 = 3: found! count += 1 = 2
    (subarray [3] has sum 3)
  prefixCount = {0: 1, 1: 1, 3: 1, 6: 1}

Result: 2 subarrays
```

**Time:** O(n), **Space:** O(n)

### Pattern 5: First Unique Character

```cpp
char firstUnique(const string& s) {
    unordered_map<char, int> freq;
    
    // Count frequencies
    for (char c : s) {
        freq[c]++;
    }
    
    // Find first with count 1
    for (char c : s) {
        if (freq[c] == 1) {
            return c;
        }
    }
    
    return '\0';  // Not found
}
```

**Note:** We iterate string again (not map) to preserve order!

### Pattern 6: K Most Frequent Elements

```cpp
vector<int> topKFrequent(vector<int>& arr, int k) {
    // Step 1: Count frequencies
    unordered_map<int, int> freq;
    for (int x : arr) {
        freq[x]++;
    }
    
    // Step 2: Use min heap of size k
    priority_queue<pair<int, int>, 
                   vector<pair<int, int>>,
                   greater<pair<int, int>>> minHeap;
    
    for (auto& [num, count] : freq) {
        minHeap.push({count, num});
        if (minHeap.size() > k) {
            minHeap.pop();  // Remove least frequent
        }
    }
    
    // Step 3: Extract results
    vector<int> result;
    while (!minHeap.empty()) {
        result.push_back(minHeap.top().second);
        minHeap.pop();
    }
    
    return result;
}

// Alternative: Bucket sort approach (O(n) time!)
vector<int> topKFrequentBucket(vector<int>& arr, int k) {
    unordered_map<int, int> freq;
    for (int x : arr) freq[x]++;
    
    // Create buckets: bucket[i] = numbers with frequency i
    vector<vector<int>> buckets(arr.size() + 1);
    for (auto& [num, count] : freq) {
        buckets[count].push_back(num);
    }
    
    // Collect top k from highest frequency
    vector<int> result;
    for (int i = buckets.size() - 1; i >= 0 && result.size() < k; i--) {
        for (int num : buckets[i]) {
            result.push_back(num);
            if (result.size() == k) break;
        }
    }
    
    return result;
}
```

**Time:** Heap: O(n log k), Bucket: O(n)  
**Space:** O(n)

---

## Deduplication

### Pattern 1: Remove Duplicates (Keep First Occurrence)

```cpp
vector<int> removeDuplicates(vector<int>& arr) {
    unordered_set<int> seen;
    vector<int> result;
    
    for (int x : arr) {
        if (!seen.count(x)) {
            seen.insert(x);
            result.push_back(x);
        }
    }
    
    return result;
}
```

**Example:**
```
arr = [1, 2, 3, 2, 1, 4, 3, 5]

x=1: seen={}, add 1, result=[1], seen={1}
x=2: seen={1}, add 2, result=[1,2], seen={1,2}
x=3: seen={1,2}, add 3, result=[1,2,3], seen={1,2,3}
x=2: seen={1,2,3}, already exists, skip
x=1: already exists, skip
x=4: add 4, result=[1,2,3,4], seen={1,2,3,4}
x=3: already exists, skip
x=5: add 5, result=[1,2,3,4,5]

Result: [1, 2, 3, 4, 5]
```

**Time:** O(n), **Space:** O(n)

### Pattern 2: Check for Duplicates

```cpp
bool hasDuplicate(vector<int>& arr) {
    unordered_set<int> seen;
    
    for (int x : arr) {
        if (seen.count(x)) {
            return true;  // Found duplicate
        }
        seen.insert(x);
    }
    
    return false;
}

// Alternative: size check
bool hasDuplicateSimple(vector<int>& arr) {
    unordered_set<int> unique(arr.begin(), arr.end());
    return unique.size() < arr.size();
}
```

**Time:** O(n), **Space:** O(n)

### Pattern 3: Find Duplicate Number

**Problem:** Array has n+1 integers from 1 to n, find the duplicate.

```cpp
int findDuplicate(vector<int>& arr) {
    unordered_set<int> seen;
    
    for (int x : arr) {
        if (seen.count(x)) {
            return x;
        }
        seen.insert(x);
    }
    
    return -1;
}

// Space-optimized: Floyd's cycle detection (no hash)
int findDuplicateFloyd(vector<int>& arr) {
    int slow = arr[0];
    int fast = arr[0];
    
    // Find intersection point
    do {
        slow = arr[slow];
        fast = arr[arr[fast]];
    } while (slow != fast);
    
    // Find entrance to cycle
    slow = arr[0];
    while (slow != fast) {
        slow = arr[slow];
        fast = arr[fast];
    }
    
    return slow;
}
```

**Time:** Hash: O(n), Floyd: O(n)  
**Space:** Hash: O(n), Floyd: O(1)

### Pattern 4: Longest Consecutive Sequence

**Problem:** Find length of longest consecutive sequence.

```cpp
int longestConsecutive(vector<int>& arr) {
    unordered_set<int> nums(arr.begin(), arr.end());
    int maxLen = 0;
    
    for (int num : nums) {
        // Only start counting if it's the beginning of sequence
        if (!nums.count(num - 1)) {
            int currentNum = num;
            int currentLen = 1;
            
            // Count consecutive numbers
            while (nums.count(currentNum + 1)) {
                currentNum++;
                currentLen++;
            }
            
            maxLen = max(maxLen, currentLen);
        }
    }
    
    return maxLen;
}
```

**Example:**
```
arr = [100, 4, 200, 1, 3, 2]
nums = {100, 4, 200, 1, 3, 2}

num=100: 99 not in set, start sequence
  100‚Üí101? no. Length = 1

num=4: 3 in set, skip (not start)

num=200: 199 not in set, start sequence
  200‚Üí201? no. Length = 1

num=1: 0 not in set, start sequence ‚úì
  1‚Üí2? yes
  2‚Üí3? yes
  3‚Üí4? yes
  4‚Üí5? no. Length = 4

num=3: 2 in set, skip
num=2: 1 in set, skip

Result: 4 (sequence [1,2,3,4])
```

**Time:** O(n), **Space:** O(n)

---

## Grouping Patterns

### Pattern 1: Group Anagrams

**Problem:** Group strings that are anagrams of each other.

**Key insight:** Anagrams have same sorted characters or same character counts.

```cpp
vector<vector<string>> groupAnagrams(vector<string>& strs) {
    unordered_map<string, vector<string>> groups;
    
    for (const string& s : strs) {
        // Use sorted string as key
        string key = s;
        sort(key.begin(), key.end());
        
        groups[key].push_back(s);
    }
    
    // Extract groups
    vector<vector<string>> result;
    for (auto& [key, group] : groups) {
        result.push_back(group);
    }
    
    return result;
}
```

**Example:**
```
strs = ["eat", "tea", "tan", "ate", "nat", "bat"]

"eat" ‚Üí sorted: "aet" ‚Üí groups["aet"] = ["eat"]
"tea" ‚Üí sorted: "aet" ‚Üí groups["aet"] = ["eat", "tea"]
"tan" ‚Üí sorted: "ant" ‚Üí groups["ant"] = ["tan"]
"ate" ‚Üí sorted: "aet" ‚Üí groups["aet"] = ["eat", "tea", "ate"]
"nat" ‚Üí sorted: "ant" ‚Üí groups["ant"] = ["tan", "nat"]
"bat" ‚Üí sorted: "abt" ‚Üí groups["abt"] = ["bat"]

Result: [["eat","tea","ate"], ["tan","nat"], ["bat"]]
```

**Alternative: Character count as key**
```cpp
vector<vector<string>> groupAnagramsCount(vector<string>& strs) {
    unordered_map<string, vector<string>> groups;
    
    for (const string& s : strs) {
        // Create character count signature
        string key(26, '0');
        for (char c : s) {
            key[c - 'a']++;
        }
        
        groups[key].push_back(s);
    }
    
    vector<vector<string>> result;
    for (auto& [key, group] : groups) {
        result.push_back(group);
    }
    
    return result;
}
```

**Time:** Sort: O(n * k log k), Count: O(n * k) where k = max string length  
**Space:** O(n * k)

### Pattern 2: Group by Sum

```cpp
map<int, vector<vector<int>>> groupBySum(vector<vector<int>>& arrays) {
    map<int, vector<vector<int>>> groups;
    
    for (const auto& arr : arrays) {
        int sum = accumulate(arr.begin(), arr.end(), 0);
        groups[sum].push_back(arr);
    }
    
    return groups;
}
```

### Pattern 3: Isomorphic Strings

**Problem:** Check if two strings are isomorphic (one-to-one character mapping).

```cpp
bool isIsomorphic(string s, string t) {
    if (s.length() != t.length()) return false;
    
    unordered_map<char, char> mapST;  // s ‚Üí t mapping
    unordered_map<char, char> mapTS;  // t ‚Üí s mapping
    
    for (int i = 0; i < s.length(); i++) {
        char c1 = s[i], c2 = t[i];
        
        // Check s ‚Üí t mapping
        if (mapST.count(c1) && mapST[c1] != c2) {
            return false;
        }
        
        // Check t ‚Üí s mapping
        if (mapTS.count(c2) && mapTS[c2] != c1) {
            return false;
        }
        
        mapST[c1] = c2;
        mapTS[c2] = c1;
    }
    
    return true;
}
```

**Example:**
```
s = "egg", t = "add"

i=0: 'e'‚Üí'a', 'a'‚Üí'e', maps = {e:a}, {a:e}
i=1: 'g'‚Üí'd', 'd'‚Üí'g', maps = {e:a, g:d}, {a:e, d:g}
i=2: 'g'‚Üí'd', already mapped correctly ‚úì

Result: true

s = "foo", t = "bar"

i=0: 'f'‚Üí'b', maps = {f:b}, {b:f}
i=1: 'o'‚Üí'a', maps = {f:b, o:a}, {b:f, a:o}
i=2: 'o'‚Üí'r', but 'o' already maps to 'a' ‚úó

Result: false
```

**Time:** O(n), **Space:** O(1) (at most 256 characters)

### Pattern 4: Group Shifted Strings

**Problem:** Group strings that can be shifted to match each other.

```cpp
vector<vector<string>> groupStrings(vector<string>& strs) {
    unordered_map<string, vector<string>> groups;
    
    for (const string& s : strs) {
        // Create signature based on differences
        string key;
        for (int i = 1; i < s.length(); i++) {
            int diff = (s[i] - s[i-1] + 26) % 26;
            key += to_string(diff) + ",";
        }
        
        groups[key].push_back(s);
    }
    
    vector<vector<string>> result;
    for (auto& [key, group] : groups) {
        result.push_back(group);
    }
    
    return result;
}
```

**Example:**
```
strs = ["abc", "bcd", "xyz"]

"abc": diff = ['b'-'a', 'c'-'b'] = [1, 1] ‚Üí key = "1,1,"
"bcd": diff = ['c'-'b', 'd'-'c'] = [1, 1] ‚Üí key = "1,1,"
"xyz": diff = ['y'-'x', 'z'-'y'] = [1, 1] ‚Üí key = "1,1,"

All have same pattern! Group together.
```

**Time:** O(n * k), **Space:** O(n * k)

---

## Collision Handling

### What are Collisions?

**Collision:** When different keys hash to the same index.

```
hash("apple") = 5
hash("grape") = 5  ‚Üê Collision!
```

### Collision Resolution Methods

#### 1. Chaining (What unordered_map uses)

**Concept:** Each bucket stores a linked list of all key-value pairs that hash to it.

```
Buckets:
[0]: nullptr
[1]: nullptr
[2]: ["apple", 5] ‚Üí ["grape", 8] ‚Üí nullptr
[3]: ["banana", 3] ‚Üí nullptr
[4]: nullptr
```

**Operations:**
- Insert: Add to front of list at bucket
- Search: Traverse list at bucket
- Delete: Find and remove from list

**Time complexity:**
- Best: O(1) - no collisions
- Worst: O(n) - all keys hash to same bucket
- Average: O(1 + Œ±) where Œ± = load factor = n/m

#### 2. Open Addressing (Alternative approach)

**Concept:** If bucket is full, find next empty bucket.

**Linear Probing:**
```cpp
int probe(int hash, int i, int table_size) {
    return (hash + i) % table_size;
}

// If bucket[hash] is full, try bucket[hash+1], then bucket[hash+2], etc.
```

**Quadratic Probing:**
```cpp
int probe(int hash, int i, int table_size) {
    return (hash + i*i) % table_size;
}

// Try hash, hash+1, hash+4, hash+9, hash+16, ...
```

**Double Hashing:**
```cpp
int probe(int hash, int i, int table_size, int key) {
    int hash2 = second_hash(key);
    return (hash + i * hash2) % table_size;
}
```

### Load Factor

**Definition:** Œ± = n / m (number of elements / number of buckets)

**Impact:**
- Œ± < 0.7: Good performance
- Œ± > 1.0: Many collisions, slower operations

**Rehashing:** When Œ± exceeds threshold (usually 0.75), create larger table and rehash all elements.

```cpp
// Conceptual rehashing
void rehash() {
    old_buckets = buckets;
    buckets = new_buckets(table_size * 2);
    
    // Reinsert all elements
    for (auto bucket : old_buckets) {
        for (auto element : bucket) {
            insert(element);  // Uses new hash function with new size
        }
    }
}
```

### Understanding Collision Impact

```cpp
// Measure collision rate
void analyzeCollisions(const vector<string>& keys) {
    const int TABLE_SIZE = 100;
    vector<int> bucketSizes(TABLE_SIZE, 0);
    
    for (const string& key : keys) {
        size_t hash = hash_function(key);
        int bucket = hash % TABLE_SIZE;
        bucketSizes[bucket]++;
    }
    
    // Statistics
    int maxCollisions = *max_element(bucketSizes.begin(), bucketSizes.end());
    int emptyBuckets = count(bucketSizes.begin(), bucketSizes.end(), 0);
    
    cout << "Max elements in one bucket: " << maxCollisions << "\n";
    cout << "Empty buckets: " << emptyBuckets << "\n";
    cout << "Load factor: " << (double)keys.size() / TABLE_SIZE << "\n";
}
```

---

## Custom Hash Functions

### When Do You Need Custom Hash?

**Default hash works for:**
- Primitive types (int, long, char, etc.)
- strings
- Most STL containers

**Need custom hash for:**
- Pairs
- Custom structs/classes
- Vectors/arrays as keys
- Complex composite keys

### Method 1: Hash for Pairs

```cpp
// Using pair as key in unordered_map
struct PairHash {
    template <typename T1, typename T2>
    size_t operator()(const pair<T1, T2>& p) const {
        auto h1 = hash<T1>{}(p.first);
        auto h2 = hash<T2>{}(p.second);
        
        // Combine hashes
        return h1 ^ (h2 << 1);  // XOR with shifted hash
    }
};

// Usage
unordered_map<pair<int, int>, string, PairHash> pairMap;
pairMap[{1, 2}] = "value";
```

**Why shift?** Prevents `(a, b)` and `(b, a)` from having same hash if just XOR.

**Alternative combining methods:**
```cpp
// Method 1: Polynomial rolling
size_t hash = 0;
hash = hash * 31 + h1;
hash = hash * 31 + h2;
return hash;

// Method 2: Boost's hash_combine
size_t hash = h1;
hash ^= h2 + 0x9e3779b9 + (hash << 6) + (hash >> 2);
return hash;
```

### Method 2: Hash for Custom Struct

```cpp
struct Point {
    int x, y;
    
    bool operator==(const Point& other) const {
        return x == other.x && y == other.y;
    }
};

struct PointHash {
    size_t operator()(const Point& p) const {
        // Combine x and y hashes
        size_t h1 = hash<int>{}(p.x);
        size_t h2 = hash<int>{}(p.y);
        return h1 ^ (h2 << 1);
    }
};

// Usage
unordered_set<Point, PointHash> points;
points.insert({3, 4});
points.insert({5, 6});

unordered_map<Point, string, PointHash> pointMap;
pointMap[{1, 2}] = "location";
```

**Important:** Must also define `operator==` for equality comparison!

### Method 3: Hash for Vector

```cpp
struct VectorHash {
    size_t operator()(const vector<int>& v) const {
        size_t hash = 0;
        for (int x : v) {
            hash ^= std::hash<int>{}(x) + 0x9e3779b9 + (hash << 6) + (hash >> 2);
        }
        return hash;
    }
};

// Usage
unordered_map<vector<int>, int, VectorHash> vecMap;
vecMap[{1, 2, 3}] = 100;
```

### Method 4: Hash for Tuple (C++17)

```cpp
struct TupleHash {
    template <typename... T>
    size_t operator()(const tuple<T...>& t) const {
        size_t hash = 0;
        
        // Helper to hash each element
        auto hash_combine = [&hash](const auto& v) {
            hash ^= std::hash<decay_t<decltype(v)>>{}(v) + 0x9e3779b9 
                  + (hash << 6) + (hash >> 2);
        };
        
        // Apply to each tuple element
        apply([&hash_combine](const auto&... args) {
            (hash_combine(args), ...);
        }, t);
        
        return hash;
    }
};

// Usage
unordered_map<tuple<int, string, double>, int, TupleHash> tupleMap;
tupleMap[{1, "hello", 3.14}] = 42;
```

### Method 5: String Hash for Patterns

**Rolling hash for substring matching (Rabin-Karp):**

```cpp
class RollingHash {
    const long long BASE = 31;
    const long long MOD = 1e9 + 7;
    
public:
    long long computeHash(const string& s) {
        long long hash = 0;
        long long pow = 1;
        
        for (char c : s) {
            hash = (hash + (c - 'a' + 1) * pow) % MOD;
            pow = (pow * BASE) % MOD;
        }
        
        return hash;
    }
    
    // Can efficiently update hash when sliding window
    long long updateHash(long long oldHash, char oldChar, 
                        char newChar, int length) {
        // Remove old character
        oldHash = (oldHash - (oldChar - 'a' + 1) + MOD) % MOD;
        
        // Divide by base
        oldHash = (oldHash * modInverse(BASE, MOD)) % MOD;
        
        // Add new character at end
        long long pow = modPow(BASE, length - 1, MOD);
        oldHash = (oldHash + (newChar - 'a' + 1) * pow) % MOD;
        
        return oldHash;
    }
};
```

### Common Hash Combining Techniques

```cpp
// Technique 1: Simple XOR (not great for similar values)
size_t hash = h1 ^ h2;

// Technique 2: XOR with shift (better distribution)
size_t hash = h1 ^ (h2 << 1);

// Technique 3: Polynomial (good for sequences)
size_t hash = h1 * 31 + h2;

// Technique 4: Boost's hash_combine (industry standard)
size_t hash = h1;
hash ^= h2 + 0x9e3779b9 + (hash << 6) + (hash >> 2);

// For multiple values
void hash_combine(size_t& seed, size_t hash) {
    seed ^= hash + 0x9e3779b9 + (seed << 6) + (seed >> 2);
}
```

**The magic number:** `0x9e3779b9` is the golden ratio, helps with distribution.

---

## Performance Optimization

### Reserve Capacity

```cpp
// Bad: causes multiple rehashes
unordered_map<int, int> map;
for (int i = 0; i < 1000000; i++) {
    map[i] = i;  // Rehashes multiple times!
}

// Good: reserve space upfront
unordered_map<int, int> map;
map.reserve(1000000);  // No rehashing needed
for (int i = 0; i < 1000000; i++) {
    map[i] = i;
}
```

### Use emplace Instead of insert

```cpp
// Slower: creates pair, then copies
map.insert(make_pair(key, value));

// Faster: constructs in-place
map.emplace(key, value);
```

### Check Before Access

```cpp
// Bad: creates entry if doesn't exist
int val = map[key];  // If key not found, inserts with default value

// Good: check first
if (map.count(key)) {
    int val = map[key];
}

// Or use find
auto it = map.find(key);
if (it != map.end()) {
    int val = it->second;
}
```

### Choose Right Container

```cpp
// If order matters: use map
map<int, int> ordered;  // O(log n) but ordered

// If just need fast lookup: use unordered_map
unordered_map<int, int> fast;  // O(1) average but unordered

// If only storing keys (no values): use set/unordered_set
unordered_set<int> uniqueValues;

// If need both fast lookup AND order: use map
// Or maintain separate structures
```

### Benchmark Example

```cpp
#include <chrono>

void benchmark() {
    const int N = 1000000;
    
    // Test unordered_map
    auto start = chrono::high_resolution_clock::now();
    
    unordered_map<int, int> umap;
    umap.reserve(N);
    for (int i = 0; i < N; i++) {
        umap[i] = i;
    }
    
    auto end = chrono::high_resolution_clock::now();
    auto duration = chrono::duration_cast<chrono::milliseconds>(end - start);
    
    cout << "unordered_map: " << duration.count() << "ms\n";
    
    // Test map
    start = chrono::high_resolution_clock::now();
    
    map<int, int> m;
    for (int i = 0; i < N; i++) {
        m[i] = i;
    }
    
    end = chrono::high_resolution_clock::now();
    duration = chrono::duration_cast<chrono::milliseconds>(end - start);
    
    cout << "map: " << duration.count() << "ms\n";
}
```

---

## Common Pitfalls

### Pitfall 1: Default Value Creation

```cpp
unordered_map<string, int> map;

// This creates entry if not exists!
cout << map["nonexistent"] << "\n";  // Prints 0, but adds "nonexistent" ‚Üí 0

// Check size
cout << map.size() << "\n";  // Now 1!

// Safe way
if (map.count("key")) {
    cout << map["key"] << "\n";
}
```

### Pitfall 2: Iterator Invalidation

```cpp
unordered_map<int, int> map = {{1,1}, {2,2}, {3,3}};

// Bad: modifying while iterating
for (auto& [key, val] : map) {
    if (val == 2) {
        map.erase(key);  // Undefined behavior!
    }
}

// Good: collect keys to remove first
vector<int> toRemove;
for (auto& [key, val] : map) {
    if (val == 2) {
        toRemove.push_back(key);
    }
}
for (int key : toRemove) {
    map.erase(key);
}

// Or use iterator-based erase
for (auto it = map.begin(); it != map.end(); ) {
    if (it->second == 2) {
        it = map.erase(it);  // Returns next valid iterator
    } else {
        ++it;
    }
}
```

### Pitfall 3: Forgetting operator==

```cpp
struct Point {
    int x, y;
};

struct PointHash {
    size_t operator()(const Point& p) const {
        return hash<int>{}(p.x) ^ (hash<int>{}(p.y) << 1);
    }
};

// This won't compile without operator==!
unordered_set<Point, PointHash> points;

// Must add:
bool operator==(const Point& p1, const Point& p2) {
    return p1.x == p2.x && p1.y == p2.y;
}
```

### Pitfall 4: Mutable vs Const Access

```cpp
unordered_map<string, int> map = {{"a", 1}};

// Non-const: can modify, creates if not exists
map["a"]++;       // OK
map["b"]++;       // Creates "b" ‚Üí 0, then increments to 1

// Const: compile error if not exists
const auto& cmap = map;
// cmap["c"]++;   // Compile error!

// Must use find/count for const maps
auto it = cmap.find("a");
if (it != cmap.end()) {
    // Can't modify: it->second++;  // Error!
    cout << it->second << "\n";  // OK
}
```

### Pitfall 5: Hash Function Quality

```cpp
// Bad hash: many collisions
struct BadHash {
    size_t operator()(int x) const {
        return x % 10;  // Only 10 possible values!
    }
};

// Results in slow performance
unordered_map<int, int, BadHash> map;
for (int i = 0; i < 1000; i++) {
    map[i] = i;  // All collide into 10 buckets
}

// Good hash: use default or well-distributed custom hash
unordered_map<int, int> goodMap;  // Uses default hash
```

---

## Summary Tables

### Operation Complexities

| Operation | unordered_map | map |
|-----------|---------------|-----|
| Insert | O(1) avg, O(n) worst | O(log n) |
| Delete | O(1) avg, O(n) worst | O(log n) |
| Search | O(1) avg, O(n) worst | O(log n) |
| Ordered iteration | No | Yes |
| Memory overhead | Higher | Lower |

### Common Patterns

| Pattern | Use Case | Time | Space |
|---------|----------|------|-------|
| Frequency count | Count occurrences | O(n) | O(k) |
| Two sum | Find pairs | O(n) | O(n) |
| Deduplication | Remove duplicates | O(n) | O(n) |
| Group anagrams | Group by pattern | O(n*k) | O(n*k) |
| Subarray sum | Prefix sum problems | O(n) | O(n) |

### Hash Function Guidelines

| Type | Method | Example |
|------|--------|---------|
| Primitives | Use default | `hash<int>{}(x)` |
| Strings | Default or rolling | `hash<string>{}(s)` |
| Pairs | XOR with shift | `h1 ^ (h2 << 1)` |
| Vectors | Iterate and combine | Boost's hash_combine |
| Custom struct | Combine member hashes | XOR or polynomial |

---

## Practice Problems

### Counting
- [ ] Two Sum
- [ ] Subarray Sum Equals K
- [ ] Contiguous Array
- [ ] Longest Substring Without Repeating Characters
- [ ] Top K Frequent Elements

### Deduplication
- [ ] Remove Duplicates
- [ ] Contains Duplicate
- [ ] Longest Consecutive Sequence
- [ ] Find Duplicate Number

### Grouping
- [ ] Group Anagrams
- [ ] Isomorphic Strings
- [ ] Word Pattern
- [ ] Group Shifted Strings

### Custom Hash
- [ ] Max Points on a Line (pair hash)
- [ ] Encode and Decode TinyURL
- [ ] Design HashMap

---

## Key Takeaways

1. **Hash tables provide O(1) average operations** - perfect for counting, deduplication
2. **Collisions are inevitable** - good hash function minimizes them
3. **Load factor matters** - keep below 0.75 for good performance
4. **Use `unordered_map` for speed** - unless you need sorted order
5. **Custom types need custom hash** - plus `operator==`
6. **Reserve capacity** when size is known - avoids rehashing
7. **Be careful with operator[]** - it creates entries!
8. **Prefix sum + map** is powerful pattern for subarray problems

Master hashing and you'll solve counting/grouping problems in O(n) time! üöÄ
