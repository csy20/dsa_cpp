# Dynamic Programming

## Table of Contents
1. [DP Fundamentals](#dp-fundamentals)
2. [1D DP Problems](#1d-dp-problems)
3. [House Robber](#house-robber)
4. [Frog Jump](#frog-jump)
5. [Longest Increasing Subsequence (LIS)](#longest-increasing-subsequence-lis)
6. [2D/Grid DP](#2dgrid-dp)
7. [Unique Paths](#unique-paths)
8. [Min Path Sum](#min-path-sum)
9. [Knapsack Problems](#knapsack-problems)
10. [0/1 Knapsack](#01-knapsack)
11. [Unbounded Knapsack](#unbounded-knapsack)
12. [Subset Sum & Partition](#subset-sum--partition)
13. [String DP](#string-dp)
14. [Longest Common Subsequence (LCS)](#longest-common-subsequence-lcs)
15. [Edit Distance](#edit-distance)
16. [Palindrome Partitioning](#palindrome-partitioning)
17. [Common Problems](#common-problems)

---

## DP Fundamentals

### What is Dynamic Programming?

**DP:** Solving complex problems by breaking them into overlapping subproblems.

**Key properties:**
1. **Optimal substructure:** Optimal solution contains optimal solutions to subproblems
2. **Overlapping subproblems:** Same subproblems solved multiple times

**DP vs Recursion:**
```
Recursion (naive):
  fib(5) = fib(4) + fib(3)
           /            \
       fib(4)          fib(3)
       /    \          /    \
   fib(3) fib(2)   fib(2) fib(1)
   
  fib(3) computed twice!
  fib(2) computed three times!
  Exponential time: O(2^n)

DP (memoization):
  Store fib(3) first time
  Return stored value on second call
  Linear time: O(n)
```

### DP Approaches

**1. Top-down (Memoization):**
```cpp
map<int, int> memo;

int fib(int n) {
    if (n <= 1) return n;
    if (memo.count(n)) return memo[n];
    
    return memo[n] = fib(n-1) + fib(n-2);
}
```

**2. Bottom-up (Tabulation):**
```cpp
int fib(int n) {
    if (n <= 1) return n;
    
    vector<int> dp(n + 1);
    dp[0] = 0;
    dp[1] = 1;
    
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }
    
    return dp[n];
}
```

**3. Space-optimized:**
```cpp
int fib(int n) {
    if (n <= 1) return n;
    
    int prev2 = 0, prev1 = 1;
    
    for (int i = 2; i <= n; i++) {
        int curr = prev1 + prev2;
        prev2 = prev1;
        prev1 = curr;
    }
    
    return prev1;
}
```

### DP Problem-Solving Steps

**1. Define state:**
- What does `dp[i]` represent?
- What parameters change?

**2. Find recurrence:**
- How to compute `dp[i]` from previous states?
- What are the base cases?

**3. Choose implementation:**
- Top-down (easier to think) vs bottom-up (faster)
- Space optimization possible?

**4. Reconstruct solution (if needed):**
- Track choices made
- Backtrack to build answer

---

## 1D DP Problems

### Common Pattern

**State:** `dp[i]` = answer for first i elements

**Recurrence:** `dp[i]` depends on `dp[i-1]`, `dp[i-2]`, etc.

**Space optimization:** Often only need last few values

---

## House Robber

### Problem

**Houses in a line, each has money. Can't rob adjacent houses. Maximize money.**

```
houses = [2, 7, 9, 3, 1]
         
Can rob: houses[0] + houses[2] + houses[4] = 2 + 9 + 1 = 12
Or:      houses[1] + houses[3] = 7 + 3 = 10
Best:    houses[1] + houses[2] = 7 + 9 = 16? NO! (adjacent)
Actually: houses[0] + houses[2] + houses[4] = 12 âœ“
```

### How It Works

**State:** `dp[i]` = max money robbing houses 0 to i

**Recurrence:**
```
For house i, two choices:
  1. Rob house i: money[i] + dp[i-2] (skip adjacent i-1)
  2. Skip house i: dp[i-1]

dp[i] = max(dp[i-1], money[i] + dp[i-2])
```

**Base cases:**
```
dp[0] = money[0]  (only one house)
dp[1] = max(money[0], money[1])  (better of first two)
```

**Visual:**
```
houses = [2, 7, 9, 3, 1]

i=0: dp[0] = 2
  Rob house 0 â†’ 2

i=1: dp[1] = max(dp[0], money[1])
           = max(2, 7) = 7
  Skip 0, rob 1 â†’ 7

i=2: dp[2] = max(dp[1], money[2] + dp[0])
           = max(7, 9 + 2) = 11
  Rob 0 and 2 â†’ 11

i=3: dp[3] = max(dp[2], money[3] + dp[1])
           = max(11, 3 + 7) = 11
  Keep previous best (no improvement)

i=4: dp[4] = max(dp[3], money[4] + dp[2])
           = max(11, 1 + 11) = 12
  Rob 0, 2, 4 â†’ 12

Answer: 12
```

### Implementation

```cpp
int rob(vector<int>& nums) {
    int n = nums.size();
    if (n == 0) return 0;
    if (n == 1) return nums[0];
    
    vector<int> dp(n);
    dp[0] = nums[0];
    dp[1] = max(nums[0], nums[1]);
    
    for (int i = 2; i < n; i++) {
        dp[i] = max(dp[i-1], nums[i] + dp[i-2]);
    }
    
    return dp[n-1];
}
```

**Space-optimized:**
```cpp
int rob(vector<int>& nums) {
    int n = nums.size();
    if (n == 0) return 0;
    if (n == 1) return nums[0];
    
    int prev2 = nums[0];
    int prev1 = max(nums[0], nums[1]);
    
    for (int i = 2; i < n; i++) {
        int curr = max(prev1, nums[i] + prev2);
        prev2 = prev1;
        prev1 = curr;
    }
    
    return prev1;
}
```

**Time:** O(n)  
**Space:** O(1) with optimization

---

## Frog Jump

### Problem

**Frog on stone 0, wants to reach stone n-1. Can jump 1 or 2 stones. Each jump costs energy = height difference. Minimize total energy.**

```
heights = [10, 20, 30, 10]

Jump sequence 1: 0â†’1â†’2â†’3
  Cost: |20-10| + |30-20| + |10-30| = 10 + 10 + 20 = 40

Jump sequence 2: 0â†’1â†’3
  Cost: |20-10| + |10-20| = 10 + 10 = 20 âœ“

Jump sequence 3: 0â†’2â†’3
  Cost: |30-10| + |10-30| = 20 + 20 = 40

Best: 20
```

### How It Works

**State:** `dp[i]` = minimum cost to reach stone i

**Recurrence:**
```
Can reach stone i from:
  - Stone i-1: cost = dp[i-1] + |height[i] - height[i-1]|
  - Stone i-2: cost = dp[i-2] + |height[i] - height[i-2]|

dp[i] = min(
  dp[i-1] + abs(height[i] - height[i-1]),
  dp[i-2] + abs(height[i] - height[i-2])
)
```

**Base case:**
```
dp[0] = 0  (start at stone 0, no cost)
```

**Complete trace:**
```
heights = [10, 20, 30, 10]

dp[0] = 0
  At stone 0, cost = 0

dp[1] = dp[0] + |20-10| = 0 + 10 = 10
  Jump from 0 â†’ 1

dp[2] = min(
  dp[1] + |30-20| = 10 + 10 = 20,
  dp[0] + |30-10| = 0 + 20 = 20
) = 20
  Either path works

dp[3] = min(
  dp[2] + |10-30| = 20 + 20 = 40,
  dp[1] + |10-20| = 10 + 10 = 20
) = 20
  Jump 0â†’1â†’3 is optimal

Answer: dp[3] = 20
```

### Implementation

```cpp
int frogJump(vector<int>& height) {
    int n = height.size();
    vector<int> dp(n, INT_MAX);
    
    dp[0] = 0;
    
    for (int i = 1; i < n; i++) {
        // Jump from i-1
        dp[i] = min(dp[i], dp[i-1] + abs(height[i] - height[i-1]));
        
        // Jump from i-2
        if (i > 1) {
            dp[i] = min(dp[i], dp[i-2] + abs(height[i] - height[i-2]));
        }
    }
    
    return dp[n-1];
}
```

**Space-optimized:**
```cpp
int frogJump(vector<int>& height) {
    int n = height.size();
    if (n == 1) return 0;
    
    int prev2 = 0;
    int prev1 = abs(height[1] - height[0]);
    
    for (int i = 2; i < n; i++) {
        int curr = min(
            prev1 + abs(height[i] - height[i-1]),
            prev2 + abs(height[i] - height[i-2])
        );
        prev2 = prev1;
        prev1 = curr;
    }
    
    return prev1;
}
```

**Variant: K jumps allowed**
```cpp
int frogJumpK(vector<int>& height, int k) {
    int n = height.size();
    vector<int> dp(n, INT_MAX);
    dp[0] = 0;
    
    for (int i = 1; i < n; i++) {
        for (int j = 1; j <= k && i - j >= 0; j++) {
            dp[i] = min(dp[i], dp[i-j] + abs(height[i] - height[i-j]));
        }
    }
    
    return dp[n-1];
}
```

**Time:** O(n) for 2 jumps, O(nk) for k jumps  
**Space:** O(1) with optimization

---

## Longest Increasing Subsequence (LIS)

### Problem

**Find length of longest strictly increasing subsequence.**

```
nums = [10, 9, 2, 5, 3, 7, 101, 18]

LIS: [2, 3, 7, 101] or [2, 5, 7, 101] etc.
Length: 4
```

### Method 1: DP O(nÂ²)

**State:** `dp[i]` = length of LIS ending at index i

**Recurrence:**
```
For each j < i:
  If nums[j] < nums[i]:
    dp[i] = max(dp[i], dp[j] + 1)

We can extend LIS ending at j with nums[i]
```

**Complete trace:**
```
nums = [10, 9, 2, 5, 3, 7, 101, 18]

dp[0] = 1  (just [10])

dp[1] = 1
  nums[0]=10 >= nums[1]=9, can't extend
  Just [9]

dp[2] = 1
  nums[0]=10 >= nums[2]=2, can't extend
  nums[1]=9 >= nums[2]=2, can't extend
  Just [2]

dp[3] = 2
  nums[0]=10 >= nums[3]=5, can't extend
  nums[1]=9 >= nums[3]=5, can't extend
  nums[2]=2 < nums[3]=5, extend! dp[3] = dp[2]+1 = 2
  LIS: [2, 5]

dp[4] = 2
  nums[2]=2 < nums[4]=3, extend! dp[4] = dp[2]+1 = 2
  nums[3]=5 >= nums[4]=3, can't extend
  LIS: [2, 3]

dp[5] = 3
  nums[2]=2 < nums[5]=7, dp[5] = dp[2]+1 = 2
  nums[3]=5 < nums[5]=7, dp[5] = max(dp[5], dp[3]+1) = 3
  nums[4]=3 < nums[5]=7, dp[5] = max(dp[5], dp[4]+1) = 3
  LIS: [2, 5, 7] or [2, 3, 7]

dp[6] = 4
  Best: extend from dp[5] â†’ dp[6] = 4
  LIS: [2, 5, 7, 101]

dp[7] = 4
  Best: extend from dp[5] â†’ dp[7] = 4
  LIS: [2, 5, 7, 18]

Answer: max(dp) = 4
```

**Implementation:**
```cpp
int lengthOfLIS_DP(vector<int>& nums) {
    int n = nums.size();
    vector<int> dp(n, 1);  // Each element is LIS of length 1
    
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[j] < nums[i]) {
                dp[i] = max(dp[i], dp[j] + 1);
            }
        }
    }
    
    return *max_element(dp.begin(), dp.end());
}
```

**Time:** O(nÂ²)  
**Space:** O(n)

### Method 2: Binary Search O(n log n)

**Key insight:** Maintain array `tail` where `tail[i]` = smallest ending value of all LIS of length i+1.

**Why this works:**
```
If we have LIS ending with smaller value, we can extend it more easily!

Example:
  LIS of length 2: [2, 5] and [2, 3]
  Store tail[1] = 3 (smaller ending)
  
  New element 4:
    Can extend [2, 3] â†’ [2, 3, 4] âœ“
    Can't extend [2, 5] (4 < 5) âœ—
    
Smaller ending = more potential!
```

**Algorithm:**
```
For each num in nums:
  pos = binary search in tail for smallest >= num
  
  If pos == len:
    Append num (new longest LIS)
  Else:
    Replace tail[pos] with num (smaller ending)
```

**Complete trace:**
```
nums = [10, 9, 2, 5, 3, 7, 101, 18]
tail = []  (empty initially)

num = 10:
  tail empty, append
  tail = [10]

num = 9:
  Binary search: 10 >= 9, pos = 0
  Replace tail[0] = 9
  tail = [9]  (better to end with 9 than 10)

num = 2:
  Binary search: 9 >= 2, pos = 0
  Replace tail[0] = 2
  tail = [2]

num = 5:
  Binary search: 2 < 5, pos = 1 (end of array)
  Append
  tail = [2, 5]  (LIS length 2)

num = 3:
  Binary search: 2 < 3 <= 5, pos = 1
  Replace tail[1] = 3
  tail = [2, 3]  (better ending for length 2)

num = 7:
  Binary search: pos = 2 (end)
  Append
  tail = [2, 3, 7]  (LIS length 3)

num = 101:
  Binary search: pos = 3 (end)
  Append
  tail = [2, 3, 7, 101]  (LIS length 4)

num = 18:
  Binary search: 7 < 18 <= 101, pos = 3
  Replace tail[3] = 18
  tail = [2, 3, 7, 18]  (better ending for length 4)

Answer: tail.size() = 4
```

**Implementation:**
```cpp
int lengthOfLIS(vector<int>& nums) {
    vector<int> tail;
    
    for (int num : nums) {
        // Binary search for smallest element >= num
        auto it = lower_bound(tail.begin(), tail.end(), num);
        
        if (it == tail.end()) {
            tail.push_back(num);  // New longest LIS
        } else {
            *it = num;  // Replace with smaller ending
        }
    }
    
    return tail.size();
}
```

**Why it works:**
```
Invariant: tail[i] is the smallest ending value 
           of all LIS of length i+1

When we see num:
  - If num > all elements in tail: extends longest LIS
  - Otherwise: improves ending value for some length
  
tail stays sorted (binary search works)!
```

**Time:** O(n log n)  
**Space:** O(n)

---

## 2D/Grid DP

### Common Pattern

**State:** `dp[i][j]` = answer for cell (i, j)

**Recurrence:** `dp[i][j]` depends on neighbors (usually top and left)

**Base cases:** First row and/or first column

---

## Unique Paths

### Problem

**Robot at (0,0), wants to reach (m-1, n-1). Can only move right or down. Count unique paths.**

```
Grid 3Ã—3:
  S . .
  . . .
  . . E

Path 1: R R D D
Path 2: R D R D
Path 3: R D D R
Path 4: D R R D
Path 5: D R D R
Path 6: D D R R

Total: 6 paths
```

### How It Works

**State:** `dp[i][j]` = number of paths to reach (i, j)

**Recurrence:**
```
Can reach (i,j) from:
  - (i-1, j) by moving down
  - (i, j-1) by moving right

dp[i][j] = dp[i-1][j] + dp[i][j-1]
```

**Base cases:**
```
dp[0][j] = 1  (only one way: all right)
dp[i][0] = 1  (only one way: all down)
```

**Complete trace:**
```
Grid 3Ã—3:

Initialize first row and column:
  dp:
    1  1  1
    1  ?  ?
    1  ?  ?

dp[1][1] = dp[0][1] + dp[1][0] = 1 + 1 = 2
  dp:
    1  1  1
    1  2  ?
    1  ?  ?

dp[1][2] = dp[0][2] + dp[1][1] = 1 + 2 = 3
  dp:
    1  1  1
    1  2  3
    1  ?  ?

dp[2][1] = dp[1][1] + dp[2][0] = 2 + 1 = 3
  dp:
    1  1  1
    1  2  3
    1  3  ?

dp[2][2] = dp[1][2] + dp[2][1] = 3 + 3 = 6
  dp:
    1  1  1
    1  2  3
    1  3  6

Answer: dp[2][2] = 6
```

### Implementation

```cpp
int uniquePaths(int m, int n) {
    vector<vector<int>> dp(m, vector<int>(n, 1));
    
    // First row and column already 1
    
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
        }
    }
    
    return dp[m-1][n-1];
}
```

**Space-optimized (1D array):**
```cpp
int uniquePaths(int m, int n) {
    vector<int> dp(n, 1);
    
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[j] += dp[j-1];  // dp[j] = dp[j] + dp[j-1]
        }
    }
    
    return dp[n-1];
}
```

**With obstacles:**
```cpp
int uniquePathsWithObstacles(vector<vector<int>>& grid) {
    int m = grid.size(), n = grid[0].size();
    if (grid[0][0] == 1) return 0;  // Start blocked
    
    vector<vector<int>> dp(m, vector<int>(n, 0));
    dp[0][0] = 1;
    
    // First row
    for (int j = 1; j < n; j++) {
        if (grid[0][j] == 0) {
            dp[0][j] = dp[0][j-1];
        }
    }
    
    // First column
    for (int i = 1; i < m; i++) {
        if (grid[i][0] == 0) {
            dp[i][0] = dp[i-1][0];
        }
    }
    
    // Fill rest
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            if (grid[i][j] == 0) {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
    }
    
    return dp[m-1][n-1];
}
```

**Time:** O(mn)  
**Space:** O(n) with optimization

---

## Min Path Sum

### Problem

**Grid with values, find path from top-left to bottom-right with minimum sum. Can only move right or down.**

```
Grid:
  1  3  1
  1  5  1
  4  2  1

Path: 1â†’3â†’1â†’1â†’1 = 7 (optimal)
```

### How It Works

**State:** `dp[i][j]` = minimum sum to reach (i, j)

**Recurrence:**
```
dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])
```

**Base cases:**
```
dp[0][0] = grid[0][0]
dp[0][j] = dp[0][j-1] + grid[0][j]
dp[i][0] = dp[i-1][0] + grid[i][0]
```

**Complete trace:**
```
Grid:
  1  3  1
  1  5  1
  4  2  1

dp[0][0] = 1
dp[0][1] = 1 + 3 = 4
dp[0][2] = 4 + 1 = 5

dp[1][0] = 1 + 1 = 2
dp[1][1] = 5 + min(dp[0][1], dp[1][0])
         = 5 + min(4, 2) = 7
dp[1][2] = 1 + min(dp[0][2], dp[1][1])
         = 1 + min(5, 7) = 6

dp[2][0] = 2 + 4 = 6
dp[2][1] = 2 + min(dp[1][1], dp[2][0])
         = 2 + min(7, 6) = 8
dp[2][2] = 1 + min(dp[1][2], dp[2][1])
         = 1 + min(6, 8) = 7

Final dp:
  1  4  5
  2  7  6
  6  8  7

Answer: 7
Path: 1â†’1â†’5â†’1â†’1 or 1â†’3â†’1â†’1â†’1
```

### Implementation

```cpp
int minPathSum(vector<vector<int>>& grid) {
    int m = grid.size(), n = grid[0].size();
    vector<vector<int>> dp(m, vector<int>(n));
    
    dp[0][0] = grid[0][0];
    
    // First row
    for (int j = 1; j < n; j++) {
        dp[0][j] = dp[0][j-1] + grid[0][j];
    }
    
    // First column
    for (int i = 1; i < m; i++) {
        dp[i][0] = dp[i-1][0] + grid[i][0];
    }
    
    // Fill rest
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]);
        }
    }
    
    return dp[m-1][n-1];
}
```

**Time:** O(mn)  
**Space:** O(mn), can optimize to O(n)

---

## Knapsack Problems

### Problem Types

**0/1 Knapsack:** Each item can be taken 0 or 1 times

**Unbounded Knapsack:** Each item can be taken unlimited times

**Fractional Knapsack:** Can take fractions (greedy works!)

---

## 0/1 Knapsack

### Problem

**n items with weights and values. Capacity W. Maximize value without exceeding capacity. Each item used at most once.**

```
Items:
  weight = [1, 3, 4, 5]
  value  = [1, 4, 5, 7]
  capacity = 7

Best: items 1, 2 (weight = 3+4 = 7, value = 4+5 = 9)
```

### How It Works

**State:** `dp[i][w]` = max value using first i items with capacity w

**Recurrence:**
```
For item i with weight[i] and value[i]:

  If weight[i] > w:
    Can't take item i
    dp[i][w] = dp[i-1][w]
  
  Else:
    Choice: take or skip
    Take: dp[i-1][w - weight[i]] + value[i]
    Skip: dp[i-1][w]
    
    dp[i][w] = max(skip, take)
```

**Base case:**
```
dp[0][w] = 0  (no items, value = 0)
dp[i][0] = 0  (capacity 0, can't take anything)
```

**Complete trace:**
```
weight = [1, 3, 4, 5]
value  = [1, 4, 5, 7]
capacity = 7

DP table (rows = items, columns = capacity):

    w=0  w=1  w=2  w=3  w=4  w=5  w=6  w=7
i=0  0    0    0    0    0    0    0    0

i=1 (weight=1, value=1):
  w=1: max(skip=0, take=0+1) = 1
  w=2: max(skip=0, take=0+1) = 1
  ...
  Row: 0  1  1  1  1  1  1  1

i=2 (weight=3, value=4):
  w=1: can't take (weight=3 > 1), dp[1][1] = 1
  w=2: can't take, dp[1][2] = 1
  w=3: max(skip=1, take=dp[1][0]+4=4) = 4
  w=4: max(skip=1, take=dp[1][1]+4=5) = 5
  w=5: max(skip=1, take=dp[1][2]+4=5) = 5
  ...
  Row: 0  1  1  4  5  5  5  5

i=3 (weight=4, value=5):
  w=4: max(skip=5, take=dp[2][0]+5=5) = 5
  w=5: max(skip=5, take=dp[2][1]+5=6) = 6
  w=6: max(skip=5, take=dp[2][2]+5=6) = 6
  w=7: max(skip=5, take=dp[2][3]+5=9) = 9
  Row: 0  1  1  4  5  6  6  9

i=4 (weight=5, value=7):
  w=5: max(skip=6, take=dp[3][0]+7=7) = 7
  w=6: max(skip=6, take=dp[3][1]+7=8) = 8
  w=7: max(skip=9, take=dp[3][2]+7=8) = 9
  Row: 0  1  1  4  5  7  8  9

Answer: dp[4][7] = 9
Items taken: items 1 and 2 (backtrack to verify)
```

### Implementation

```cpp
int knapsack01(vector<int>& weight, vector<int>& value, int W) {
    int n = weight.size();
    vector<vector<int>> dp(n + 1, vector<int>(W + 1, 0));
    
    for (int i = 1; i <= n; i++) {
        for (int w = 1; w <= W; w++) {
            // Skip item i-1
            dp[i][w] = dp[i-1][w];
            
            // Take item i-1 if fits
            if (weight[i-1] <= w) {
                dp[i][w] = max(dp[i][w], 
                              dp[i-1][w - weight[i-1]] + value[i-1]);
            }
        }
    }
    
    return dp[n][W];
}
```

**Space-optimized (1D array):**
```cpp
int knapsack01(vector<int>& weight, vector<int>& value, int W) {
    int n = weight.size();
    vector<int> dp(W + 1, 0);
    
    for (int i = 0; i < n; i++) {
        // Iterate backwards to avoid using updated values
        for (int w = W; w >= weight[i]; w--) {
            dp[w] = max(dp[w], dp[w - weight[i]] + value[i]);
        }
    }
    
    return dp[W];
}
```

**Why backwards?**
```
If we go forward:
  dp[w] uses dp[w - weight], but we already updated it!
  Item gets counted multiple times!

Backwards ensures we use old values (previous row).
```

**Time:** O(nW)  
**Space:** O(W) with optimization

---

## Unbounded Knapsack

### Problem

**Same as 0/1 knapsack but each item can be used unlimited times.**

```
Items:
  weight = [1, 3, 4]
  value  = [1, 4, 5]
  capacity = 7

Best: item 1 three times + item 2 once
  weight = 3Ã—1 + 1Ã—4 = 7
  value = 3Ã—1 + 1Ã—5 = 8? NO
  
Actually: item 1 twice + item 2 once
  weight = 2Ã—3 + 1Ã—1 = 7
  value = 2Ã—4 + 1Ã—1 = 9 âœ“
```

### How It Works

**Difference from 0/1:** Can reuse same item!

**State:** `dp[w]` = max value with capacity w

**Recurrence:**
```
For each weight w:
  For each item i:
    If weight[i] <= w:
      dp[w] = max(dp[w], dp[w - weight[i]] + value[i])
```

**Key difference:** Use `dp[w - weight[i]]` instead of `dp[i-1][w - weight[i]]`
- Can include item i again!

**Implementation:**
```cpp
int knapsackUnbounded(vector<int>& weight, vector<int>& value, int W) {
    vector<int> dp(W + 1, 0);
    
    for (int w = 1; w <= W; w++) {
        for (int i = 0; i < weight.size(); i++) {
            if (weight[i] <= w) {
                dp[w] = max(dp[w], dp[w - weight[i]] + value[i]);
            }
        }
    }
    
    return dp[W];
}
```

**Alternative (items outer loop, forward iteration):**
```cpp
int knapsackUnbounded(vector<int>& weight, vector<int>& value, int W) {
    vector<int> dp(W + 1, 0);
    
    for (int i = 0; i < weight.size(); i++) {
        // Forward iteration (can reuse item)
        for (int w = weight[i]; w <= W; w++) {
            dp[w] = max(dp[w], dp[w - weight[i]] + value[i]);
        }
    }
    
    return dp[W];
}
```

**Time:** O(nW)  
**Space:** O(W)

---

## Subset Sum & Partition

### Subset Sum

**Problem:** Given array and target sum, can we select subset that sums to target?

```
nums = [3, 34, 4, 12, 5, 2]
target = 9

Subset: [4, 5] â†’ sum = 9 âœ“
```

### How It Works

**State:** `dp[i][s]` = can we get sum s using first i elements?

**Recurrence:**
```
For element nums[i]:
  Skip: dp[i-1][s]
  Take: dp[i-1][s - nums[i]]
  
dp[i][s] = dp[i-1][s] OR dp[i-1][s - nums[i]]
```

**Implementation:**
```cpp
bool canPartition(vector<int>& nums, int target) {
    vector<bool> dp(target + 1, false);
    dp[0] = true;  // Sum 0 is always possible (empty subset)
    
    for (int num : nums) {
        // Backwards to avoid reusing element
        for (int s = target; s >= num; s--) {
            dp[s] = dp[s] || dp[s - num];
        }
    }
    
    return dp[target];
}
```

**Complete trace:**
```
nums = [3, 4, 5]
target = 9

Initially: dp = [T, F, F, F, F, F, F, F, F, F]
                 0  1  2  3  4  5  6  7  8  9

After num=3:
  dp[9] = dp[9] || dp[6] = F
  dp[8] = dp[8] || dp[5] = F
  ...
  dp[3] = dp[3] || dp[0] = T
  
  dp = [T, F, F, T, F, F, F, F, F, F]

After num=4:
  dp[9] = dp[9] || dp[5] = F
  dp[8] = dp[8] || dp[4] = F
  dp[7] = dp[7] || dp[3] = T (3+4=7)
  dp[4] = dp[4] || dp[0] = T
  
  dp = [T, F, F, T, T, F, F, T, F, F]

After num=5:
  dp[9] = dp[9] || dp[4] = T (4+5=9) âœ“
  dp[8] = dp[8] || dp[3] = T (3+5=8)
  dp[5] = dp[5] || dp[0] = T
  
  dp = [T, F, F, T, T, T, F, T, T, T]

Answer: dp[9] = true
```

### Partition Equal Subset Sum

**Problem:** Can we partition array into two subsets with equal sum?

```
nums = [1, 5, 11, 5]

Partition 1: [1, 5, 5] = 11
Partition 2: [11] = 11
Yes! âœ“
```

**Solution:** If total sum is odd, impossible. Otherwise, find subset summing to sum/2.

```cpp
bool canPartition(vector<int>& nums) {
    int sum = accumulate(nums.begin(), nums.end(), 0);
    
    if (sum % 2 == 1) return false;  // Odd sum
    
    int target = sum / 2;
    vector<bool> dp(target + 1, false);
    dp[0] = true;
    
    for (int num : nums) {
        for (int s = target; s >= num; s--) {
            dp[s] = dp[s] || dp[s - num];
        }
    }
    
    return dp[target];
}
```

**Time:** O(n Ã— sum)  
**Space:** O(sum)

---

## String DP

### Common Pattern

**Two strings:** `dp[i][j]` relates to s1[0..i] and s2[0..j]

**One string:** `dp[i][j]` for substring s[i..j]

---

## Longest Common Subsequence (LCS)

### Problem

**Find length of longest subsequence common to both strings.**

```
s1 = "ABCDGH"
s2 = "AEDFHR"

LCS: "ADH" (length 3)
```

### How It Works

**State:** `dp[i][j]` = LCS length of s1[0..i-1] and s2[0..j-1]

**Recurrence:**
```
If s1[i-1] == s2[j-1]:
  Match! Extend LCS
  dp[i][j] = dp[i-1][j-1] + 1

Else:
  No match, try skipping one character
  dp[i][j] = max(dp[i-1][j], dp[i][j-1])
```

**Base case:**
```
dp[0][j] = 0  (empty s1)
dp[i][0] = 0  (empty s2)
```

**Complete trace:**
```
s1 = "ABCDGH"
s2 = "AEDFHR"

DP table:
      ""  A  E  D  F  H  R
  ""   0  0  0  0  0  0  0
  A    0  1  1  1  1  1  1
  B    0  1  1  1  1  1  1
  C    0  1  1  1  1  1  1
  D    0  1  1  2  2  2  2
  G    0  1  1  2  2  2  2
  H    0  1  1  2  2  3  3

Building:
  dp[1][1]: s1[0]='A' == s2[0]='A'
    dp[1][1] = dp[0][0] + 1 = 1

  dp[1][2]: s1[0]='A' != s2[1]='E'
    dp[1][2] = max(dp[0][2], dp[1][1]) = 1

  dp[4][3]: s1[3]='D' == s2[2]='D'
    dp[4][3] = dp[3][2] + 1 = 2

  dp[6][5]: s1[5]='H' == s2[4]='H'
    dp[6][5] = dp[5][4] + 1 = 3

Answer: dp[6][6] = 3
```

**Visual of matching:**
```
s1: A B C D G H
    â†“     â†“   â†“
s2: A E D F H R

LCS: A D H
```

### Implementation

```cpp
int longestCommonSubsequence(string s1, string s2) {
    int m = s1.length(), n = s2.length();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (s1[i-1] == s2[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    
    return dp[m][n];
}
```

**Space-optimized:**
```cpp
int longestCommonSubsequence(string s1, string s2) {
    int m = s1.length(), n = s2.length();
    vector<int> prev(n + 1, 0), curr(n + 1, 0);
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (s1[i-1] == s2[j-1]) {
                curr[j] = prev[j-1] + 1;
            } else {
                curr[j] = max(prev[j], curr[j-1]);
            }
        }
        swap(prev, curr);
    }
    
    return prev[n];
}
```

**Reconstruct LCS:**
```cpp
string reconstructLCS(string s1, string s2, vector<vector<int>>& dp) {
    int i = s1.length(), j = s2.length();
    string lcs;
    
    while (i > 0 && j > 0) {
        if (s1[i-1] == s2[j-1]) {
            lcs = s1[i-1] + lcs;
            i--; j--;
        } else if (dp[i-1][j] > dp[i][j-1]) {
            i--;
        } else {
            j--;
        }
    }
    
    return lcs;
}
```

**Time:** O(mn)  
**Space:** O(n) with optimization

---

## Edit Distance

### Problem

**Minimum operations (insert, delete, replace) to convert s1 to s2.**

```
s1 = "horse"
s2 = "ros"

Operations:
  1. Replace 'h' with 'r': "rorse"
  2. Delete 'r': "rose"  
  3. Delete 'e': "ros"

Minimum: 3
```

### How It Works

**State:** `dp[i][j]` = min operations to convert s1[0..i-1] to s2[0..j-1]

**Recurrence:**
```
If s1[i-1] == s2[j-1]:
  Characters match, no operation needed
  dp[i][j] = dp[i-1][j-1]

Else:
  Try all operations:
    Insert: dp[i][j-1] + 1
    Delete: dp[i-1][j] + 1
    Replace: dp[i-1][j-1] + 1
  
  dp[i][j] = min(insert, delete, replace)
```

**Base cases:**
```
dp[0][j] = j  (insert j characters)
dp[i][0] = i  (delete i characters)
```

**Complete trace:**
```
s1 = "horse"
s2 = "ros"

DP table:
      ""  r  o  s
  ""   0  1  2  3
  h    1  1  2  3
  o    2  2  1  2
  r    3  2  2  2
  s    4  3  3  2
  e    5  4  4  3

Building:
  dp[1][1]: s1[0]='h' != s2[0]='r'
    Insert: dp[1][0] + 1 = 2
    Delete: dp[0][1] + 1 = 2
    Replace: dp[0][0] + 1 = 1 âœ“
    dp[1][1] = 1

  dp[2][2]: s1[1]='o' == s2[1]='o'
    dp[2][2] = dp[1][1] = 1

  dp[3][1]: s1[2]='r' == s2[0]='r'
    dp[3][1] = dp[2][0] = 2

  dp[5][3]: s1[4]='e' != s2[2]='s'
    Insert: dp[5][2] + 1 = 5
    Delete: dp[4][3] + 1 = 3 âœ“
    Replace: dp[4][2] + 1 = 4
    dp[5][3] = 3

Answer: dp[5][3] = 3
```

**Operations:**
```
"horse" â†’ "ros"

Step 1: Replace 'h' with 'r'
  "rorse"

Step 2: Delete 'r'
  "rose"

Step 3: Delete 'e'
  "ros" âœ“
```

### Implementation

```cpp
int minDistance(string s1, string s2) {
    int m = s1.length(), n = s2.length();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));
    
    // Base cases
    for (int i = 0; i <= m; i++) dp[i][0] = i;
    for (int j = 0; j <= n; j++) dp[0][j] = j;
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (s1[i-1] == s2[j-1]) {
                dp[i][j] = dp[i-1][j-1];
            } else {
                dp[i][j] = 1 + min({
                    dp[i][j-1],    // Insert
                    dp[i-1][j],    // Delete
                    dp[i-1][j-1]   // Replace
                });
            }
        }
    }
    
    return dp[m][n];
}
```

**Time:** O(mn)  
**Space:** O(mn), can optimize to O(n)

---

## Palindrome Partitioning

### Problem

**Minimum cuts to partition string into palindromes.**

```
s = "aab"

Partition: "aa" | "b" (both palindromes)
Cuts: 1

Alternative: "a" | "a" | "b"
Cuts: 2 (not minimal)
```

### How It Works

**State:** `dp[i]` = min cuts for s[0..i]

**Recurrence:**
```
For each position i:
  For each j from 0 to i:
    If s[j..i] is palindrome:
      dp[i] = min(dp[i], dp[j-1] + 1)
```

**Need helper:** Check if substring is palindrome.

**Complete trace:**
```
s = "aab"

Precompute palindromes:
  isPalin[i][j] = is s[i..j] palindrome?
  
      a  a  b
  a   T  T  F
  a      T  F
  b         T

dp[0] = 0  (single char "a", no cuts)

dp[1]:
  j=0: s[0..1]="aa" is palindrome
    dp[1] = min(âˆž, dp[-1] + 1) = 0
    
dp[2]:
  j=0: s[0..2]="aab" not palindrome
  j=1: s[1..2]="ab" not palindrome
  j=2: s[2..2]="b" is palindrome
    dp[2] = min(âˆž, dp[1] + 1) = 1

Answer: dp[2] = 1
Partition: "aa" | "b"
```

### Implementation

```cpp
int minCut(string s) {
    int n = s.length();
    
    // Precompute palindromes
    vector<vector<bool>> isPalin(n, vector<bool>(n, false));
    
    for (int i = 0; i < n; i++) {
        isPalin[i][i] = true;  // Single char
    }
    
    for (int len = 2; len <= n; len++) {
        for (int i = 0; i <= n - len; i++) {
            int j = i + len - 1;
            
            if (s[i] == s[j]) {
                if (len == 2) {
                    isPalin[i][j] = true;
                } else {
                    isPalin[i][j] = isPalin[i+1][j-1];
                }
            }
        }
    }
    
    // DP for min cuts
    vector<int> dp(n, INT_MAX);
    
    for (int i = 0; i < n; i++) {
        if (isPalin[0][i]) {
            dp[i] = 0;  // Whole string is palindrome
        } else {
            for (int j = 0; j < i; j++) {
                if (isPalin[j+1][i]) {
                    dp[i] = min(dp[i], dp[j] + 1);
                }
            }
        }
    }
    
    return dp[n-1];
}
```

**Optimized palindrome check (expand from center):**
```cpp
int minCut(string s) {
    int n = s.length();
    vector<int> dp(n, INT_MAX);
    vector<vector<bool>> isPalin(n, vector<bool>(n, false));
    
    for (int i = 0; i < n; i++) {
        // Odd length palindromes
        for (int l = i, r = i; l >= 0 && r < n && s[l] == s[r]; l--, r++) {
            isPalin[l][r] = true;
        }
        
        // Even length palindromes
        for (int l = i, r = i+1; l >= 0 && r < n && s[l] == s[r]; l--, r++) {
            isPalin[l][r] = true;
        }
    }
    
    for (int i = 0; i < n; i++) {
        if (isPalin[0][i]) {
            dp[i] = 0;
        } else {
            for (int j = 0; j < i; j++) {
                if (isPalin[j+1][i]) {
                    dp[i] = min(dp[i], dp[j] + 1);
                }
            }
        }
    }
    
    return dp[n-1];
}
```

**Time:** O(nÂ²)  
**Space:** O(nÂ²)

---

## Common Problems

### Problem 1: Climbing Stairs

```cpp
int climbStairs(int n) {
    if (n <= 2) return n;
    
    int prev2 = 1, prev1 = 2;
    
    for (int i = 3; i <= n; i++) {
        int curr = prev1 + prev2;
        prev2 = prev1;
        prev1 = curr;
    }
    
    return prev1;
}
```

### Problem 2: Coin Change

```cpp
int coinChange(vector<int>& coins, int amount) {
    vector<int> dp(amount + 1, INT_MAX);
    dp[0] = 0;
    
    for (int a = 1; a <= amount; a++) {
        for (int coin : coins) {
            if (coin <= a && dp[a - coin] != INT_MAX) {
                dp[a] = min(dp[a], dp[a - coin] + 1);
            }
        }
    }
    
    return dp[amount] == INT_MAX ? -1 : dp[amount];
}
```

### Problem 3: Longest Palindromic Subsequence

```cpp
int longestPalindromeSubseq(string s) {
    string rev = s;
    reverse(rev.begin(), rev.end());
    
    // LCS of s and reverse(s)
    return longestCommonSubsequence(s, rev);
}
```

### Problem 4: Maximum Subarray (Kadane's)

```cpp
int maxSubArray(vector<int>& nums) {
    int maxSum = nums[0];
    int currSum = nums[0];
    
    for (int i = 1; i < nums.size(); i++) {
        currSum = max(nums[i], currSum + nums[i]);
        maxSum = max(maxSum, currSum);
    }
    
    return maxSum;
}
```

---

## Summary Tables

### DP Problem Types

| Type | State | Example | Complexity |
|------|-------|---------|------------|
| **1D** | `dp[i]` | House robber, frog jump | O(n) |
| **2D** | `dp[i][j]` | Unique paths, LCS | O(mn) |
| **Knapsack** | `dp[i][w]` | 0/1 knapsack | O(nW) |
| **String** | `dp[i][j]` | Edit distance | O(mn) |

### Common Patterns

| Pattern | Recurrence | Example |
|---------|------------|---------|
| **Linear** | `dp[i] = f(dp[i-1], dp[i-2])` | Fibonacci, stairs |
| **Choice** | `dp[i] = max/min(take, skip)` | Knapsack, robber |
| **Grid** | `dp[i][j] = f(dp[i-1][j], dp[i][j-1])` | Paths, min sum |
| **String match** | Match: `dp[i-1][j-1] + 1` | LCS, edit distance |

### Space Optimization

| Original | Optimized | Technique |
|----------|-----------|-----------|
| O(n) | O(1) | Keep last 2 values |
| O(mn) 2D | O(n) 1D | Process row by row |
| O(nW) knapsack | O(W) | Reverse iteration |

---

## Practice Problems

### 1D DP
- [ ] Climbing Stairs
- [ ] House Robber I & II
- [ ] Jump Game
- [ ] Decode Ways
- [ ] Maximum Product Subarray

### 2D/Grid DP
- [ ] Unique Paths I & II
- [ ] Minimum Path Sum
- [ ] Triangle
- [ ] Maximal Square
- [ ] Dungeon Game

### Knapsack
- [ ] 0/1 Knapsack
- [ ] Partition Equal Subset Sum
- [ ] Target Sum
- [ ] Coin Change I & II
- [ ] Perfect Squares

### String DP
- [ ] Longest Common Subsequence
- [ ] Edit Distance
- [ ] Distinct Subsequences
- [ ] Palindrome Partitioning I & II
- [ ] Longest Palindromic Substring

### LIS
- [ ] Longest Increasing Subsequence
- [ ] Number of LIS
- [ ] Russian Doll Envelopes
- [ ] Maximum Length of Pair Chain

---

## Key Takeaways

1. **House robber: dp[i] = max(skip, rob)** - Can't rob adjacent
2. **Frog jump: dp[i] = min cost to reach stone i** - Try all possible jumps
3. **LIS O(nÂ²): dp[i] = max LIS ending at i** - Check all j < i
4. **LIS O(n log n): Binary search in tail array** - Maintain smallest endings
5. **Grid DP: dp[i][j] = f(top, left)** - Only two directions
6. **Unique paths: dp[i][j] = dp[i-1][j] + dp[i][j-1]** - Add paths
7. **Min path sum: Add grid value to min of neighbors** - Greedy doesn't work!
8. **0/1 knapsack: Iterate backwards** - Avoid reusing items
9. **Unbounded knapsack: Iterate forwards** - Can reuse items
10. **Subset sum: Boolean DP** - Can achieve sum or not
11. **LCS: Match â†’ diagonal + 1, no match â†’ max(top, left)** - Two strings
12. **Edit distance: Match â†’ diagonal, no match â†’ min(insert, delete, replace) + 1** - Three operations
13. **Palindrome partitioning: Precompute palindromes** - O(nÂ²) check
14. **Space optimization: Rolling array or last k values** - Reduce memory
15. **Reconstruct solution: Track choices or backtrack DP table** - Build answer

Master these DP patterns and you'll solve any DP problem! ðŸ’¡

