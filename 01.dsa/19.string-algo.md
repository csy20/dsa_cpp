# String Algorithms

## Table of Contents
1. [String Algorithm Overview](#string-algorithm-overview)
2. [KMP Algorithm](#kmp-algorithm)
3. [KMP: LPS Array Construction](#kmp-lps-array-construction)
4. [KMP: Pattern Matching](#kmp-pattern-matching)
5. [Z-Algorithm](#z-algorithm)
6. [Z-Algorithm: Pattern Search](#z-algorithm-pattern-search)
7. [Rolling Hash (Rabin-Karp)](#rolling-hash-rabin-karp)
8. [Hash Collision Handling](#hash-collision-handling)
9. [Trie (Prefix Tree)](#trie-prefix-tree)
10. [Trie: Prefix Queries](#trie-prefix-queries)
11. [Manacher's Algorithm](#manachers-algorithm)
12. [Suffix Array Introduction](#suffix-array-introduction)
13. [Common Problems](#common-problems)

---

## String Algorithm Overview

### Pattern Matching Problem

**Given:**
- Text T of length n
- Pattern P of length m

**Find:** All occurrences of P in T

**Naive approach:** Check every position â†’ O(nm)

**Efficient algorithms:** O(n + m) or O(n) with preprocessing

### Algorithm Comparison

| Algorithm | Preprocessing | Search | Space | Best For |
|-----------|---------------|--------|-------|----------|
| **Naive** | - | O(nm) | O(1) | Very short patterns |
| **KMP** | O(m) | O(n) | O(m) | Single pattern, guaranteed O(n) |
| **Z-Algorithm** | - | O(n+m) | O(n+m) | Pattern search, string analysis |
| **Rabin-Karp** | O(m) | O(n+m) avg | O(1) | Multiple patterns, approximate matching |
| **Trie** | O(mk) | O(n) | O(ALPHABETÃ—nodes) | Multiple patterns, prefix queries |

**When to use each:**

**KMP:**
âœ… Need guaranteed linear time  
âœ… Single pattern matching  
âœ… Understanding string borders/periods

**Z-Algorithm:**
âœ… Simpler than KMP  
âœ… Multiple applications (palindromes, periods)  
âœ… Pattern matching with concatenation

**Rabin-Karp:**
âœ… Multiple pattern search  
âœ… 2D pattern matching  
âœ… Approximate/fuzzy matching

**Trie:**
âœ… Prefix-based queries  
âœ… Autocomplete  
âœ… Multiple pattern matching (Aho-Corasick)

---

## KMP Algorithm

### What is KMP?

**Knuth-Morris-Pratt:** Linear-time pattern matching using failure function.

**Key insight:** When mismatch occurs, don't restart from scratch!

**Use pattern's self-similarity to skip unnecessary comparisons.**

### How KMP Works

**Core concept: Borders**

**Border:** Proper prefix that is also a suffix.

**Example:**
```
Pattern: "ABABC"

Prefixes:  A, AB, ABA, ABAB, ABABC
Suffixes:  ABABC, BABC, ABC, BC, C

Borders for each prefix:
  "A"     â†’ border: "" (length 0)
  "AB"    â†’ border: "" (length 0)
  "ABA"   â†’ border: "A" (length 1)
  "ABAB"  â†’ border: "AB" (length 2)
  "ABABC" â†’ border: "" (length 0)
```

**LPS Array (Longest Proper Prefix which is also Suffix):**
```
Pattern: A B A B C
Index:   0 1 2 3 4
LPS:     0 0 1 2 0

lps[i] = length of longest border of pattern[0..i]
```

**Why borders matter:**
```
Text:    A B A B D
Pattern: A B A B C
Match:   âœ“ âœ“ âœ“ âœ“ âœ—

Naive: restart pattern from position 1

KMP: pattern has border "AB"
     We know text has "AB" before mismatch
     Skip directly to position matching this border!
     
Text:    A B A B D
Pattern:     A B A B C
             â†‘ Continue from here
```

### LPS Array Intuition

**lps[i] tells us: "If mismatch at i+1, where to continue matching?"**

**Visual:**
```
Pattern: A B A B A B C A
LPS:     0 0 1 2 3 4 0 1

At position 6 (pattern[6] = 'C'):
  lps[5] = 4 means:
    pattern[0..3] = pattern[2..5] = "ABAB"
  
If mismatch after position 5:
  We already matched "ABAB"
  No need to re-check "ABAB"
  Continue matching from lps[5] = 4
```

**Self-matching pattern:**
```
We build LPS by matching pattern against itself!

Pattern: A B A B C
         â†“ â†“ â†“ â†“ â†“
         A B A B C

i=0: No border, lps[0] = 0
i=1: "AB" has no matching prefix, lps[1] = 0
i=2: "ABA" has "A", lps[2] = 1
i=3: "ABAB" has "AB", lps[3] = 2
i=4: "ABABC" has no matching prefix, lps[4] = 0
```

---

## KMP: LPS Array Construction

### Algorithm

```cpp
vector<int> computeLPS(string pattern) {
    int m = pattern.size();
    vector<int> lps(m, 0);
    
    int len = 0;  // Length of previous longest prefix suffix
    int i = 1;
    
    while (i < m) {
        if (pattern[i] == pattern[len]) {
            len++;
            lps[i] = len;
            i++;
        } else {
            if (len != 0) {
                len = lps[len - 1];  // Try shorter border
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
    
    return lps;
}
```

### Complete Trace

```
Pattern: A B C A B C D
Index:   0 1 2 3 4 5 6

Step-by-step:

Initial: len = 0, i = 1

i=1: pattern[1]='B' vs pattern[0]='A'
  Mismatch, len=0
  lps[1] = 0, i=2

i=2: pattern[2]='C' vs pattern[0]='A'
  Mismatch, len=0
  lps[2] = 0, i=3

i=3: pattern[3]='A' vs pattern[0]='A'
  Match! len=1
  lps[3] = 1, i=4

i=4: pattern[4]='B' vs pattern[1]='B'
  Match! len=2
  lps[4] = 2, i=5

i=5: pattern[5]='C' vs pattern[2]='C'
  Match! len=3
  lps[5] = 3, i=6

i=6: pattern[6]='D' vs pattern[3]='A'
  Mismatch, len=3 > 0
  len = lps[3-1] = lps[2] = 0
  
  pattern[6]='D' vs pattern[0]='A'
  Mismatch, len=0
  lps[6] = 0, i=7

Final LPS: [0, 0, 0, 1, 2, 3, 0]
```

**Why `len = lps[len-1]` works:**
```
If pattern[0..len-1] matches pattern[i-len..i-1]
but pattern[len] â‰  pattern[i]:

Try next shorter border!

pattern[0..lps[len-1]-1] is a border of pattern[0..len-1]
So it's also a border of pattern[i-len..i-1]

Example:
  Pattern: A B C A B D A B C
           0 1 2 3 4 5 6 7 8
  
  At i=8, len=5:
    pattern[5]='D' â‰  pattern[8]='C'
    
  len = lps[4] = 2
    Try matching pattern[2]='C' with pattern[8]='C'
    Match! lps[8] = 3
```

**Time:** O(m) - each character processed at most twice

---

## KMP: Pattern Matching

### Algorithm

```cpp
vector<int> KMP(string text, string pattern) {
    int n = text.size();
    int m = pattern.size();
    
    vector<int> lps = computeLPS(pattern);
    vector<int> matches;
    
    int i = 0;  // Index in text
    int j = 0;  // Index in pattern
    
    while (i < n) {
        if (text[i] == pattern[j]) {
            i++;
            j++;
        }
        
        if (j == m) {
            matches.push_back(i - j);  // Found match
            j = lps[j - 1];
        } else if (i < n && text[i] != pattern[j]) {
            if (j != 0) {
                j = lps[j - 1];  // Use LPS to skip
            } else {
                i++;
            }
        }
    }
    
    return matches;
}
```

### Complete Trace

```
Text:    A B C A B C A B C A B D
Pattern: A B C A B D

LPS:     0 0 0 1 2 0

Search:

i=0, j=0: text[0]='A' = pattern[0]='A', match, i=1, j=1
i=1, j=1: text[1]='B' = pattern[1]='B', match, i=2, j=2
i=2, j=2: text[2]='C' = pattern[2]='C', match, i=3, j=3
i=3, j=3: text[3]='A' = pattern[3]='A', match, i=4, j=4
i=4, j=4: text[4]='B' = pattern[4]='B', match, i=5, j=5
i=5, j=5: text[5]='C' â‰  pattern[5]='D', mismatch!
  
  j=5 > 0, use LPS: j = lps[4] = 2
  
  Why? We matched "ABCAB"
       lps[4] = 2 means "AB" is a border
       Text has "AB" at positions [3,4]
       Continue matching from pattern[2]

i=5, j=2: text[5]='C' = pattern[2]='C', match, i=6, j=3
i=6, j=3: text[6]='A' = pattern[3]='A', match, i=7, j=4
i=7, j=4: text[7]='B' = pattern[4]='B', match, i=8, j=5
i=8, j=5: text[8]='C' â‰  pattern[5]='D', mismatch!
  
  j = lps[4] = 2

i=8, j=2: text[8]='C' = pattern[2]='C', match, i=9, j=3
i=9, j=3: text[9]='A' = pattern[3]='A', match, i=10, j=4
i=10, j=4: text[10]='B' = pattern[4]='B', match, i=11, j=5
i=11, j=5: text[11]='D' = pattern[5]='D', match, i=12, j=6

j=6 = m, found match at position i-j = 12-6 = 6

Matches: [6]

Visual:
Text:    A B C A B C A B C A B D
Pattern:             A B C A B D
                     â†‘ Match at index 6
```

**Why KMP is O(n):**
```
Key: i never decreases!

Each iteration either:
  1. i increases (advance in text)
  2. j decreases (use LPS)

j can decrease at most i times
Total operations: â‰¤ 2n
```

**Time:** O(n + m)  
**Space:** O(m)

---

## Z-Algorithm

### What is Z-Algorithm?

**Z[i] = length of longest substring starting at i which is also a prefix of string.**

**Example:**
```
String: A B A C A B A
Index:  0 1 2 3 4 5 6
Z:      - 0 1 0 3 0 1

Z[0] = undefined (entire string)
Z[1] = 0: "BACABA" vs "ABACABA" â†’ no match
Z[2] = 1: "ACABA" vs "ABACABA" â†’ "A" matches
Z[3] = 0: "CABA" vs "ABACABA" â†’ no match
Z[4] = 3: "ABA" vs "ABACABA" â†’ "ABA" matches
Z[5] = 0: "BA" vs "ABACABA" â†’ no match
Z[6] = 1: "A" vs "ABACABA" â†’ "A" matches
```

### How Z-Algorithm Works

**Key optimization: Use previously computed Z values!**

**Maintain Z-box [L, R]:** Rightmost segment matching prefix.

**Visual:**
```
String: A B A B C A B A B D
        0 1 2 3 4 5 6 7 8 9

Computing Z[5]:
  Previous Z-box: [2, 4] (substring "ABC" matched "ABC")
  
  Position 5 is at R+1
  No information, compute naively
  
Computing Z[6]:
  If [L, R] = [5, 8] (substring "ABAB" matched prefix)
  
  Position 6 is inside [L, R]
  Position 6 corresponds to position 6-L = 1 in prefix
  
  We already know Z[1]!
  Use Z[1] as starting point
```

### Algorithm

```cpp
vector<int> computeZ(string s) {
    int n = s.size();
    vector<int> z(n);
    z[0] = n;  // Or leave undefined
    
    int L = 0, R = 0;
    
    for (int i = 1; i < n; i++) {
        if (i > R) {
            // Outside Z-box, compute naively
            L = R = i;
            while (R < n && s[R - L] == s[R]) {
                R++;
            }
            z[i] = R - L;
            R--;
        } else {
            // Inside Z-box, use previous Z value
            int k = i - L;
            
            if (z[k] < R - i + 1) {
                z[i] = z[k];
            } else {
                L = i;
                while (R < n && s[R - L] == s[R]) {
                    R++;
                }
                z[i] = R - L;
                R--;
            }
        }
    }
    
    return z;
}
```

### Complete Trace

```
String: A A B A A B C
Index:  0 1 2 3 4 5 6
Z:      7 1 0 3 1 0 0

Build Z array:

i=0: z[0] = 7 (length of string)
L=0, R=0

i=1: i > R (1 > 0)
  Naive comparison:
    s[0]='A' = s[1]='A', R=2
    s[1]='A' â‰  s[2]='B', stop
  z[1] = 1, L=1, R=1

i=2: i > R (2 > 1)
  Naive comparison:
    s[0]='A' â‰  s[2]='B', stop
  z[2] = 0, L=2, R=1 (R < L)

i=3: i > R (3 > 1)
  Naive comparison:
    s[0]='A' = s[3]='A', R=4
    s[1]='A' = s[4]='A', R=5
    s[2]='B' = s[5]='B', R=6
    s[3]='A' â‰  s[6]='C', stop
  z[3] = 3, L=3, R=5

i=4: i <= R (4 <= 5)
  k = i - L = 4 - 3 = 1
  z[k] = z[1] = 1
  R - i + 1 = 5 - 4 + 1 = 2
  
  z[1]=1 < 2, so z[4] = z[1] = 1
  (No need to extend)

i=5: i <= R (5 <= 5)
  k = i - L = 5 - 3 = 2
  z[k] = z[2] = 0
  R - i + 1 = 5 - 5 + 1 = 1
  
  z[2]=0 < 1, so z[5] = z[2] = 0

i=6: i > R (6 > 5)
  Naive comparison:
    s[0]='A' â‰  s[6]='C', stop
  z[6] = 0

Final Z: [7, 1, 0, 3, 1, 0, 0]
```

**Time:** O(n) - R never decreases, each character examined at most twice  
**Space:** O(n)

---

## Z-Algorithm: Pattern Search

### Pattern Matching with Z

**Concatenate pattern and text:** `S = pattern + "$" + text`

**$ is a separator (not in alphabet)**

**Find Z values â‰¥ len(pattern)**

```cpp
vector<int> patternSearch(string text, string pattern) {
    string s = pattern + "$" + text;
    vector<int> z = computeZ(s);
    
    vector<int> matches;
    int m = pattern.size();
    
    for (int i = m + 1; i < s.size(); i++) {
        if (z[i] == m) {
            matches.push_back(i - m - 1);  // Position in text
        }
    }
    
    return matches;
}
```

### Example

```
Pattern: ABA
Text:    ABACABA

Concatenation: ABA$ABACABA
Index:         0123456789A

Z array:
  z[0] = 11
  z[1] = 0
  z[2] = 1
  z[3] = 0 (separator)
  z[4] = 3  â† "ABA" matches pattern!
  z[5] = 0
  z[6] = 1
  z[7] = 0
  z[8] = 3  â† "ABA" matches pattern!
  z[9] = 0
  z[A] = 1

Matches at positions:
  z[4] = 3 â†’ text position 4 - 3 - 1 = 0
  z[8] = 3 â†’ text position 8 - 3 - 1 = 4

Text:    A B A C A B A
         â†‘       â†‘
         0       4
```

### Why Z-Algorithm is Useful

**1. Simple to implement** (compared to KMP)

**2. Multiple applications:**
- Pattern matching
- Finding periods
- Palindrome detection
- String compression

**3. Z-box concept generalizes** to other problems

---

## Rolling Hash (Rabin-Karp)

### What is Rolling Hash?

**Hash function that can be updated in O(1) when sliding window.**

**Idea:**
```
Hash of "ABC" = 1Ã—31Â² + 2Ã—31Â¹ + 3Ã—31â° (treat as base-31 number)

Slide window right: "ABC" â†’ "BCD"
  Remove 'A': subtract 1Ã—31Â²
  Add 'D': multiply by 31, add 4
```

### How Rabin-Karp Works

**Polynomial rolling hash:**
```
hash(s) = (s[0]Ã—p^(n-1) + s[1]Ã—p^(n-2) + ... + s[n-1]Ã—p^0) mod M

p = base (typically prime, e.g., 31 or 37)
M = modulo (large prime, e.g., 10^9+7 or 10^9+9)
```

**Rolling update:**
```
Old window: [s[i], s[i+1], ..., s[i+m-1]]
New window: [s[i+1], s[i+2], ..., s[i+m]]

new_hash = (old_hash - s[i]Ã—p^(m-1)) Ã— p + s[i+m]
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”˜   â””â”€â”€â”€â”€â”˜
           Remove first char       Shift  Add last
```

### Implementation

```cpp
class RollingHash {
    const long long P = 31;
    const long long M = 1e9 + 7;
    
    long long power(long long a, long long b, long long mod) {
        long long res = 1;
        while (b > 0) {
            if (b & 1) res = (res * a) % mod;
            a = (a * a) % mod;
            b >>= 1;
        }
        return res;
    }
    
public:
    long long computeHash(string s) {
        long long hash = 0;
        long long p_pow = 1;
        
        for (int i = 0; i < s.size(); i++) {
            hash = (hash + (s[i] - 'a' + 1) * p_pow) % M;
            p_pow = (p_pow * P) % M;
        }
        
        return hash;
    }
    
    vector<int> search(string text, string pattern) {
        int n = text.size();
        int m = pattern.size();
        
        if (m > n) return {};
        
        long long patternHash = computeHash(pattern);
        long long textHash = computeHash(text.substr(0, m));
        
        long long p_pow = power(P, m - 1, M);
        
        vector<int> matches;
        
        for (int i = 0; i <= n - m; i++) {
            if (textHash == patternHash) {
                // Hash match, verify actual string
                if (text.substr(i, m) == pattern) {
                    matches.push_back(i);
                }
            }
            
            if (i < n - m) {
                // Roll hash
                textHash = (textHash - (text[i] - 'a' + 1)) % M;
                if (textHash < 0) textHash += M;
                textHash = (textHash * P) % M;
                textHash = (textHash + (text[i + m] - 'a' + 1)) % M;
            }
        }
        
        return matches;
    }
};
```

### Complete Trace

```
Text:    ABCDABC
Pattern: ABC

Pattern hash:
  hash('ABC') = 1Ã—31Â² + 2Ã—31Â¹ + 3Ã—31â° mod M
              = 961 + 62 + 3
              = 1026

Window 0: "ABC"
  hash = 1026
  Match! (hash equals pattern, verify string â†’ true)
  
Roll to window 1: "BCD"
  Remove 'A': hash = (1026 - 1Ã—31Â²) mod M = 65
  Shift and add 'D': hash = (65Ã—31 + 4) mod M = 2019

Window 1: "BCD"
  hash = 2019 â‰  1026
  No match

Roll to window 2: "CDA"
  Remove 'B': hash = (2019 - 2Ã—31Â²) mod M
  Continue...

Roll to window 4: "ABC"
  hash = 1026
  Match! (verify string â†’ true)

Matches: [0, 4]
```

**Time:**
- Average: O(n + m)
- Worst: O(nm) (all hash collisions)

**Space:** O(1)

---

## Hash Collision Handling

### Why Collisions Matter

**Hash collision:** Different strings with same hash value.

**Example:**
```
Using small modulo M = 100:
  hash("AB") = (1Ã—31 + 2) mod 100 = 33
  hash("BC") might also be 33 (different calculation)
```

**Collision probability:** Depends on M and string length.

### Collision Mitigation Strategies

**1. Use large prime modulo**
```cpp
const long long M1 = 1e9 + 7;
const long long M2 = 1e9 + 9;
```

**2. Double hashing**
```cpp
struct DoubleHash {
    long long h1, h2;
    
    bool operator==(const DoubleHash& other) const {
        return h1 == other.h1 && h2 == other.h2;
    }
};

DoubleHash computeHash(string s) {
    long long h1 = 0, h2 = 0;
    long long p1 = 1, p2 = 1;
    
    for (char c : s) {
        h1 = (h1 + (c - 'a' + 1) * p1) % M1;
        h2 = (h2 + (c - 'a' + 1) * p2) % M2;
        p1 = (p1 * 31) % M1;
        p2 = (p2 * 37) % M2;  // Different base
    }
    
    return {h1, h2};
}
```

**3. Verify on collision**
```cpp
if (hash1 == hash2) {
    if (str1 == str2) {  // Actual comparison
        // True match
    }
}
```

### Collision Probability Analysis

**Birthday paradox:** With M possible hash values and n strings:
```
P(collision) â‰ˆ 1 - e^(-nÂ²/(2M))

For M = 10^9:
  n = 10^4 â†’ P â‰ˆ 0.00005 (very low)
  n = 10^5 â†’ P â‰ˆ 0.5 (HIGH!)
```

**Double hashing:**
```
P(collision) â‰ˆ (nÂ²/(2M1)) Ã— (nÂ²/(2M2))

With M1 = M2 = 10^9:
  n = 10^5 â†’ P â‰ˆ 0.5 Ã— 0.5 Ã— 10^-9 â‰ˆ 10^-9 (negligible!)
```

### Safe Hashing Practice

```cpp
class SafeRollingHash {
    static const long long M1 = 1e9 + 7;
    static const long long M2 = 1e9 + 9;
    static const int P1 = 31;
    static const int P2 = 37;
    
    long long h1, h2;
    
public:
    SafeRollingHash(string s) {
        h1 = h2 = 0;
        long long p1 = 1, p2 = 1;
        
        for (char c : s) {
            h1 = (h1 + (c - 'a' + 1) * p1) % M1;
            h2 = (h2 + (c - 'a' + 1) * p2) % M2;
            p1 = (p1 * P1) % M1;
            p2 = (p2 * P2) % M2;
        }
    }
    
    bool operator==(const SafeRollingHash& other) const {
        return h1 == other.h1 && h2 == other.h2;
    }
};
```

**Key takeaways:**
- Always use large prime modulo (â‰¥ 10^9)
- Use double hashing for critical applications
- Verify string equality on hash match when needed
- Understand collision probability for your use case

---

## Trie (Prefix Tree)

### What is Trie?

**Tree structure storing strings with common prefixes.**

**Each node represents a character.**

**Path from root to node spells a prefix.**

**Visual:**
```
Insert: "CAR", "CAT", "DOG", "DOOR"

        root
        / \
       C   D
       |   |
       A   O
      / \  |
     R   T O
           |
           R

Each path:
  rootâ†’Câ†’Aâ†’R = "CAR"
  rootâ†’Câ†’Aâ†’T = "CAT"
  rootâ†’Dâ†’Oâ†’G = "DOG"
  rootâ†’Dâ†’Oâ†’Oâ†’R = "DOOR"
```

### How Trie Works

**Node structure:**
```cpp
struct TrieNode {
    unordered_map<char, TrieNode*> children;
    bool isEndOfWord;
    
    TrieNode() : isEndOfWord(false) {}
};
```

**Why use map instead of array?**
```
Array: children[26] for 'a'-'z'
  âœ“ O(1) access
  âœ— Space: always 26 pointers per node
  
Map: only store existing children
  âœ“ Space: only used characters
  âœ— O(log k) access (k = # of children)
  
For sparse alphabets (Unicode), use map!
For dense alphabets (a-z), use array!
```

### Implementation

```cpp
class Trie {
    struct TrieNode {
        unordered_map<char, TrieNode*> children;
        bool isEndOfWord;
        
        TrieNode() : isEndOfWord(false) {}
    };
    
    TrieNode* root;
    
public:
    Trie() {
        root = new TrieNode();
    }
    
    void insert(string word) {
        TrieNode* node = root;
        
        for (char c : word) {
            if (node->children.find(c) == node->children.end()) {
                node->children[c] = new TrieNode();
            }
            node = node->children[c];
        }
        
        node->isEndOfWord = true;
    }
    
    bool search(string word) {
        TrieNode* node = root;
        
        for (char c : word) {
            if (node->children.find(c) == node->children.end()) {
                return false;
            }
            node = node->children[c];
        }
        
        return node->isEndOfWord;
    }
    
    bool startsWith(string prefix) {
        TrieNode* node = root;
        
        for (char c : prefix) {
            if (node->children.find(c) == node->children.end()) {
                return false;
            }
            node = node->children[c];
        }
        
        return true;
    }
};
```

### Complete Trace

```
Operations:
  insert("CAT")
  insert("CAR")
  insert("DOG")
  search("CAT")
  search("CAN")
  startsWith("CA")

Step-by-step:

insert("CAT"):
  Start at root
  'C' not in root.children, create node
  'A' not in C.children, create node
  'T' not in A.children, create node
  Mark T.isEndOfWord = true
  
  root â†’ C â†’ A â†’ T*
         
insert("CAR"):
  Start at root
  'C' exists in root.children
  'A' exists in C.children
  'R' not in A.children, create node
  Mark R.isEndOfWord = true
  
  root â†’ C â†’ A â†’ T*
              â†’ R*

insert("DOG"):
  Start at root
  'D' not in root.children, create node
  'O' not in D.children, create node
  'G' not in O.children, create node
  Mark G.isEndOfWord = true
  
  root â†’ C â†’ A â†’ T*
              â†’ R*
      â†’ D â†’ O â†’ G*

search("CAT"):
  root â†’ has 'C'
  C â†’ has 'A'
  A â†’ has 'T'
  T.isEndOfWord = true
  Return true âœ“

search("CAN"):
  root â†’ has 'C'
  C â†’ has 'A'
  A â†’ no 'N'
  Return false âœ“

startsWith("CA"):
  root â†’ has 'C'
  C â†’ has 'A'
  Prefix exists
  Return true âœ“
```

**Time:**
- Insert: O(m) where m = word length
- Search: O(m)
- StartsWith: O(m)

**Space:** O(ALPHABET_SIZE Ã— N Ã— M)  
where N = number of words, M = average length

---

## Trie: Prefix Queries

### Common Prefix Operations

**1. Count words with prefix**
```cpp
int countWordsWithPrefix(TrieNode* node, string prefix) {
    // Navigate to prefix
    for (char c : prefix) {
        if (node->children.find(c) == node->children.end()) {
            return 0;
        }
        node = node->children[c];
    }
    
    // Count all words in subtree
    return countWords(node);
}

int countWords(TrieNode* node) {
    int count = node->isEndOfWord ? 1 : 0;
    
    for (auto& [c, child] : node->children) {
        count += countWords(child);
    }
    
    return count;
}
```

**2. Longest common prefix**
```cpp
string longestCommonPrefix(vector<string>& words) {
    Trie trie;
    for (string& word : words) {
        trie.insert(word);
    }
    
    string lcp = "";
    TrieNode* node = trie.root;
    
    while (node->children.size() == 1 && !node->isEndOfWord) {
        auto it = node->children.begin();
        lcp += it->first;
        node = it->second;
    }
    
    return lcp;
}
```

**3. Autocomplete (find all words with prefix)**
```cpp
vector<string> autocomplete(string prefix) {
    TrieNode* node = root;
    
    // Navigate to prefix
    for (char c : prefix) {
        if (node->children.find(c) == node->children.end()) {
            return {};
        }
        node = node->children[c];
    }
    
    // DFS to find all words
    vector<string> results;
    dfs(node, prefix, results);
    return results;
}

void dfs(TrieNode* node, string current, vector<string>& results) {
    if (node->isEndOfWord) {
        results.push_back(current);
    }
    
    for (auto& [c, child] : node->children) {
        dfs(child, current + c, results);
    }
}
```

### Trie with Frequency

```cpp
class TrieWithFreq {
    struct TrieNode {
        unordered_map<char, TrieNode*> children;
        int frequency;
        
        TrieNode() : frequency(0) {}
    };
    
    TrieNode* root;
    
public:
    TrieWithFreq() {
        root = new TrieNode();
    }
    
    void insert(string word) {
        TrieNode* node = root;
        
        for (char c : word) {
            if (node->children.find(c) == node->children.end()) {
                node->children[c] = new TrieNode();
            }
            node = node->children[c];
        }
        
        node->frequency++;
    }
    
    int getFrequency(string word) {
        TrieNode* node = root;
        
        for (char c : word) {
            if (node->children.find(c) == node->children.end()) {
                return 0;
            }
            node = node->children[c];
        }
        
        return node->frequency;
    }
    
    // Find top k words with prefix
    vector<pair<string, int>> topKWithPrefix(string prefix, int k) {
        TrieNode* node = root;
        
        for (char c : prefix) {
            if (node->children.find(c) == node->children.end()) {
                return {};
            }
            node = node->children[c];
        }
        
        vector<pair<string, int>> allWords;
        dfs(node, prefix, allWords);
        
        sort(allWords.begin(), allWords.end(),
             [](auto& a, auto& b) { return a.second > b.second; });
        
        allWords.resize(min(k, (int)allWords.size()));
        return allWords;
    }
    
private:
    void dfs(TrieNode* node, string current, vector<pair<string, int>>& words) {
        if (node->frequency > 0) {
            words.push_back({current, node->frequency});
        }
        
        for (auto& [c, child] : node->children) {
            dfs(child, current + c, words);
        }
    }
};
```

---

## Manacher's Algorithm

### What is Manacher's?

**Find all palindromes in O(n) time.**

**Specifically:** Longest palindrome centered at each position.

### Key Insight

**Palindromes have symmetry!**

**If we know palindrome at position i, we can infer palindrome at mirror position.**

**Visual:**
```
String: A B A C A B A
         0 1 2 3 4 5 6

Center at 3 ('C'):
  Palindrome: "ABACABA" (radius 3)
  
  Position 2 mirrors to position 4
  Position 1 mirrors to position 5
  Position 0 mirrors to position 6
  
If we know palindrome at position 1,
we can infer palindrome at position 5!
```

### Handle Even-Length Palindromes

**Problem:** Even palindromes have no center character.

**Solution:** Insert separators!

**Transform:**
```
Original: ABBA
         
Add '#': #A#B#B#A#
         0 1 2 3 4 5 6 7 8

Now all palindromes are odd-length:
  "ABBA" becomes "#A#B#B#A#"
  Center at position 4 ('#')
  Radius 4
```

### Algorithm

```cpp
string longestPalindrome(string s) {
    // Transform string
    string t = "#";
    for (char c : s) {
        t += c;
        t += '#';
    }
    
    int n = t.size();
    vector<int> p(n, 0);  // p[i] = radius of palindrome centered at i
    
    int center = 0, right = 0;
    
    for (int i = 0; i < n; i++) {
        int mirror = 2 * center - i;
        
        if (i < right) {
            p[i] = min(right - i, p[mirror]);
        }
        
        // Expand around center
        while (i + p[i] + 1 < n && i - p[i] - 1 >= 0 &&
               t[i + p[i] + 1] == t[i - p[i] - 1]) {
            p[i]++;
        }
        
        // Update rightmost palindrome
        if (i + p[i] > right) {
            center = i;
            right = i + p[i];
        }
    }
    
    // Find longest palindrome
    int maxLen = 0, maxCenter = 0;
    for (int i = 0; i < n; i++) {
        if (p[i] > maxLen) {
            maxLen = p[i];
            maxCenter = i;
        }
    }
    
    // Extract original string
    int start = (maxCenter - maxLen) / 2;
    return s.substr(start, maxLen);
}
```

### Complete Trace

```
String: "BABAD"

Transform: "#B#A#B#A#D#"
Index:      0 1 2 3 4 5 6 7 8 9 10

Build p array:

i=0: '#'
  p[0] = 0 (can't expand)

i=1: 'B'
  Expand: t[0]='#' = t[2]='#'
  p[1] = 1

i=2: '#'
  Expand: t[1]='B' â‰  t[3]='A'
  p[2] = 0

i=3: 'A'
  i < right? No (first real expansion)
  Expand: t[2]='#' = t[4]='#'
          t[1]='B' = t[5]='B'
          t[0]='#' â‰  t[6]='#' (bounds)
  p[3] = 3
  Update: center=3, right=6

i=4: '#'
  mirror = 2Ã—3 - 4 = 2
  p[i] = min(right - i, p[mirror]) = min(2, 0) = 0
  Expand: t[3]='A' â‰  t[5]='B'
  p[4] = 0

i=5: 'B'
  mirror = 2Ã—3 - 5 = 1
  p[i] = min(right - i, p[mirror]) = min(1, 1) = 1
  Expand: t[4]='#' = t[6]='#'
          t[3]='A' = t[7]='A'
          t[2]='#' â‰  t[8]='#' (bounds)
  p[5] = 3
  Update: center=5, right=8

...continue

Final p: [0, 1, 0, 3, 0, 3, 0, 1, 0, 1, 0]

Max: p[3] = 3 or p[5] = 3
  p[3] = 3, center = 3
  Palindrome: t[0..6] = "#B#A#B#"
  Original: s[0..2] = "BAB"
  
  p[5] = 3, center = 5
  Palindrome: t[2..8] = "#A#B#A#"
  Original: s[1..3] = "ABA"

Return: "BAB" or "ABA" (both valid)
```

**Time:** O(n) - each position expanded at most once  
**Space:** O(n)

---

## Suffix Array Introduction

### What is Suffix Array?

**Array of all suffixes, sorted lexicographically.**

**Example:**
```
String: "BANANA"

Suffixes:
  0: BANANA
  1: ANANA
  2: NANA
  3: ANA
  4: NA
  5: A

Sorted:
  5: A
  3: ANA
  1: ANANA
  0: BANANA
  4: NA
  2: NANA

Suffix Array: [5, 3, 1, 0, 4, 2]
```

### Why Suffix Array?

**Applications:**
- Pattern matching
- Longest repeated substring
- Longest common substring
- Burrows-Wheeler Transform (compression)

**Advantage over suffix tree:**
- Simpler to implement
- Less space (O(n) vs O(n) but smaller constants)

### Naive Construction

```cpp
vector<int> buildSuffixArray(string s) {
    int n = s.size();
    vector<int> sa(n);
    
    iota(sa.begin(), sa.end(), 0);  // [0, 1, 2, ..., n-1]
    
    sort(sa.begin(), sa.end(), [&](int i, int j) {
        return s.substr(i) < s.substr(j);
    });
    
    return sa;
}
```

**Time:** O(nÂ² log n)  
**Space:** O(n)

### Efficient Construction (Overview)

**Prefix doubling:**
```
Sort suffixes by first 1 character
Then by first 2 characters
Then by first 4 characters
...
Then by first 2^k characters (k = log n)
```

**Key insight:**
```
Sorting by first 2k characters:
  = Sort by (first k chars, next k chars)
  
We already sorted by first k chars!
Use that ranking to sort by next k chars!
```

**Time:** O(n logÂ² n) or O(n log n) with optimizations

### Pattern Matching with Suffix Array

```cpp
int lcp(string& s, int i, int j) {
    int len = 0;
    while (i + len < s.size() && j + len < s.size() &&
           s[i + len] == s[j + len]) {
        len++;
    }
    return len;
}

vector<int> patternSearch(string text, string pattern, vector<int>& sa) {
    int n = text.size();
    int m = pattern.size();
    
    // Binary search for lower bound
    int left = 0, right = n;
    while (left < right) {
        int mid = (left + right) / 2;
        if (text.substr(sa[mid], m) < pattern) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    
    int start = left;
    
    // Binary search for upper bound
    left = 0; right = n;
    while (left < right) {
        int mid = (left + right) / 2;
        if (text.substr(sa[mid], m) <= pattern) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    
    int end = left;
    
    vector<int> matches;
    for (int i = start; i < end; i++) {
        matches.push_back(sa[i]);
    }
    
    return matches;
}
```

**Time:** O(m log n) for search (with binary search)

### LCP Array

**LCP[i] = longest common prefix of sa[i] and sa[i-1]**

```
String: "BANANA"
Suffix Array: [5, 3, 1, 0, 4, 2]

Suffixes in order:
  sa[0]=5: A
  sa[1]=3: ANA
  sa[2]=1: ANANA
  sa[3]=0: BANANA
  sa[4]=4: NA
  sa[5]=2: NANA

LCP:
  lcp[0] = 0 (no previous)
  lcp[1] = lcp("A", "ANA") = 1
  lcp[2] = lcp("ANA", "ANANA") = 3
  lcp[3] = lcp("ANANA", "BANANA") = 0
  lcp[4] = lcp("BANANA", "NA") = 0
  lcp[5] = lcp("NA", "NANA") = 2

LCP: [0, 1, 3, 0, 0, 2]
```

**LCP array enables:**
- Longest repeated substring: max(lcp)
- Number of distinct substrings: n(n+1)/2 - sum(lcp)

---

## Common Problems

### Problem 1: Implement strStr()

```cpp
int strStr(string haystack, string needle) {
    if (needle.empty()) return 0;
    
    vector<int> matches = KMP(haystack, needle);
    return matches.empty() ? -1 : matches[0];
}
```

### Problem 2: Repeated String Match

```cpp
int repeatedStringMatch(string a, string b) {
    string repeated = "";
    int count = 0;
    
    while (repeated.size() < b.size()) {
        repeated += a;
        count++;
    }
    
    if (repeated.find(b) != string::npos) return count;
    
    repeated += a;
    count++;
    
    if (repeated.find(b) != string::npos) return count;
    
    return -1;
}
```

### Problem 3: Longest Palindromic Substring

```cpp
string longestPalindrome(string s) {
    // Use Manacher's algorithm (shown above)
    // Or expand around center:
    
    string longest = "";
    
    for (int i = 0; i < s.size(); i++) {
        // Odd length
        string p1 = expandAroundCenter(s, i, i);
        if (p1.size() > longest.size()) longest = p1;
        
        // Even length
        string p2 = expandAroundCenter(s, i, i + 1);
        if (p2.size() > longest.size()) longest = p2;
    }
    
    return longest;
}

string expandAroundCenter(string& s, int left, int right) {
    while (left >= 0 && right < s.size() && s[left] == s[right]) {
        left--;
        right++;
    }
    return s.substr(left + 1, right - left - 1);
}
```

### Problem 4: Word Search II (Trie)

```cpp
class Solution {
    struct TrieNode {
        unordered_map<char, TrieNode*> children;
        string word;
    };
    
    TrieNode* buildTrie(vector<string>& words) {
        TrieNode* root = new TrieNode();
        
        for (string& word : words) {
            TrieNode* node = root;
            for (char c : word) {
                if (!node->children[c]) {
                    node->children[c] = new TrieNode();
                }
                node = node->children[c];
            }
            node->word = word;
        }
        
        return root;
    }
    
    void dfs(vector<vector<char>>& board, int i, int j,
             TrieNode* node, vector<string>& result) {
        char c = board[i][j];
        if (c == '#' || !node->children[c]) return;
        
        node = node->children[c];
        
        if (!node->word.empty()) {
            result.push_back(node->word);
            node->word = "";  // Avoid duplicates
        }
        
        board[i][j] = '#';
        
        if (i > 0) dfs(board, i - 1, j, node, result);
        if (i < board.size() - 1) dfs(board, i + 1, j, node, result);
        if (j > 0) dfs(board, i, j - 1, node, result);
        if (j < board[0].size() - 1) dfs(board, i, j + 1, node, result);
        
        board[i][j] = c;
    }
    
public:
    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {
        TrieNode* root = buildTrie(words);
        vector<string> result;
        
        for (int i = 0; i < board.size(); i++) {
            for (int j = 0; j < board[0].size(); j++) {
                dfs(board, i, j, root, result);
            }
        }
        
        return result;
    }
};
```

---

## Summary Tables

### Algorithm Comparison

| Algorithm | Preprocessing | Search | Space | Guaranteed O(n)? |
|-----------|---------------|--------|-------|------------------|
| **KMP** | O(m) | O(n) | O(m) | âœ“ Yes |
| **Z-Algorithm** | - | O(n+m) | O(n+m) | âœ“ Yes |
| **Rabin-Karp** | O(m) | O(n+m) avg | O(1) | âœ— Worst O(nm) |
| **Boyer-Moore** | O(m+Ïƒ) | O(n/m) avg | O(m+Ïƒ) | âœ— Worst O(nm) |

Ïƒ = alphabet size

### Data Structure Comparison

| Structure | Insert | Search | Prefix Query | Space |
|-----------|--------|--------|--------------|-------|
| **Trie** | O(m) | O(m) | O(m) | O(ALPHABETÃ—NÃ—M) |
| **Suffix Array** | O(n log n) | O(m log n) | - | O(n) |
| **Suffix Tree** | O(n) | O(m) | O(m) | O(n) |

### When to Use Each Algorithm

| Problem Type | Best Algorithm |
|--------------|----------------|
| **Single pattern search** | KMP or Z-Algorithm |
| **Multiple pattern search** | Trie or Rabin-Karp |
| **Prefix queries** | Trie |
| **All palindromes** | Manacher's |
| **Longest repeated substring** | Suffix Array |
| **Fuzzy matching** | Rabin-Karp (hash) |

---

## Practice Problems

### KMP
- [ ] Implement strStr()
- [ ] Shortest Palindrome
- [ ] Repeated Substring Pattern

### Z-Algorithm
- [ ] Count Palindromic Substrings
- [ ] Longest Happy Prefix
- [ ] Find All Patterns in String

### Rolling Hash
- [ ] Longest Duplicate Substring
- [ ] Repeated DNA Sequences
- [ ] Compare Strings by Frequency

### Trie
- [ ] Implement Trie (Prefix Tree)
- [ ] Word Search II
- [ ] Design Add and Search Words Data Structure
- [ ] Replace Words
- [ ] Map Sum Pairs

### Manacher's
- [ ] Longest Palindromic Substring
- [ ] Palindromic Substrings
- [ ] Shortest Palindrome

### Suffix Array
- [ ] Longest Repeated Substring
- [ ] Distinct Substrings
- [ ] Longest Common Substring

---

## Key Takeaways

1. **KMP uses failure function (LPS)** - Precompute pattern self-similarity
2. **LPS[i] = longest border of pattern[0..i]** - Prefix = suffix
3. **KMP never backtracks in text** - i only increases â†’ O(n)
4. **Z[i] = longest match with prefix starting at i** - Simpler than KMP
5. **Z-algorithm uses Z-box optimization** - Reuse previous Z values
6. **Pattern search with Z: concatenate pattern + "$" + text** - Find Z â‰¥ m
7. **Rolling hash: polynomial hash with modulo** - Slide window in O(1)
8. **Use double hashing to avoid collisions** - Two different (base, mod) pairs
9. **Always verify hash matches with string comparison** - Hash collision possible
10. **Trie: tree where paths spell strings** - Share common prefixes
11. **Trie insert/search: O(m)** - Follow path character by character
12. **Trie uses map for sparse, array for dense alphabet** - Space vs speed
13. **Manacher's finds all palindromes in O(n)** - Use symmetry
14. **Transform to handle even palindromes: insert '#'** - Make all odd-length
15. **Suffix array: sorted suffixes** - Binary search for pattern matching

Master these string algorithms and you'll handle any text processing problem efficiently! ðŸ”¤

