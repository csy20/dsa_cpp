# Linked List - Complete Guide

## Table of Contents
1. [Singly Linked List](#singly-linked-list)
2. [Doubly Linked List](#doubly-linked-list)
3. [Circular Linked List](#circular-linked-list)
4. [Reverse Operations](#reverse-operations)
5. [Finding Middle](#finding-middle)
6. [K-Reverse Operations](#k-reverse-operations)
7. [Cycle Detection (Floyd's Algorithm)](#cycle-detection-floyds-algorithm)
8. [Intersection Problems](#intersection-problems)
9. [Merge Operations](#merge-operations)
10. [Advanced Patterns](#advanced-patterns)

---

## Singly Linked List

### What is a Singly Linked List?

**Concept:** Linear data structure where each node contains data and pointer to next node.

**Structure:**
```
[data|next] â†’ [data|next] â†’ [data|next] â†’ NULL

Each box is a node:
- data: the value stored
- next: pointer to next node
```

**Visual:**
```
HEAD â†’ [1|â€¢] â†’ [2|â€¢] â†’ [3|â€¢] â†’ [4|NULL]
```

### Node Definition

```cpp
struct ListNode {
    int val;
    ListNode* next;
    
    ListNode(int x) : val(x), next(nullptr) {}
};
```

### Basic Operations

#### 1. Create & Insert at Head

```cpp
ListNode* insertAtHead(ListNode* head, int val) {
    ListNode* newNode = new ListNode(val);
    newNode->next = head;
    return newNode;  // New head
}
```

**Visual:**
```
Before: HEAD â†’ [1] â†’ [2] â†’ NULL
Insert 0 at head:
Step 1: Create [0]
Step 2: [0]->next = HEAD
Step 3: Return [0] as new HEAD

After: HEAD â†’ [0] â†’ [1] â†’ [2] â†’ NULL
```

#### 2. Insert at Tail

```cpp
ListNode* insertAtTail(ListNode* head, int val) {
    ListNode* newNode = new ListNode(val);
    
    if (!head) return newNode;
    
    ListNode* curr = head;
    while (curr->next) {
        curr = curr->next;
    }
    curr->next = newNode;
    
    return head;
}
```

**Time:** O(n), **Space:** O(1)

#### 3. Delete Node

```cpp
ListNode* deleteNode(ListNode* head, int val) {
    if (!head) return nullptr;
    
    // If head needs to be deleted
    if (head->val == val) {
        ListNode* temp = head->next;
        delete head;
        return temp;
    }
    
    ListNode* curr = head;
    while (curr->next && curr->next->val != val) {
        curr = curr->next;
    }
    
    if (curr->next) {
        ListNode* temp = curr->next;
        curr->next = curr->next->next;
        delete temp;
    }
    
    return head;
}
```

#### 4. Traverse & Print

```cpp
void printList(ListNode* head) {
    ListNode* curr = head;
    while (curr) {
        cout << curr->val;
        if (curr->next) cout << " â†’ ";
        curr = curr->next;
    }
    cout << " â†’ NULL\n";
}
```

#### 5. Search

```cpp
bool search(ListNode* head, int val) {
    ListNode* curr = head;
    while (curr) {
        if (curr->val == val) return true;
        curr = curr->next;
    }
    return false;
}
```

**Time:** O(n), **Space:** O(1)

### Advantages & Disadvantages

| Aspect | Advantage | Disadvantage |
|--------|-----------|--------------|
| Insertion | O(1) at head | O(n) at tail |
| Deletion | O(1) at head | O(n) to find |
| Access | - | O(n) no random access |
| Memory | Dynamic size | Extra pointer per node |
| Cache | - | Poor locality |

---

## Doubly Linked List

### What is a Doubly Linked List?

**Concept:** Each node has pointer to both next AND previous nodes.

**Structure:**
```
NULL â† [prev|data|next] â‡„ [prev|data|next] â‡„ [prev|data|next] â†’ NULL
```

**Visual:**
```
     â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”    â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”    â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
NULL â†â”‚ â€¢ â”‚ 1 â”‚ â€¢ â”‚â†â†’â”‚ â€¢ â”‚ 2 â”‚ â€¢ â”‚â†â†’â”‚ â€¢ â”‚ 3 â”‚ â€¢ â”‚â†’ NULL
     â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜    â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜    â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
      prev val next   prev val next   prev val next
```

### Node Definition

```cpp
struct DListNode {
    int val;
    DListNode* prev;
    DListNode* next;
    
    DListNode(int x) : val(x), prev(nullptr), next(nullptr) {}
};
```

### Operations

#### 1. Insert at Head

```cpp
DListNode* insertAtHead(DListNode* head, int val) {
    DListNode* newNode = new DListNode(val);
    
    if (head) {
        newNode->next = head;
        head->prev = newNode;
    }
    
    return newNode;
}
```

**Visual:**
```
Before: [1] â‡„ [2] â‡„ [3]

Insert 0:
Step 1: Create [0]
Step 2: [0]->next = [1]
Step 3: [1]->prev = [0]

After: [0] â‡„ [1] â‡„ [2] â‡„ [3]
```

#### 2. Delete Node (Given Node Pointer)

```cpp
void deleteNode(DListNode* node) {
    // Connect previous node to next node
    if (node->prev) {
        node->prev->next = node->next;
    }
    
    // Connect next node to previous node
    if (node->next) {
        node->next->prev = node->prev;
    }
    
    delete node;
}
```

**Advantage:** O(1) deletion when given node pointer (don't need to find previous)!

#### 3. Traverse Forward & Backward

```cpp
void traverseForward(DListNode* head) {
    while (head) {
        cout << head->val << " ";
        head = head->next;
    }
    cout << "\n";
}

void traverseBackward(DListNode* tail) {
    while (tail) {
        cout << tail->val << " ";
        tail = tail->prev;
    }
    cout << "\n";
}
```

### Use Cases

âœ… **Browser history** (back/forward buttons)  
âœ… **LRU Cache** (need to move nodes to front)  
âœ… **Music player** (next/previous song)  
âœ… **Undo/Redo** (navigate both directions)

---

## Circular Linked List

### What is a Circular Linked List?

**Concept:** Last node points back to first node (no NULL termination).

**Singly Circular:**
```
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â†“                     â”‚
   [1] â†’ [2] â†’ [3] â†’ [4] â”€â”€â”˜
```

**Doubly Circular:**
```
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â†“                          â”‚
   [1] â‡„ [2] â‡„ [3] â‡„ [4] â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚                          â†‘
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Operations

#### 1. Create Circular List

```cpp
ListNode* createCircular(vector<int>& arr) {
    if (arr.empty()) return nullptr;
    
    ListNode* head = new ListNode(arr[0]);
    ListNode* curr = head;
    
    for (int i = 1; i < arr.size(); i++) {
        curr->next = new ListNode(arr[i]);
        curr = curr->next;
    }
    
    curr->next = head;  // Make circular!
    return head;
}
```

#### 2. Traverse Circular List

```cpp
void traverseCircular(ListNode* head) {
    if (!head) return;
    
    ListNode* curr = head;
    do {
        cout << curr->val << " ";
        curr = curr->next;
    } while (curr != head);  // Stop when back to head
    cout << "\n";
}
```

**Important:** Use `do-while` to ensure we process head at least once!

#### 3. Insert in Circular List

```cpp
ListNode* insertCircular(ListNode* head, int val) {
    ListNode* newNode = new ListNode(val);
    
    if (!head) {
        newNode->next = newNode;  // Points to itself
        return newNode;
    }
    
    // Find last node
    ListNode* curr = head;
    while (curr->next != head) {
        curr = curr->next;
    }
    
    // Insert at end
    newNode->next = head;
    curr->next = newNode;
    
    return head;
}
```

### Use Cases

âœ… **Round-robin scheduling**  
âœ… **Multiplayer games** (turn-based)  
âœ… **Circular buffer**  
âœ… **Music playlist** (repeat mode)

---

## Reverse Operations

### Pattern 1: Reverse Entire List (Iterative)

**Problem:** Reverse a singly linked list.

**How it works:** Use 3 pointers to reverse links one by one.

```cpp
ListNode* reverseList(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* curr = head;
    
    while (curr) {
        ListNode* nextNode = curr->next;  // Save next
        curr->next = prev;                 // Reverse link
        prev = curr;                       // Move prev
        curr = nextNode;                   // Move curr
    }
    
    return prev;  // New head
}
```

**Detailed trace:**
```
Initial: NULL â† prev  curr â†’ [1] â†’ [2] â†’ [3] â†’ NULL

Step 1: Save next = [2]
        [1]->next = NULL
        prev = [1], curr = [2]
        NULL â† [1]  prev  curr â†’ [2] â†’ [3] â†’ NULL

Step 2: Save next = [3]
        [2]->next = [1]
        prev = [2], curr = [3]
        NULL â† [1] â† [2]  prev  curr â†’ [3] â†’ NULL

Step 3: Save next = NULL
        [3]->next = [2]
        prev = [3], curr = NULL
        NULL â† [1] â† [2] â† [3]  prev  curr

Return prev = [3]
Result: [3] â†’ [2] â†’ [1] â†’ NULL
```

**Time:** O(n), **Space:** O(1)

### Pattern 2: Reverse Entire List (Recursive)

**How it works:** Recursively reverse rest of list, then fix current node.

```cpp
ListNode* reverseListRecursive(ListNode* head) {
    // Base case
    if (!head || !head->next) {
        return head;
    }
    
    // Reverse rest of list
    ListNode* newHead = reverseListRecursive(head->next);
    
    // Fix current node
    head->next->next = head;  // Next node points back to current
    head->next = nullptr;     // Current becomes tail
    
    return newHead;
}
```

**Detailed trace:**
```
Input: [1] â†’ [2] â†’ [3] â†’ NULL

Call stack:
reverse([1] â†’ [2] â†’ [3])
  â†’ reverse([2] â†’ [3])
      â†’ reverse([3])
          Returns [3] (base case)
      [2]->next->next = [2]  (i.e., [3]->next = [2])
      [2]->next = NULL
      Returns [3]
  [1]->next->next = [1]  (i.e., [2]->next = [1])
  [1]->next = NULL
  Returns [3]

Visual:
[1] â†’ [2] â†’ [3] â†’ NULL

After reverse([3]): [3] â†’ NULL

After reverse([2]):
[3] â†’ [2] â†’ NULL
      â†“
     [3] (old link removed)

After reverse([1]):
[3] â†’ [2] â†’ [1] â†’ NULL
```

**Time:** O(n), **Space:** O(n) stack

### Pattern 3: Reverse Between Positions

**Problem:** Reverse sublist from position left to right.

```cpp
ListNode* reverseBetween(ListNode* head, int left, int right) {
    if (left == right) return head;
    
    ListNode dummy(0);
    dummy.next = head;
    ListNode* prev = &dummy;
    
    // Move to node before left
    for (int i = 1; i < left; i++) {
        prev = prev->next;
    }
    
    // Reverse from left to right
    ListNode* curr = prev->next;
    for (int i = 0; i < right - left; i++) {
        ListNode* temp = curr->next;
        curr->next = temp->next;
        temp->next = prev->next;
        prev->next = temp;
    }
    
    return dummy.next;
}
```

**Trace:**
```
Input: [1] â†’ [2] â†’ [3] â†’ [4] â†’ [5], left=2, right=4

Initial: dummy â†’ [1] â†’ [2] â†’ [3] â†’ [4] â†’ [5]
         prev points to [1]
         curr points to [2]

Iteration 1: Reverse [2] and [3]
  temp = [3]
  [2]->next = [4]
  [3]->next = [2]
  prev->next = [3]
  Result: [1] â†’ [3] â†’ [2] â†’ [4] â†’ [5]

Iteration 2: Reverse [2] and [4]
  temp = [4]
  [2]->next = [5]
  [4]->next = [3]
  prev->next = [4]
  Result: [1] â†’ [4] â†’ [3] â†’ [2] â†’ [5]

Final: [1] â†’ [4] â†’ [3] â†’ [2] â†’ [5]
```

**Time:** O(n), **Space:** O(1)

---

## Finding Middle

### Pattern 1: Two-Pass Approach

```cpp
ListNode* findMiddle(ListNode* head) {
    // Count length
    int length = 0;
    ListNode* curr = head;
    while (curr) {
        length++;
        curr = curr->next;
    }
    
    // Go to middle
    curr = head;
    for (int i = 0; i < length / 2; i++) {
        curr = curr->next;
    }
    
    return curr;
}
```

**Time:** O(n), **Space:** O(1)

### Pattern 2: Slow-Fast Pointers (Floyd's Tortoise & Hare)

**How it works:**
- Slow pointer moves 1 step at a time
- Fast pointer moves 2 steps at a time
- When fast reaches end, slow is at middle!

```cpp
ListNode* findMiddle(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;
    
    while (fast && fast->next) {
        slow = slow->next;        // 1 step
        fast = fast->next->next;  // 2 steps
    }
    
    return slow;  // Middle node
}
```

**Detailed trace:**
```
List: [1] â†’ [2] â†’ [3] â†’ [4] â†’ [5] â†’ NULL

Initial:
slow â†’ [1]
fast â†’ [1]

Step 1:
slow â†’ [2]  (moved 1)
fast â†’ [3]  (moved 2)

Step 2:
slow â†’ [3]  (moved 1)
fast â†’ [5]  (moved 2)

Step 3:
slow â†’ [4]  (moved 1)
fast â†’ NULL (moved 2, reached end)

Loop stops, return slow = [4]... wait, that's wrong!

Actually for odd length:
Step 1: slow=[2], fast=[3]
Step 2: slow=[3], fast=[5]
Step 3: fast->next=NULL, loop stops
Return slow = [3] âœ“ (correct middle)
```

**Visual explanation:**
```
Odd length [1,2,3,4,5]:
S F
â†“ â†“
1 2 3 4 5 â†’ S moves to 2, F moves to 3
  S   F
  2   3 4 5 â†’ S moves to 3, F moves to 5
    S     F
    3     5 â†’ F->next is NULL, stop
Middle = 3 âœ“

Even length [1,2,3,4]:
S F
1 2 3 4 â†’ S moves to 2, F moves to 3
  S   F
  2   3 4 â†’ S moves to 3, F moves to NULL
    S   F
Middle = 3 (second of two middles)
```

**Time:** O(n), **Space:** O(1)

### Pattern 3: Delete Middle Node

```cpp
ListNode* deleteMiddle(ListNode* head) {
    if (!head || !head->next) return nullptr;
    
    ListNode* slow = head;
    ListNode* fast = head;
    ListNode* prev = nullptr;
    
    while (fast && fast->next) {
        prev = slow;
        slow = slow->next;
        fast = fast->next->next;
    }
    
    // slow is middle, prev is before middle
    prev->next = slow->next;
    delete slow;
    
    return head;
}
```

**Time:** O(n), **Space:** O(1)

---

## K-Reverse Operations

### Pattern 1: Reverse in Groups of K

**Problem:** Reverse nodes in k-group.

**Example:** `[1,2,3,4,5], k=2` â†’ `[2,1,4,3,5]`

```cpp
ListNode* reverseKGroup(ListNode* head, int k) {
    // Count nodes
    int count = 0;
    ListNode* curr = head;
    while (curr) {
        count++;
        curr = curr->next;
    }
    
    ListNode dummy(0);
    dummy.next = head;
    ListNode* prev = &dummy;
    
    while (count >= k) {
        curr = prev->next;
        
        // Reverse k nodes
        for (int i = 1; i < k; i++) {
            ListNode* temp = curr->next;
            curr->next = temp->next;
            temp->next = prev->next;
            prev->next = temp;
        }
        
        prev = curr;
        count -= k;
    }
    
    return dummy.next;
}
```

**Detailed trace:**
```
Input: [1] â†’ [2] â†’ [3] â†’ [4] â†’ [5], k = 2

Initial: dummy â†’ [1] â†’ [2] â†’ [3] â†’ [4] â†’ [5]
         prev = dummy
         curr = [1]

First group (reverse [1,2]):
  i=1:
    temp = [2]
    [1]->next = [3]
    [2]->next = [1]
    prev->next = [2]
    Result: dummy â†’ [2] â†’ [1] â†’ [3] â†’ [4] â†’ [5]

  prev = [1]
  curr = [1]

Second group (reverse [3,4]):
  i=1:
    temp = [4]
    [3]->next = [5]
    [4]->next = [3]
    prev->next = [4]
    Result: [2] â†’ [1] â†’ [4] â†’ [3] â†’ [5]

  prev = [3]
  count = 1 < k, stop

Final: [2] â†’ [1] â†’ [4] â†’ [3] â†’ [5]
```

**Time:** O(n), **Space:** O(1)

### Pattern 2: Reverse Alternate K Nodes

**Problem:** Reverse first k, skip next k, repeat.

```cpp
ListNode* reverseAlternateK(ListNode* head, int k) {
    ListNode* curr = head;
    ListNode* prev = nullptr;
    ListNode* next = nullptr;
    int count = 0;
    
    // Reverse first k nodes
    while (curr && count < k) {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
        count++;
    }
    
    // head now points to k-th node
    if (head) {
        head->next = curr;  // Connect to remaining
    }
    
    // Skip next k nodes
    count = 0;
    while (curr && count < k - 1) {
        curr = curr->next;
        count++;
    }
    
    // Recursively reverse next k
    if (curr) {
        curr->next = reverseAlternateK(curr->next, k);
    }
    
    return prev;
}
```

**Example:** `[1,2,3,4,5,6,7,8], k=2`
- Reverse [1,2] â†’ [2,1]
- Skip [3,4]
- Reverse [5,6] â†’ [6,5]
- Skip [7,8]
- Result: `[2,1,3,4,6,5,7,8]`

**Time:** O(n), **Space:** O(n/k) recursion

### Pattern 3: Reverse Every K Nodes (Simple Recursion)

```cpp
ListNode* reverseKNodes(ListNode* head, int k) {
    ListNode* curr = head;
    ListNode* prev = nullptr;
    ListNode* next = nullptr;
    int count = 0;
    
    // Reverse k nodes
    while (curr && count < k) {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
        count++;
    }
    
    // If more nodes exist, recursively reverse them
    if (next) {
        head->next = reverseKNodes(next, k);
    }
    
    return prev;
}
```

**Time:** O(n), **Space:** O(n/k)

---

## Cycle Detection (Floyd's Algorithm)

### What is a Cycle?

**Cycle:** When a node's next pointer points back to a previous node.

**Visual:**
```
[1] â†’ [2] â†’ [3] â†’ [4]
            â†‘     â†“
            [6] â† [5]
            
Node 6 points back to node 3, forming a cycle!
```

### Pattern 1: Detect Cycle (Floyd's Cycle Detection)

**How it works:**
- Use slow (1 step) and fast (2 steps) pointers
- If there's a cycle, fast will eventually catch slow
- If no cycle, fast reaches NULL

**Why it works:**
- In a cycle, fast gains 1 step on slow per iteration
- Eventually fast will be right behind slow, then catch it!

```cpp
bool hasCycle(ListNode* head) {
    if (!head || !head->next) return false;
    
    ListNode* slow = head;
    ListNode* fast = head;
    
    while (fast && fast->next) {
        slow = slow->next;        // 1 step
        fast = fast->next->next;  // 2 steps
        
        if (slow == fast) {
            return true;  // Cycle detected!
        }
    }
    
    return false;  // No cycle
}
```

**Detailed trace:**
```
List: [1] â†’ [2] â†’ [3] â†’ [4]
                  â†‘     â†“
                  [6] â† [5]

Step 0: slow=[1], fast=[1]
Step 1: slow=[2], fast=[3]
Step 2: slow=[3], fast=[5]
Step 3: slow=[4], fast=[3]
Step 4: slow=[5], fast=[5] â†’ MATCH! Cycle detected âœ“

Why they meet:
- Once both in cycle, fast gains 1 position per step
- If slow at position 0, fast at position k
- After (cycle_length - k) steps, they meet!
```

**Time:** O(n), **Space:** O(1)

### Pattern 2: Find Cycle Start Node

**How it works:**
1. Detect cycle (fast meets slow)
2. Move slow back to head
3. Move both slow and fast 1 step at a time
4. Where they meet is the cycle start!

**Why it works:**
- Distance from head to cycle start = distance from meeting point to cycle start
- Mathematical proof using cycle length and meeting point!

```cpp
ListNode* detectCycle(ListNode* head) {
    if (!head || !head->next) return nullptr;
    
    ListNode* slow = head;
    ListNode* fast = head;
    
    // Phase 1: Detect cycle
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        
        if (slow == fast) {
            // Phase 2: Find start
            slow = head;
            while (slow != fast) {
                slow = slow->next;
                fast = fast->next;
            }
            return slow;  // Cycle start
        }
    }
    
    return nullptr;  // No cycle
}
```

**Mathematical proof:**
```
Let:
- L = distance from head to cycle start
- C = cycle length
- k = distance from cycle start to meeting point

When they meet:
- slow traveled: L + k
- fast traveled: L + k + nC (n complete cycles)
- fast = 2 * slow: L + k + nC = 2(L + k)
- Simplify: L = nC - k

So distance from head to start (L) equals
distance from meeting point to start (nC - k)!

Visual:
HEAD --L--> START --k--> MEET
            â†‘              â†“
            â””-----nC-k-----â”˜

Moving both from HEAD and MEET by 1 step,
they meet at START!
```

**Trace:**
```
List: [1] â†’ [2] â†’ [3] â†’ [4]
                  â†‘     â†“
                  [6] â† [5]
Cycle starts at [3]

Phase 1 - Detect:
  (assume they meet at [5])

Phase 2 - Find start:
  slow = HEAD = [1]
  fast = MEET = [5]
  
  Step 1: slow=[2], fast=[6]
  Step 2: slow=[3], fast=[3] â†’ MATCH!
  
Return [3] (cycle start) âœ“
```

**Time:** O(n), **Space:** O(1)

### Pattern 3: Find Cycle Length

```cpp
int cycleLength(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;
    
    // Detect cycle
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        
        if (slow == fast) {
            // Count cycle length
            int length = 1;
            fast = fast->next;
            while (slow != fast) {
                fast = fast->next;
                length++;
            }
            return length;
        }
    }
    
    return 0;  // No cycle
}
```

**Time:** O(n), **Space:** O(1)

### Pattern 4: Remove Cycle

```cpp
void removeCycle(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;
    
    // Detect cycle
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        
        if (slow == fast) break;
    }
    
    if (!fast || !fast->next) return;  // No cycle
    
    // Find cycle start
    slow = head;
    while (slow != fast) {
        slow = slow->next;
        fast = fast->next;
    }
    
    // Find node before cycle start
    while (fast->next != slow) {
        fast = fast->next;
    }
    
    fast->next = nullptr;  // Break cycle
}
```

**Time:** O(n), **Space:** O(1)

---

## Intersection Problems

### Pattern 1: Intersection of Two Lists

**Problem:** Find node where two lists intersect.

**Visual:**
```
List A: [1] â†’ [2] â†˜
                   [7] â†’ [8] â†’ [9]
List B: [3] â†’ [4] â†—

Intersection at [7]
```

**How it works:**
- Calculate length of both lists
- Advance longer list by difference
- Move both until they meet

```cpp
ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {
    if (!headA || !headB) return nullptr;
    
    // Calculate lengths
    int lenA = 0, lenB = 0;
    ListNode* currA = headA;
    ListNode* currB = headB;
    
    while (currA) {
        lenA++;
        currA = currA->next;
    }
    
    while (currB) {
        lenB++;
        currB = currB->next;
    }
    
    // Align starting points
    currA = headA;
    currB = headB;
    
    while (lenA > lenB) {
        currA = currA->next;
        lenA--;
    }
    
    while (lenB > lenA) {
        currB = currB->next;
        lenB--;
    }
    
    // Find intersection
    while (currA != currB) {
        currA = currA->next;
        currB = currB->next;
    }
    
    return currA;  // Intersection or nullptr
}
```

**Trace:**
```
List A: [1] â†’ [2] â†’ [7] â†’ [8] â†’ NULL  (length 4)
List B: [3] â†’ [7] â†’ [8] â†’ NULL        (length 3)

lenA = 4, lenB = 3
Advance A by 1: currA = [2]

Now both have 3 nodes remaining:
A: [2] â†’ [7] â†’ [8]
B: [3] â†’ [7] â†’ [8]

Step 1: currA=[2], currB=[3], not equal
Step 2: currA=[7], currB=[7], MATCH!

Return [7]
```

**Time:** O(m + n), **Space:** O(1)

### Pattern 2: Intersection (Two-Pointer Trick)

**Clever approach:** Switch pointers when reaching end!

```cpp
ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {
    if (!headA || !headB) return nullptr;
    
    ListNode* pA = headA;
    ListNode* pB = headB;
    
    while (pA != pB) {
        pA = pA ? pA->next : headB;  // Switch to B when A ends
        pB = pB ? pB->next : headA;  // Switch to A when B ends
    }
    
    return pA;  // Intersection or nullptr
}
```

**How it works:**
```
List A: a1 â†’ a2 â†’ c1 â†’ c2 â†’ c3
List B: b1 â†’ b2 â†’ b3 â†’ c1 â†’ c2 â†’ c3

Pointer A path: a1 â†’ a2 â†’ c1 â†’ c2 â†’ c3 â†’ b1 â†’ b2 â†’ b3 â†’ c1
Pointer B path: b1 â†’ b2 â†’ b3 â†’ c1 â†’ c2 â†’ c3 â†’ a1 â†’ a2 â†’ c1

Both travel same total distance!
Total = (a_unique + b_unique + common)

They meet at c1 (intersection)!
```

**If no intersection:**
```
List A: a1 â†’ a2 â†’ NULL
List B: b1 â†’ b2 â†’ b3 â†’ NULL

pA: a1 â†’ a2 â†’ NULL â†’ b1 â†’ b2 â†’ b3 â†’ NULL
pB: b1 â†’ b2 â†’ b3 â†’ NULL â†’ a1 â†’ a2 â†’ NULL

Both reach NULL at same time â†’ pA == pB == NULL
```

**Time:** O(m + n), **Space:** O(1)

### Pattern 3: Intersection with Cycles

**Complex case:** Lists may have cycles!

```cpp
ListNode* getIntersectionWithCycle(ListNode* headA, ListNode* headB) {
    ListNode* cycleA = detectCycle(headA);
    ListNode* cycleB = detectCycle(headB);
    
    // Case 1: No cycles in either list
    if (!cycleA && !cycleB) {
        return getIntersectionNode(headA, headB);
    }
    
    // Case 2: One has cycle, other doesn't â†’ no intersection
    if (!cycleA || !cycleB) {
        return nullptr;
    }
    
    // Case 3: Both have cycles
    // If cycles start at same node, intersection before or at cycle
    if (cycleA == cycleB) {
        return getIntersectionNode(headA, headB);
    }
    
    // Check if cycles are same (shared cycle)
    ListNode* curr = cycleA->next;
    while (curr != cycleA) {
        if (curr == cycleB) {
            return cycleA;  // Or cycleB, same cycle
        }
        curr = curr->next;
    }
    
    return nullptr;  // Different cycles
}
```

**Time:** O(m + n), **Space:** O(1)

---

## Merge Operations

### Pattern 1: Merge Two Sorted Lists

**Problem:** Merge two sorted lists into one sorted list.

```cpp
ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
    ListNode dummy(0);
    ListNode* tail = &dummy;
    
    while (l1 && l2) {
        if (l1->val <= l2->val) {
            tail->next = l1;
            l1 = l1->next;
        } else {
            tail->next = l2;
            l2 = l2->next;
        }
        tail = tail->next;
    }
    
    // Attach remaining nodes
    tail->next = l1 ? l1 : l2;
    
    return dummy.next;
}
```

**Trace:**
```
l1: [1] â†’ [3] â†’ [5]
l2: [2] â†’ [4] â†’ [6]

dummy â†’ ?

Step 1: 1 < 2, attach [1]
  dummy â†’ [1], l1=[3], l2=[2]

Step 2: 3 > 2, attach [2]
  dummy â†’ [1] â†’ [2], l1=[3], l2=[4]

Step 3: 3 < 4, attach [3]
  dummy â†’ [1] â†’ [2] â†’ [3], l1=[5], l2=[4]

Step 4: 5 > 4, attach [4]
  dummy â†’ [1] â†’ [2] â†’ [3] â†’ [4], l1=[5], l2=[6]

Step 5: 5 < 6, attach [5]
  dummy â†’ [1] â†’ [2] â†’ [3] â†’ [4] â†’ [5], l1=NULL, l2=[6]

Step 6: l1=NULL, attach remaining l2
  dummy â†’ [1] â†’ [2] â†’ [3] â†’ [4] â†’ [5] â†’ [6]

Result: [1] â†’ [2] â†’ [3] â†’ [4] â†’ [5] â†’ [6]
```

**Time:** O(m + n), **Space:** O(1)

### Pattern 2: Merge K Sorted Lists

**Approach 1: Divide & Conquer**

```cpp
ListNode* mergeKLists(vector<ListNode*>& lists) {
    if (lists.empty()) return nullptr;
    
    while (lists.size() > 1) {
        vector<ListNode*> merged;
        
        for (int i = 0; i < lists.size(); i += 2) {
            ListNode* l1 = lists[i];
            ListNode* l2 = (i + 1 < lists.size()) ? lists[i + 1] : nullptr;
            merged.push_back(mergeTwoLists(l1, l2));
        }
        
        lists = merged;
    }
    
    return lists[0];
}
```

**Visual:**
```
k=4 lists: [L1, L2, L3, L4]

Round 1: Merge pairs
  L1 + L2 â†’ M1
  L3 + L4 â†’ M2
  lists = [M1, M2]

Round 2: Merge pairs
  M1 + M2 â†’ Final
  lists = [Final]

Return Final

Time: O(N log k) where N = total nodes, k = number of lists
```

**Approach 2: Priority Queue (Min Heap)**

```cpp
ListNode* mergeKLists(vector<ListNode*>& lists) {
    auto cmp = [](ListNode* a, ListNode* b) {
        return a->val > b->val;  // Min heap
    };
    priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> pq(cmp);
    
    // Add first node of each list
    for (ListNode* head : lists) {
        if (head) pq.push(head);
    }
    
    ListNode dummy(0);
    ListNode* tail = &dummy;
    
    while (!pq.empty()) {
        ListNode* node = pq.top();
        pq.pop();
        
        tail->next = node;
        tail = tail->next;
        
        if (node->next) {
            pq.push(node->next);
        }
    }
    
    return dummy.next;
}
```

**Time:** O(N log k), **Space:** O(k)

### Pattern 3: Merge Lists Alternately

**Problem:** Take nodes alternately from two lists.

```cpp
ListNode* mergeAlternately(ListNode* l1, ListNode* l2) {
    if (!l1) return l2;
    if (!l2) return l1;
    
    ListNode dummy(0);
    ListNode* tail = &dummy;
    bool useL1 = true;
    
    while (l1 && l2) {
        if (useL1) {
            tail->next = l1;
            l1 = l1->next;
        } else {
            tail->next = l2;
            l2 = l2->next;
        }
        tail = tail->next;
        useL1 = !useL1;
    }
    
    tail->next = l1 ? l1 : l2;
    
    return dummy.next;
}
```

**Example:**
```
l1: [1] â†’ [3] â†’ [5]
l2: [2] â†’ [4] â†’ [6]

Result: [1] â†’ [2] â†’ [3] â†’ [4] â†’ [5] â†’ [6]
```

**Time:** O(m + n), **Space:** O(1)

---

## Advanced Patterns

### Pattern 1: Palindrome Linked List

**Approach:** Find middle, reverse second half, compare.

```cpp
bool isPalindrome(ListNode* head) {
    if (!head || !head->next) return true;
    
    // Find middle
    ListNode* slow = head;
    ListNode* fast = head;
    while (fast->next && fast->next->next) {
        slow = slow->next;
        fast = fast->next->next;
    }
    
    // Reverse second half
    ListNode* secondHalf = reverseList(slow->next);
    
    // Compare
    ListNode* p1 = head;
    ListNode* p2 = secondHalf;
    bool result = true;
    
    while (p2) {
        if (p1->val != p2->val) {
            result = false;
            break;
        }
        p1 = p1->next;
        p2 = p2->next;
    }
    
    // Restore list (optional)
    slow->next = reverseList(secondHalf);
    
    return result;
}
```

**Time:** O(n), **Space:** O(1)

### Pattern 2: Reorder List

**Problem:** L0 â†’ L1 â†’ ... â†’ Ln-1 â†’ Ln becomes L0 â†’ Ln â†’ L1 â†’ Ln-1 â†’ ...

```cpp
void reorderList(ListNode* head) {
    if (!head || !head->next) return;
    
    // Find middle
    ListNode* slow = head;
    ListNode* fast = head;
    while (fast->next && fast->next->next) {
        slow = slow->next;
        fast = fast->next->next;
    }
    
    // Reverse second half
    ListNode* second = reverseList(slow->next);
    slow->next = nullptr;
    
    // Merge alternately
    ListNode* first = head;
    while (second) {
        ListNode* temp1 = first->next;
        ListNode* temp2 = second->next;
        
        first->next = second;
        second->next = temp1;
        
        first = temp1;
        second = temp2;
    }
}
```

**Trace:**
```
Input: [1] â†’ [2] â†’ [3] â†’ [4] â†’ [5]

Step 1: Find middle
  middle = [3]

Step 2: Split and reverse second half
  first = [1] â†’ [2] â†’ [3]
  second = [5] â†’ [4]

Step 3: Merge alternately
  [1] â†’ [5] â†’ [2] â†’ [4] â†’ [3]

Result: [1] â†’ [5] â†’ [2] â†’ [4] â†’ [3]
```

**Time:** O(n), **Space:** O(1)

### Pattern 3: Add Two Numbers

**Problem:** Numbers stored in reverse (least significant first).

```cpp
ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    ListNode dummy(0);
    ListNode* tail = &dummy;
    int carry = 0;
    
    while (l1 || l2 || carry) {
        int sum = carry;
        
        if (l1) {
            sum += l1->val;
            l1 = l1->next;
        }
        
        if (l2) {
            sum += l2->val;
            l2 = l2->next;
        }
        
        carry = sum / 10;
        tail->next = new ListNode(sum % 10);
        tail = tail->next;
    }
    
    return dummy.next;
}
```

**Trace:**
```
l1: [2] â†’ [4] â†’ [3]  (represents 342)
l2: [5] â†’ [6] â†’ [4]  (represents 465)

Step 1: 2 + 5 = 7, carry=0 â†’ [7]
Step 2: 4 + 6 = 10, carry=1 â†’ [7] â†’ [0]
Step 3: 3 + 4 + 1 = 8, carry=0 â†’ [7] â†’ [0] â†’ [8]

Result: [7] â†’ [0] â†’ [8] (represents 807)
342 + 465 = 807 âœ“
```

**Time:** O(max(m, n)), **Space:** O(max(m, n))

### Pattern 4: Copy List with Random Pointer

**Problem:** Clone list where each node has next and random pointer.

```cpp
struct Node {
    int val;
    Node* next;
    Node* random;
    Node(int x) : val(x), next(nullptr), random(nullptr) {}
};

Node* copyRandomList(Node* head) {
    if (!head) return nullptr;
    
    // Step 1: Create copy nodes interleaved
    Node* curr = head;
    while (curr) {
        Node* copy = new Node(curr->val);
        copy->next = curr->next;
        curr->next = copy;
        curr = copy->next;
    }
    
    // Step 2: Set random pointers
    curr = head;
    while (curr) {
        if (curr->random) {
            curr->next->random = curr->random->next;
        }
        curr = curr->next->next;
    }
    
    // Step 3: Separate lists
    Node* dummy = new Node(0);
    Node* tail = dummy;
    curr = head;
    
    while (curr) {
        tail->next = curr->next;
        tail = tail->next;
        curr->next = curr->next->next;
        curr = curr->next;
    }
    
    return dummy->next;
}
```

**Visual:**
```
Original: [1] â†’ [2] â†’ [3]
          â†“     â†“     â†“
          [3]   [1]   [2]  (random pointers)

Step 1: Interleave copies
  [1] â†’ [1'] â†’ [2] â†’ [2'] â†’ [3] â†’ [3']

Step 2: Set random pointers for copies
  [1']->random = [1]->random->next = [3']
  [2']->random = [1']
  [3']->random = [2']

Step 3: Separate
  Original: [1] â†’ [2] â†’ [3]
  Copy: [1'] â†’ [2'] â†’ [3']
```

**Time:** O(n), **Space:** O(1)

### Pattern 5: Flatten Multilevel Doubly Linked List

**Problem:** Flatten list where nodes can have child pointer.

```cpp
Node* flatten(Node* head) {
    if (!head) return nullptr;
    
    Node* curr = head;
    
    while (curr) {
        if (curr->child) {
            // Save next
            Node* next = curr->next;
            
            // Flatten child
            Node* child = flatten(curr->child);
            
            // Connect curr to child
            curr->next = child;
            child->prev = curr;
            curr->child = nullptr;
            
            // Find end of child list
            while (curr->next) {
                curr = curr->next;
            }
            
            // Connect to next
            if (next) {
                curr->next = next;
                next->prev = curr;
            }
        }
        
        curr = curr->next;
    }
    
    return head;
}
```

**Time:** O(n), **Space:** O(1) iterative, O(depth) recursive

---

## Summary Tables

### List Type Comparison

| Type | Next | Prev | Lastâ†’First | Use Case |
|------|------|------|------------|----------|
| Singly | âœ“ | âœ— | âœ— | Simple, memory efficient |
| Doubly | âœ“ | âœ“ | âœ— | Bidirectional traversal |
| Circular | âœ“ | âœ— | âœ“ | Round-robin, playlists |
| Doubly Circular | âœ“ | âœ“ | âœ“ | Complex navigation |

### Common Pattern Complexities

| Pattern | Time | Space | Key Technique |
|---------|------|-------|---------------|
| Reverse | O(n) | O(1) | 3 pointers |
| Find Middle | O(n) | O(1) | Slow-fast pointers |
| Detect Cycle | O(n) | O(1) | Floyd's algorithm |
| Find Intersection | O(m+n) | O(1) | Length difference |
| Merge 2 Lists | O(m+n) | O(1) | Two pointers |
| Merge K Lists | O(N log k) | O(k) | Divide & conquer or heap |
| K-Reverse | O(n) | O(1) | Iterative reversal |
| Palindrome | O(n) | O(1) | Middle + reverse + compare |

### Floyd's Algorithm Applications

| Application | Description | Complexity |
|-------------|-------------|------------|
| Cycle Detection | Find if cycle exists | O(n), O(1) |
| Cycle Start | Find where cycle begins | O(n), O(1) |
| Cycle Length | Count nodes in cycle | O(n), O(1) |
| Find Middle | Meet point when no cycle | O(n), O(1) |
| Find Duplicate | Array as implicit linked list | O(n), O(1) |

### Two-Pointer Patterns

| Pattern | Slow Move | Fast Move | Stops When |
|---------|-----------|-----------|------------|
| Middle | 1 step | 2 steps | fast at end |
| Cycle Detect | 1 step | 2 steps | slow == fast |
| Cycle Start | 1 step | 1 step | slow == fast (phase 2) |
| Remove Nth | 1 step | n+1 steps ahead | fast at end |

---

## Practice Problems

### Basic Operations
- [ ] Reverse Linked List
- [ ] Middle of Linked List
- [ ] Delete Node (Given Node)
- [ ] Remove Nth Node From End
- [ ] Linked List Cycle

### Reversal
- [ ] Reverse Linked List II
- [ ] Reverse Nodes in k-Group
- [ ] Swap Nodes in Pairs
- [ ] Reverse Alternate K Nodes

### Cycle & Intersection
- [ ] Linked List Cycle II (Find Start)
- [ ] Intersection of Two Linked Lists
- [ ] Happy Number (Cycle in Numbers)
- [ ] Find Duplicate Number (Floyd's)

### Merge & Sort
- [ ] Merge Two Sorted Lists
- [ ] Merge K Sorted Lists
- [ ] Sort List (Merge Sort)
- [ ] Insertion Sort List

### Advanced
- [ ] Palindrome Linked List
- [ ] Reorder List
- [ ] Add Two Numbers I & II
- [ ] Copy List with Random Pointer
- [ ] Flatten Multilevel Doubly Linked List
- [ ] LRU Cache (Doubly Linked List)

---

## Key Takeaways

1. **Dummy node** simplifies edge cases (empty list, head changes)
2. **Slow-fast pointers** solve middle, cycle, and many problems in O(n)
3. **Floyd's algorithm** detects cycles in O(n) time, O(1) space
4. **Reverse pattern:** Use 3 pointers (prev, curr, next)
5. **Always check NULL** before accessing node->next or node->val
6. **Draw diagrams** to visualize pointer changes
7. **Two-pointer** techniques are powerful for linked lists
8. **Space-efficient** solutions often use slow-fast or in-place reversal
9. **Intersection:** Either align lengths or use switch trick
10. **K-reverse:** Process in groups using iterative reversal

Master these patterns and you'll efficiently solve 95% of linked list problems! ðŸš€
