# Sorting & Binary Search - Complete Guide

## Table of Contents
1. [Sorting Fundamentals](#sorting-fundamentals)
2. [Selection Sort](#selection-sort)
3. [Merge Sort](#merge-sort)
4. [Quick Sort](#quick-sort)
5. [std::sort & Custom Comparators](#stdsort--custom-comparators)
6. [Binary Search Basics](#binary-search-basics)
7. [Binary Search on Values](#binary-search-on-values)
8. [Binary Search on Answer](#binary-search-on-answer)
9. [Boundary Patterns (lower_bound/upper_bound)](#boundary-patterns-lower_boundupper_bound)
10. [Advanced Patterns](#advanced-patterns)

---

## Sorting Fundamentals

### Why Sorting Matters?

**Sorted data enables:**
- Binary search (O(log n) instead of O(n))
- Two-pointer techniques
- Efficient duplicate detection
- Optimal interval merging
- Many greedy algorithms

### Comparison of Basic Sorts

| Algorithm | Best | Average | Worst | Space | Stable | In-Place |
|-----------|------|---------|-------|-------|--------|----------|
| Selection | O(n¬≤) | O(n¬≤) | O(n¬≤) | O(1) | ‚úó | ‚úì |
| Insertion | O(n) | O(n¬≤) | O(n¬≤) | O(1) | ‚úì | ‚úì |
| Bubble | O(n) | O(n¬≤) | O(n¬≤) | O(1) | ‚úì | ‚úì |
| Merge | O(n log n) | O(n log n) | O(n log n) | O(n) | ‚úì | ‚úó |
| Quick | O(n log n) | O(n log n) | O(n¬≤) | O(log n) | ‚úó | ‚úì |
| Heap | O(n log n) | O(n log n) | O(n log n) | O(1) | ‚úó | ‚úì |

### Stability

**Stable sort:** Preserves relative order of equal elements.

**Example:**
```
Input: [(5,a), (3,b), (5,c), (3,d)]

Stable sort by first value:
  [(3,b), (3,d), (5,a), (5,c)]
  Order preserved: b before d, a before c

Unstable sort:
  [(3,d), (3,b), (5,c), (5,a)]
  Order NOT preserved
```

**When stability matters:**
- Sorting objects with multiple fields
- Maintaining insertion order for ties
- Multi-level sorting (sort by field2, then by field1)

---

## Selection Sort

### How Selection Sort Works

**Concept:** Repeatedly find minimum from unsorted part and put at beginning.

**Steps:**
1. Find minimum in entire array ‚Üí swap with position 0
2. Find minimum in array[1..n] ‚Üí swap with position 1
3. Continue until sorted

**Visual:**
```
[64, 25, 12, 22, 11]
 ‚Üë   ‚Üë   ‚Üë   ‚Üë   ‚Üë
 
Step 1: Find min (11), swap with arr[0]
[11, 25, 12, 22, 64]
 ‚úì   ‚Üê unsorted part ‚Üí

Step 2: Find min in [25,12,22,64] (12), swap with arr[1]
[11, 12, 25, 22, 64]
 ‚úì   ‚úì   ‚Üê unsorted ‚Üí

Step 3: Find min in [25,22,64] (22), swap with arr[2]
[11, 12, 22, 25, 64]
 ‚úì   ‚úì   ‚úì   ‚Üê unsorted

Step 4: Find min in [25,64] (25), already in place
[11, 12, 22, 25, 64]
 ‚úì   ‚úì   ‚úì   ‚úì   ‚úì
```

### Implementation

```cpp
void selectionSort(vector<int>& arr) {
    int n = arr.size();
    
    for (int i = 0; i < n - 1; i++) {
        int minIdx = i;
        
        // Find minimum in unsorted part
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }
        
        // Swap with current position
        swap(arr[i], arr[minIdx]);
    }
}
```

**Detailed trace:**
```
arr = [64, 25, 12, 22, 11]

i=0: Search [64,25,12,22,11], minIdx=4 (value 11)
     Swap arr[0] with arr[4]
     arr = [11, 25, 12, 22, 64]

i=1: Search [25,12,22,64], minIdx=2 (value 12)
     Swap arr[1] with arr[2]
     arr = [11, 12, 25, 22, 64]

i=2: Search [25,22,64], minIdx=3 (value 22)
     Swap arr[2] with arr[3]
     arr = [11, 12, 22, 25, 64]

i=3: Search [25,64], minIdx=3 (value 25)
     No swap needed
     arr = [11, 12, 22, 25, 64]

Done!
```

### Complexity Analysis

**Time Complexity:**
- Best case: O(n¬≤) - Always scans entire unsorted part
- Average case: O(n¬≤)
- Worst case: O(n¬≤)

**Comparisons:** (n-1) + (n-2) + ... + 1 = n(n-1)/2 = O(n¬≤)

**Space:** O(1) - In-place

**Advantages:**
‚úÖ Simple to understand and implement  
‚úÖ In-place (O(1) extra space)  
‚úÖ Minimum number of swaps (at most n-1)

**Disadvantages:**
‚úó Always O(n¬≤), even if already sorted  
‚úó Not stable (can swap equal elements out of order)  
‚úó Not adaptive (doesn't benefit from partial sorting)

---

## Merge Sort

### How Merge Sort Works

**Concept:** Divide and conquer - split array in half recursively, then merge sorted halves.

**Steps:**
1. **Divide:** Split array into two halves
2. **Conquer:** Recursively sort each half
3. **Combine:** Merge two sorted halves

**Visual:**
```
                [38, 27, 43, 3, 9, 82, 10]
                          ‚Üì
                    Split
                   ‚Üô       ‚Üò
        [38, 27, 43, 3]    [9, 82, 10]
             ‚Üì                   ‚Üì
           Split               Split
          ‚Üô     ‚Üò             ‚Üô     ‚Üò
    [38, 27]   [43, 3]    [9, 82]   [10]
      ‚Üì           ‚Üì          ‚Üì        ‚Üì
    Split       Split      Split    (base)
    ‚Üô   ‚Üò       ‚Üô   ‚Üò      ‚Üô  ‚Üò
  [38]  [27]  [43]  [3]  [9]  [82]  [10]
   ‚Üì     ‚Üì     ‚Üì     ‚Üì    ‚Üì     ‚Üì     ‚Üì
  (base)(base)(base)(base)(base)(base)(base)

Now merge back up:
  [27,38]    [3,43]      [9,82]   [10]
       ‚Üì          ‚Üì           ‚Üì      ‚Üì
    [3,27,38,43]         [9,10,82]
             ‚Üì                ‚Üì
         [3,9,10,27,38,43,82]
```

### Implementation

```cpp
void merge(vector<int>& arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    
    // Create temp arrays
    vector<int> L(n1), R(n2);
    
    // Copy data
    for (int i = 0; i < n1; i++)
        L[i] = arr[left + i];
    for (int j = 0; j < n2; j++)
        R[j] = arr[mid + 1 + j];
    
    // Merge back
    int i = 0, j = 0, k = left;
    
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k++] = L[i++];
        } else {
            arr[k++] = R[j++];
        }
    }
    
    // Copy remaining
    while (i < n1) arr[k++] = L[i++];
    while (j < n2) arr[k++] = R[j++];
}

void mergeSort(vector<int>& arr, int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        
        // Sort first and second halves
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        
        // Merge the sorted halves
        merge(arr, left, mid, right);
    }
}

// Helper function
void mergeSort(vector<int>& arr) {
    mergeSort(arr, 0, arr.size() - 1);
}
```

**Detailed merge trace:**
```
Merging [27, 38] and [3, 43]:

L = [27, 38], R = [3, 43]
i=0, j=0

Compare L[0]=27 vs R[0]=3: 3 < 27
  arr[k] = 3, j=1, k=1

Compare L[0]=27 vs R[1]=43: 27 < 43
  arr[k] = 27, i=1, k=2

Compare L[1]=38 vs R[1]=43: 38 < 43
  arr[k] = 38, i=2, k=3

L exhausted, copy R[1]=43
  arr[k] = 43, k=4

Result: [3, 27, 38, 43]
```

### Complexity Analysis

**Time Complexity:**
- All cases: O(n log n)
- Height of tree: log n levels
- Each level processes n elements
- Total: n √ó log n

**Space:** O(n) - Need temporary arrays for merging

**Recurrence:** T(n) = 2T(n/2) + O(n)
- Using Master theorem: a=2, b=2, f(n)=n
- Case 2: T(n) = Œò(n log n)

**Advantages:**
‚úÖ Guaranteed O(n log n) time  
‚úÖ Stable sort  
‚úÖ Predictable performance  
‚úÖ Good for linked lists (no random access needed)  
‚úÖ Parallelizable

**Disadvantages:**
‚úó Requires O(n) extra space  
‚úó Not in-place  
‚úó Slower than quicksort in practice (more data movement)

---

## Quick Sort

### How Quick Sort Works

**Concept:** Choose pivot, partition array so elements < pivot are left, elements > pivot are right, then recursively sort partitions.

**Steps:**
1. **Choose pivot** (last element, random, median-of-three)
2. **Partition:** Rearrange so pivot is in correct position
3. **Recursively sort** left and right partitions

**Visual:**
```
[10, 80, 30, 90, 40, 50, 70]
                          ‚Üë pivot = 70

Partition:
  Elements < 70: [10, 30, 40, 50]
  Pivot: [70]
  Elements > 70: [80, 90]

Result: [10, 30, 40, 50, 70, 80, 90]
                        ‚úì
Now recursively sort left and right
```

**Partitioning process (Lomuto scheme):**
```
arr = [10, 80, 30, 90, 40, 50, 70], pivot = 70
       i                              

i tracks "boundary of elements < pivot"
j scans through array

j=0: arr[0]=10 < 70, swap arr[i] with arr[j], i++
  [10, 80, 30, 90, 40, 50, 70]
       i   j

j=1: arr[1]=80 >= 70, just move j
  [10, 80, 30, 90, 40, 50, 70]
       i       j

j=2: arr[2]=30 < 70, swap arr[i] with arr[j], i++
  [10, 30, 80, 90, 40, 50, 70]
           i       j

j=3: arr[3]=90 >= 70, move j
  [10, 30, 80, 90, 40, 50, 70]
           i           j

j=4: arr[4]=40 < 70, swap arr[i] with arr[j], i++
  [10, 30, 40, 90, 80, 50, 70]
               i           j

j=5: arr[5]=50 < 70, swap arr[i] with arr[j], i++
  [10, 30, 40, 50, 80, 90, 70]
                   i       j

Finally, place pivot at position i:
  [10, 30, 40, 50, 70, 90, 80]
                   ‚úì
```

### Implementation

```cpp
int partition(vector<int>& arr, int low, int high) {
    int pivot = arr[high];  // Choose last element as pivot
    int i = low - 1;        // Index of smaller element
    
    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    
    // Place pivot in correct position
    swap(arr[i + 1], arr[high]);
    return i + 1;
}

void quickSort(vector<int>& arr, int low, int high) {
    if (low < high) {
        // Partition and get pivot index
        int pi = partition(arr, low, high);
        
        // Recursively sort elements before and after partition
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

// Helper function
void quickSort(vector<int>& arr) {
    quickSort(arr, 0, arr.size() - 1);
}
```

**Complete trace:**
```
arr = [10, 80, 30, 90, 40, 50, 70]

quickSort(0, 6):
  partition(0, 6): pivot=70, returns 4
  arr = [10, 30, 40, 50, 70, 90, 80]
                          pi
  
  quickSort(0, 3): [10, 30, 40, 50]
    partition(0, 3): pivot=50, returns 3
    arr = [10, 30, 40, 50, ...]
                      pi
    
    quickSort(0, 2): [10, 30, 40]
      partition(0, 2): pivot=40, returns 2
      arr = [10, 30, 40, ...]
                      pi
      
      quickSort(0, 1): [10, 30]
        partition(0, 1): pivot=30, returns 1
        arr = [10, 30, ...]
                  pi
        
        quickSort(0, 0): base case
        quickSort(2, 1): invalid, skip
      
      quickSort(3, 2): invalid, skip
    
    quickSort(4, 3): invalid, skip
  
  quickSort(5, 6): [90, 80]
    partition(5, 6): pivot=80, returns 5
    arr = [..., 80, 90]
              pi
    
    quickSort(5, 4): invalid, skip
    quickSort(6, 6): base case

Final: [10, 30, 40, 50, 70, 80, 90]
```

### Pivot Selection Strategies

**1. Last element (Lomuto):**
```cpp
int pivot = arr[high];
```
Simple but poor for sorted arrays.

**2. Random element:**
```cpp
int randomIdx = low + rand() % (high - low + 1);
swap(arr[randomIdx], arr[high]);
int pivot = arr[high];
```
Good average case, avoids worst case on sorted input.

**3. Median-of-three:**
```cpp
int mid = low + (high - low) / 2;
// Take median of arr[low], arr[mid], arr[high]
if (arr[mid] < arr[low]) swap(arr[low], arr[mid]);
if (arr[high] < arr[low]) swap(arr[low], arr[high]);
if (arr[mid] < arr[high]) swap(arr[mid], arr[high]);
int pivot = arr[high];
```
Better pivot choice, more balanced partitions.

### Complexity Analysis

**Time Complexity:**
- Best case: O(n log n) - Balanced partitions
- Average case: O(n log n)
- Worst case: O(n¬≤) - Unbalanced partitions (already sorted with bad pivot)

**Best case (balanced):**
```
T(n) = 2T(n/2) + O(n) = O(n log n)
```

**Worst case (unbalanced):**
```
T(n) = T(n-1) + O(n) = O(n¬≤)

Example: [1, 2, 3, 4, 5] with last element as pivot
  Partition: [] [1] [2, 3, 4, 5]
  Then: [] [2] [3, 4, 5]
  Then: [] [3] [4, 5]
  ...
  n + (n-1) + (n-2) + ... = O(n¬≤)
```

**Space:** O(log n) - Recursion stack for balanced partitions

**Advantages:**
‚úÖ In-place (O(log n) stack)  
‚úÖ Cache-friendly (good locality)  
‚úÖ Fast in practice (low constant factors)  
‚úÖ Tail recursion can be optimized

**Disadvantages:**
‚úó Not stable  
‚úó Worst case O(n¬≤) (mitigated with random pivot)  
‚úó Recursive (stack overflow risk for large n)

---

## std::sort & Custom Comparators

### Using std::sort

**Basic usage:**
```cpp
#include <algorithm>
#include <vector>

vector<int> arr = {5, 2, 8, 1, 9};
sort(arr.begin(), arr.end());  // Ascending: [1, 2, 5, 8, 9]
```

**Descending order:**
```cpp
sort(arr.begin(), arr.end(), greater<int>());  // [9, 8, 5, 2, 1]
```

### What is std::sort?

**Implementation:** Introsort (hybrid of quicksort, heapsort, insertion sort)
- Starts with quicksort
- Switches to heapsort if recursion depth exceeds log n (avoids O(n¬≤))
- Uses insertion sort for small subarrays (< 16 elements)

**Complexity:** O(n log n) guaranteed  
**Stability:** Not stable (use `stable_sort` for stability)

### Custom Comparators

**Comparator:** Function that defines ordering between two elements.

**Returns:**
- `true` if first should come before second
- `false` otherwise

#### Method 1: Function Pointer

```cpp
bool compareAscending(int a, int b) {
    return a < b;  // a comes before b if a < b
}

bool compareDescending(int a, int b) {
    return a > b;  // a comes before b if a > b
}

vector<int> arr = {5, 2, 8, 1, 9};
sort(arr.begin(), arr.end(), compareAscending);   // [1, 2, 5, 8, 9]
sort(arr.begin(), arr.end(), compareDescending);  // [9, 8, 5, 2, 1]
```

#### Method 2: Lambda Function

```cpp
vector<int> arr = {5, 2, 8, 1, 9};

// Sort ascending
sort(arr.begin(), arr.end(), [](int a, int b) {
    return a < b;
});

// Sort descending
sort(arr.begin(), arr.end(), [](int a, int b) {
    return a > b;
});

// Sort by absolute value
vector<int> arr2 = {-5, 2, -8, 1, -3};
sort(arr2.begin(), arr2.end(), [](int a, int b) {
    return abs(a) < abs(b);
});
// Result: [1, 2, -3, -5, -8]
```

#### Method 3: Functor (Function Object)

```cpp
struct CompareAbs {
    bool operator()(int a, int b) const {
        return abs(a) < abs(b);
    }
};

vector<int> arr = {-5, 2, -8, 1, -3};
sort(arr.begin(), arr.end(), CompareAbs());
```

### Sorting Complex Objects

```cpp
struct Student {
    string name;
    int score;
    int age;
};

vector<Student> students = {
    {"Alice", 85, 20},
    {"Bob", 90, 19},
    {"Charlie", 85, 21}
};

// Sort by score (descending)
sort(students.begin(), students.end(), [](const Student& a, const Student& b) {
    return a.score > b.score;
});
// Bob(90), Alice(85), Charlie(85)

// Sort by score, then by age if scores equal
sort(students.begin(), students.end(), [](const Student& a, const Student& b) {
    if (a.score != b.score) {
        return a.score > b.score;  // Higher score first
    }
    return a.age < b.age;  // Younger first if scores equal
});
// Bob(90,19), Alice(85,20), Charlie(85,21)
```

### Sorting Pairs and Tuples

```cpp
vector<pair<int, int>> points = {{1, 5}, {3, 2}, {1, 3}};

// Default: sorts by first, then by second
sort(points.begin(), points.end());
// {1,3}, {1,5}, {3,2}

// Sort by second element
sort(points.begin(), points.end(), [](auto& a, auto& b) {
    return a.second < b.second;
});
// {3,2}, {1,3}, {1,5}

// Sort by sum of coordinates
sort(points.begin(), points.end(), [](auto& a, auto& b) {
    return (a.first + a.second) < (b.first + b.second);
});
// {1,3} [sum=4], {3,2} [sum=5], {1,5} [sum=6]
```

### Partial Sorting

**nth_element:** Partition so nth element is in sorted position.

```cpp
vector<int> arr = {5, 2, 8, 1, 9, 3, 7};

// Find 3rd smallest element (index 2)
nth_element(arr.begin(), arr.begin() + 2, arr.end());
// arr[2] is now 3 (3rd smallest)
// Elements before arr[2] are smaller
// Elements after arr[2] are larger
// [1, 2, 3, ?, ?, ?, ?]  (? are unordered but > 3)

// Find median
nth_element(arr.begin(), arr.begin() + arr.size()/2, arr.end());
```

**partial_sort:** Sort first k elements.

```cpp
vector<int> arr = {5, 2, 8, 1, 9, 3, 7};

// Sort first 3 elements
partial_sort(arr.begin(), arr.begin() + 3, arr.end());
// [1, 2, 3, ?, ?, ?, ?]  (first 3 are smallest, in order)
```

**Time:** O(n log k) for partial_sort, O(n) average for nth_element

### Stable Sort

**stable_sort:** Maintains relative order of equal elements.

```cpp
vector<pair<int, char>> arr = {{2,'a'}, {1,'b'}, {2,'c'}, {1,'d'}};

stable_sort(arr.begin(), arr.end(), [](auto& a, auto& b) {
    return a.first < b.first;
});
// {1,'b'}, {1,'d'}, {2,'a'}, {2,'c'}
// 'b' before 'd', 'a' before 'c' (order preserved)
```

**Complexity:** O(n log n) time, O(n) space

---

## Binary Search Basics

### What is Binary Search?

**Concept:** Search in sorted array by repeatedly dividing search space in half.

**Prerequisite:** Array must be sorted!

**How it works:**
1. Compare target with middle element
2. If equal, found!
3. If target < middle, search left half
4. If target > middle, search right half

**Visual:**
```
arr = [1, 3, 5, 7, 9, 11, 13, 15]  target = 7

Step 1: mid = 9
  [1, 3, 5, 7, | 9, 11, 13, 15]
              mid
  7 < 9, search left

Step 2: mid = 3
  [1, | 3, 5, 7]
      mid
  7 > 3, search right

Step 3: mid = 5
  [5, | 7]
      mid
  7 > 5, search right

Step 4: mid = 7
  [7]
  mid
  7 == 7, found!
```

### Implementation (Iterative)

```cpp
int binarySearch(vector<int>& arr, int target) {
    int left = 0;
    int right = arr.size() - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;  // Avoid overflow
        
        if (arr[mid] == target) {
            return mid;  // Found
        } else if (arr[mid] < target) {
            left = mid + 1;  // Search right
        } else {
            right = mid - 1;  // Search left
        }
    }
    
    return -1;  // Not found
}
```

**Why `left + (right - left) / 2`?**
- `(left + right) / 2` can overflow if left + right > INT_MAX
- `left + (right - left) / 2` is safer

### Implementation (Recursive)

```cpp
int binarySearchRecursive(vector<int>& arr, int target, int left, int right) {
    if (left > right) {
        return -1;  // Not found
    }
    
    int mid = left + (right - left) / 2;
    
    if (arr[mid] == target) {
        return mid;
    } else if (arr[mid] < target) {
        return binarySearchRecursive(arr, target, mid + 1, right);
    } else {
        return binarySearchRecursive(arr, target, left, mid - 1);
    }
}

int binarySearch(vector<int>& arr, int target) {
    return binarySearchRecursive(arr, target, 0, arr.size() - 1);
}
```

### Complexity Analysis

**Time:** O(log n)
- Each step eliminates half of remaining elements
- After k steps: n / 2^k elements remain
- When n / 2^k = 1, we're done
- k = log‚ÇÇ(n)

**Space:**
- Iterative: O(1)
- Recursive: O(log n) - call stack

**Example:**
```
n = 1024
Step 1: 512 elements
Step 2: 256 elements
Step 3: 128 elements
...
Step 10: 1 element

log‚ÇÇ(1024) = 10 steps
```

---

## Binary Search on Values

### Pattern 1: Find Exact Value

```cpp
bool binarySearch(vector<int>& arr, int target) {
    int left = 0, right = arr.size() - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) return true;
        else if (arr[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    
    return false;
}
```

### Pattern 2: Find in Rotated Sorted Array

**Problem:** Array was sorted then rotated: [4,5,6,7,0,1,2]

```cpp
int searchRotated(vector<int>& arr, int target) {
    int left = 0, right = arr.size() - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) return mid;
        
        // Determine which half is sorted
        if (arr[left] <= arr[mid]) {  // Left half sorted
            if (target >= arr[left] && target < arr[mid]) {
                right = mid - 1;  // Target in left half
            } else {
                left = mid + 1;   // Target in right half
            }
        } else {  // Right half sorted
            if (target > arr[mid] && target <= arr[right]) {
                left = mid + 1;   // Target in right half
            } else {
                right = mid - 1;  // Target in left half
            }
        }
    }
    
    return -1;
}
```

**Trace:**
```
arr = [4, 5, 6, 7, 0, 1, 2], target = 0

Step 1: mid = 7, left half [4,5,6,7] sorted
  0 not in [4,7], search right
  left = 4

Step 2: mid = 1, right half [0,1,2] sorted
  0 in [0,2], search right (but also includes mid)
  Actually: 0 < 1, so search left
  right = 3

Step 3: mid = 0
  Found!
```

### Pattern 3: Find Peak Element

**Peak:** Element greater than neighbors.

```cpp
int findPeakElement(vector<int>& arr) {
    int left = 0, right = arr.size() - 1;
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] < arr[mid + 1]) {
            left = mid + 1;  // Peak is on right
        } else {
            right = mid;     // Peak is on left (or mid itself)
        }
    }
    
    return left;  // Peak index
}
```

**Why it works:**
- If arr[mid] < arr[mid+1], there must be a peak on right (goes up then down)
- If arr[mid] > arr[mid+1], there must be a peak on left or at mid

**Time:** O(log n)

### Pattern 4: Search in 2D Matrix

**Matrix:** Each row sorted, first element of each row > last of previous row.

```cpp
bool searchMatrix(vector<vector<int>>& matrix, int target) {
    if (matrix.empty() || matrix[0].empty()) return false;
    
    int m = matrix.size(), n = matrix[0].size();
    int left = 0, right = m * n - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        int midVal = matrix[mid / n][mid % n];  // Convert 1D to 2D
        
        if (midVal == target) return true;
        else if (midVal < target) left = mid + 1;
        else right = mid - 1;
    }
    
    return false;
}
```

**How it works:** Treat 2D matrix as 1D array!
```
Matrix:          1D array:
[1, 3, 5]        [1, 3, 5, 7, 10, 11]
[7, 10, 11]       0  1  2  3   4   5

Index conversion:
  1D index = i * n + j
  2D: row = idx / n, col = idx % n
```

---

## Binary Search on Answer

### Concept

**Idea:** When answer space is sorted/monotonic, binary search on answer!

**Pattern:**
1. Answer is in range [low, high]
2. We can check if answer X is valid
3. If X is valid, try smaller/larger (depending on min/max)
4. Binary search on X!

**Template:**
```cpp
int binarySearchAnswer() {
    int left = minPossible;
    int right = maxPossible;
    int result = -1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (isValid(mid)) {
            result = mid;       // Store valid answer
            // Try for better answer
            left = mid + 1;     // For maximum
            // or right = mid - 1;  For minimum
        } else {
            right = mid - 1;    // For maximum
            // or left = mid + 1;   For minimum
        }
    }
    
    return result;
}
```

### Pattern 1: Square Root

**Problem:** Find floor(‚àöx).

```cpp
int mySqrt(int x) {
    if (x < 2) return x;
    
    int left = 1, right = x / 2;
    int result = 0;
    
    while (left <= right) {
        long long mid = left + (right - left) / 2;
        long long square = mid * mid;
        
        if (square == x) {
            return mid;
        } else if (square < x) {
            result = mid;    // Store valid answer
            left = mid + 1;  // Try larger
        } else {
            right = mid - 1; // Try smaller
        }
    }
    
    return result;
}
```

**Trace:**
```
x = 8, answer should be 2 (since 2¬≤ = 4 ‚â§ 8, 3¬≤ = 9 > 8)

left = 1, right = 4

Step 1: mid = 2, 2¬≤ = 4 < 8
  result = 2, left = 3

Step 2: mid = 3, 3¬≤ = 9 > 8
  right = 2

left > right, return result = 2
```

**Time:** O(log n)

### Pattern 2: Capacity To Ship Packages

**Problem:** Ship packages in D days. What's minimum ship capacity?

**Key insight:** If capacity C works, capacity C+1 also works (monotonic)!

```cpp
bool canShip(vector<int>& weights, int days, int capacity) {
    int daysNeeded = 1;
    int currentLoad = 0;
    
    for (int weight : weights) {
        if (currentLoad + weight > capacity) {
            daysNeeded++;
            currentLoad = weight;
            
            if (daysNeeded > days) return false;
        } else {
            currentLoad += weight;
        }
    }
    
    return true;
}

int shipWithinDays(vector<int>& weights, int days) {
    int left = *max_element(weights.begin(), weights.end());  // Min capacity
    int right = accumulate(weights.begin(), weights.end(), 0); // Max capacity
    int result = right;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (canShip(weights, days, mid)) {
            result = mid;       // Valid capacity
            right = mid - 1;    // Try smaller (minimize)
        } else {
            left = mid + 1;     // Need larger capacity
        }
    }
    
    return result;
}
```

**Trace:**
```
weights = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], days = 5

left = 10 (max weight), right = 55 (sum)

Step 1: mid = 32
  canShip(32, 5)? Yes (many ways to split)
  result = 32, right = 31

Step 2: mid = 20
  canShip(20, 5)? Yes
  result = 20, right = 19

Step 3: mid = 14
  canShip(14, 5)? No (can't fit even with 5 days)
  left = 15

Step 4: mid = 17
  canShip(17, 5)? Yes
  result = 17, right = 16

Step 5: mid = 15
  canShip(15, 5)? Yes
  result = 15, right = 14

left > right, return 15
```

**Time:** O(n log(sum - max))

### Pattern 3: Koko Eating Bananas

**Problem:** Koko eats at most K bananas/hour. Minimum K to finish in H hours?

```cpp
bool canFinish(vector<int>& piles, int h, int k) {
    long long hours = 0;
    for (int pile : piles) {
        hours += (pile + k - 1) / k;  // Ceiling division
        if (hours > h) return false;
    }
    return true;
}

int minEatingSpeed(vector<int>& piles, int h) {
    int left = 1;
    int right = *max_element(piles.begin(), piles.end());
    int result = right;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (canFinish(piles, h, mid)) {
            result = mid;
            right = mid - 1;  // Try slower
        } else {
            left = mid + 1;   // Need faster
        }
    }
    
    return result;
}
```

**Time:** O(n log m) where m = max pile

### Pattern 4: Split Array Largest Sum

**Problem:** Split array into m subarrays, minimize largest sum.

```cpp
bool canSplit(vector<int>& nums, int m, int maxSum) {
    int splits = 1;
    int currentSum = 0;
    
    for (int num : nums) {
        if (currentSum + num > maxSum) {
            splits++;
            currentSum = num;
            if (splits > m) return false;
        } else {
            currentSum += num;
        }
    }
    
    return true;
}

int splitArray(vector<int>& nums, int m) {
    int left = *max_element(nums.begin(), nums.end());
    int right = accumulate(nums.begin(), nums.end(), 0);
    int result = right;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (canSplit(nums, m, mid)) {
            result = mid;
            right = mid - 1;  // Try smaller max
        } else {
            left = mid + 1;   // Need larger max
        }
    }
    
    return result;
}
```

**Time:** O(n log(sum - max))

---

## Boundary Patterns (lower_bound/upper_bound)

### Understanding lower_bound and upper_bound

**lower_bound(x):** First position where element ‚â• x can be inserted  
**upper_bound(x):** First position where element > x can be inserted

**Visual:**
```
arr = [1, 2, 2, 2, 3, 5, 5, 7]
           ‚Üë       ‚Üë
           
lower_bound(2) = index 1 (first 2)
upper_bound(2) = index 4 (first element > 2, which is 3)

lower_bound(4) = index 5 (position where 4 would go)
upper_bound(4) = index 5 (same, no 4 exists)

lower_bound(5) = index 5 (first 5)
upper_bound(5) = index 7 (first element > 5, which is 7)
```

### STL Functions

```cpp
#include <algorithm>

vector<int> arr = {1, 2, 2, 2, 3, 5, 5, 7};

// Find lower_bound
auto it1 = lower_bound(arr.begin(), arr.end(), 2);
int idx1 = it1 - arr.begin();  // 1

// Find upper_bound
auto it2 = upper_bound(arr.begin(), arr.end(), 2);
int idx2 = it2 - arr.begin();  // 4

// Count occurrences
int count = upper_bound(arr.begin(), arr.end(), 2) 
          - lower_bound(arr.begin(), arr.end(), 2);  // 3
```

### Manual Implementation

#### lower_bound (First ‚â• target)

```cpp
int lowerBound(vector<int>& arr, int target) {
    int left = 0, right = arr.size();
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] < target) {
            left = mid + 1;  // Move right
        } else {
            right = mid;     // Could be answer, keep searching left
        }
    }
    
    return left;
}
```

**Trace:**
```
arr = [1, 2, 2, 2, 3, 5, 5, 7], target = 2

left = 0, right = 8

Step 1: mid = 4, arr[4] = 3 >= 2
  right = 4

Step 2: mid = 2, arr[2] = 2 >= 2
  right = 2 (could be answer, but search left)

Step 3: mid = 1, arr[1] = 2 >= 2
  right = 1

Step 4: mid = 0, arr[0] = 1 < 2
  left = 1

left == right, return 1 (first index with value >= 2)
```

#### upper_bound (First > target)

```cpp
int upperBound(vector<int>& arr, int target) {
    int left = 0, right = arr.size();
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] <= target) {
            left = mid + 1;  // Move right
        } else {
            right = mid;     // Could be answer, keep searching left
        }
    }
    
    return left;
}
```

**Key difference:** `<=` vs `<` in condition!

### Pattern 1: Count Occurrences

```cpp
int countOccurrences(vector<int>& arr, int target) {
    int lower = lower_bound(arr.begin(), arr.end(), target) - arr.begin();
    int upper = upper_bound(arr.begin(), arr.end(), target) - arr.begin();
    return upper - lower;
}
```

**Example:**
```
arr = [1, 2, 2, 2, 3, 5]
target = 2

lower_bound(2) = 1
upper_bound(2) = 4
count = 4 - 1 = 3
```

### Pattern 2: Find First and Last Position

```cpp
vector<int> searchRange(vector<int>& arr, int target) {
    int lower = lower_bound(arr.begin(), arr.end(), target) - arr.begin();
    
    if (lower == arr.size() || arr[lower] != target) {
        return {-1, -1};  // Not found
    }
    
    int upper = upper_bound(arr.begin(), arr.end(), target) - arr.begin();
    return {lower, upper - 1};
}
```

### Pattern 3: Insert Position

```cpp
int searchInsert(vector<int>& arr, int target) {
    return lower_bound(arr.begin(), arr.end(), target) - arr.begin();
}
```

**Example:**
```
arr = [1, 3, 5, 6], target = 2
lower_bound(2) = 1 (insert at index 1)

arr = [1, 3, 5, 6], target = 7
lower_bound(7) = 4 (insert at end)
```

### Pattern 4: Closest Element

```cpp
int findClosest(vector<int>& arr, int target) {
    int pos = lower_bound(arr.begin(), arr.end(), target) - arr.begin();
    
    if (pos == 0) return arr[0];
    if (pos == arr.size()) return arr[arr.size() - 1];
    
    // Check both neighbors
    int before = arr[pos - 1];
    int after = arr[pos];
    
    return (abs(before - target) <= abs(after - target)) ? before : after;
}
```

### Pattern 5: Find Range with Sum

**Problem:** Find count of elements in range [lower, upper].

```cpp
int countRangeSum(vector<int>& arr, int lower, int upper) {
    auto lowerIt = lower_bound(arr.begin(), arr.end(), lower);
    auto upperIt = upper_bound(arr.begin(), arr.end(), upper);
    return upperIt - lowerIt;
}
```

### Binary Search Template Variations

**Template 1: Find exact value**
```cpp
while (left <= right) {
    int mid = left + (right - left) / 2;
    if (arr[mid] == target) return mid;
    else if (arr[mid] < target) left = mid + 1;
    else right = mid - 1;
}
```

**Template 2: Find boundary (lower_bound style)**
```cpp
while (left < right) {
    int mid = left + (right - left) / 2;
    if (condition(mid)) {
        right = mid;  // Might be answer, keep searching left
    } else {
        left = mid + 1;
    }
}
return left;
```

**Template 3: Find boundary (upper_bound style)**
```cpp
while (left < right) {
    int mid = left + (right - left) / 2;
    if (condition(mid)) {
        left = mid + 1;
    } else {
        right = mid;
    }
}
return left;
```

---

## Advanced Patterns

### Pattern 1: Median of Two Sorted Arrays

**Problem:** Find median in O(log(min(m, n))).

```cpp
double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
    if (nums1.size() > nums2.size()) {
        return findMedianSortedArrays(nums2, nums1);  // Ensure nums1 is smaller
    }
    
    int m = nums1.size(), n = nums2.size();
    int left = 0, right = m;
    
    while (left <= right) {
        int partition1 = (left + right) / 2;
        int partition2 = (m + n + 1) / 2 - partition1;
        
        int maxLeft1 = (partition1 == 0) ? INT_MIN : nums1[partition1 - 1];
        int minRight1 = (partition1 == m) ? INT_MAX : nums1[partition1];
        
        int maxLeft2 = (partition2 == 0) ? INT_MIN : nums2[partition2 - 1];
        int minRight2 = (partition2 == n) ? INT_MAX : nums2[partition2];
        
        if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) {
            if ((m + n) % 2 == 0) {
                return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2.0;
            } else {
                return max(maxLeft1, maxLeft2);
            }
        } else if (maxLeft1 > minRight2) {
            right = partition1 - 1;
        } else {
            left = partition1 + 1;
        }
    }
    
    return 0.0;
}
```

**Time:** O(log(min(m, n)))

### Pattern 2: Find Minimum in Rotated Sorted Array

```cpp
int findMin(vector<int>& arr) {
    int left = 0, right = arr.size() - 1;
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] > arr[right]) {
            left = mid + 1;  // Min is in right half
        } else {
            right = mid;     // Min is in left half or mid
        }
    }
    
    return arr[left];
}
```

### Pattern 3: Single Element in Sorted Array

**Problem:** All elements appear twice except one.

```cpp
int singleNonDuplicate(vector<int>& arr) {
    int left = 0, right = arr.size() - 1;
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        // Ensure mid is at first of pair
        if (mid % 2 == 1) mid--;
        
        if (arr[mid] == arr[mid + 1]) {
            left = mid + 2;  // Single is on right
        } else {
            right = mid;     // Single is on left
        }
    }
    
    return arr[left];
}
```

**How it works:**
```
[1,1,2,3,3,4,4,8,8]
     ‚Üë (single element at index 2)

Pairs before single: [1,1], [2]
Pairs after single: [3,3], [4,4], [8,8]

If mid at even index and arr[mid] == arr[mid+1]:
  Pair is complete, single is on right
Else:
  Pair is broken, single is on left
```

### Pattern 4: Aggressive Cows

**Problem:** Place C cows in N stalls, maximize minimum distance.

```cpp
bool canPlace(vector<int>& stalls, int cows, int minDist) {
    int count = 1;  // Place first cow
    int lastPos = stalls[0];
    
    for (int i = 1; i < stalls.size(); i++) {
        if (stalls[i] - lastPos >= minDist) {
            count++;
            lastPos = stalls[i];
            if (count == cows) return true;
        }
    }
    
    return false;
}

int aggressiveCows(vector<int>& stalls, int cows) {
    sort(stalls.begin(), stalls.end());
    
    int left = 1;
    int right = stalls.back() - stalls[0];
    int result = 0;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (canPlace(stalls, cows, mid)) {
            result = mid;
            left = mid + 1;  // Try larger distance
        } else {
            right = mid - 1;
        }
    }
    
    return result;
}
```

**Time:** O(n log n) sort + O(n log(max_dist))

---

## Summary Tables

### Sort Comparison

| Algorithm | Time (Best/Avg/Worst) | Space | Stable | Use Case |
|-----------|----------------------|-------|--------|----------|
| Selection | O(n¬≤)/O(n¬≤)/O(n¬≤) | O(1) | ‚úó | Small arrays, min swaps |
| Insertion | O(n)/O(n¬≤)/O(n¬≤) | O(1) | ‚úì | Nearly sorted, online |
| Merge | O(n log n)/O(n log n)/O(n log n) | O(n) | ‚úì | Linked lists, stable |
| Quick | O(n log n)/O(n log n)/O(n¬≤) | O(log n) | ‚úó | General purpose |
| Heap | O(n log n)/O(n log n)/O(n log n) | O(1) | ‚úó | In-place O(n log n) |
| std::sort | O(n log n)/O(n log n)/O(n log n) | O(log n) | ‚úó | Default choice |

### Binary Search Patterns

| Pattern | Range | Condition | Result |
|---------|-------|-----------|--------|
| Exact match | [0, n-1] | arr[mid] == target | mid or -1 |
| lower_bound | [0, n] | arr[mid] < target | First ‚â• target |
| upper_bound | [0, n] | arr[mid] <= target | First > target |
| Binary on answer | [min, max] | isValid(mid) | Optimal answer |

### Comparator Patterns

| Use Case | Comparator | Result |
|----------|------------|--------|
| Ascending | `a < b` | Smallest first |
| Descending | `a > b` | Largest first |
| By absolute value | `abs(a) < abs(b)` | Closest to 0 first |
| Pairs by first | `a.first < b.first` | Sort by key |
| Multi-key | `if (a.x != b.x) return a.x < b.x; return a.y < b.y;` | Sort by x, then y |

### Time Complexities

| Operation | Unsorted | Sorted | With Binary Search |
|-----------|----------|--------|-------------------|
| Search | O(n) | O(n) | O(log n) |
| Insert | O(1) | O(n) | O(n) find + O(n) insert |
| Delete | O(n) | O(n) | O(log n) find + O(n) delete |
| Min/Max | O(n) | O(1) | O(1) |
| K-th element | O(n log n) sort | O(1) | O(1) if sorted |

---

## Practice Problems

### Sorting
- [ ] Sort Colors (Dutch National Flag)
- [ ] Merge Intervals
- [ ] Largest Number
- [ ] Custom Sort String
- [ ] Sort Characters By Frequency

### Binary Search - Basic
- [ ] Binary Search
- [ ] Search Insert Position
- [ ] First Bad Version
- [ ] Find Peak Element
- [ ] Search in Rotated Sorted Array

### Binary Search - Advanced
- [ ] Find Minimum in Rotated Sorted Array
- [ ] Search a 2D Matrix
- [ ] Median of Two Sorted Arrays
- [ ] Find K-th Smallest Element
- [ ] Single Element in Sorted Array

### Binary Search on Answer
- [ ] Capacity To Ship Packages Within D Days
- [ ] Koko Eating Bananas
- [ ] Split Array Largest Sum
- [ ] Minimum Time to Complete Trips
- [ ] Magnetic Force Between Two Balls

### Boundary Patterns
- [ ] Find First and Last Position
- [ ] Count of Smaller Numbers After Self
- [ ] Russian Doll Envelopes
- [ ] Count of Range Sum
- [ ] Longest Increasing Subsequence (binary search optimization)

---

## Key Takeaways

1. **std::sort is usually the best choice** - O(n log n) guaranteed, well-optimized
2. **Merge sort for stability**, quick sort for in-place with good average case
3. **Binary search requires sorted data** - always check this prerequisite!
4. **`mid = left + (right - left) / 2`** prevents overflow
5. **lower_bound vs upper_bound:** `<` vs `<=` in condition
6. **Binary search on answer** when answer space is monotonic
7. **Custom comparators:** Return `true` if first should come before second
8. **Template choice matters:** `left <= right` vs `left < right` for different patterns
9. **Visualize the search space** - draw diagrams to understand boundaries
10. **Practice both iterative and recursive** - understand when to use each

Master these sorting and binary search patterns and you'll efficiently solve 90% of related problems! üöÄ
