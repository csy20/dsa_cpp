# Greedy Algorithms - Complete Guide

## Table of Contents
1. [Greedy Fundamentals](#greedy-fundamentals)
2. [When Greedy Works](#when-greedy-works)
3. [Interval Scheduling](#interval-scheduling)
4. [Activity Selection](#activity-selection)
5. [Interval Partitioning](#interval-partitioning)
6. [Meeting Rooms Problems](#meeting-rooms-problems)
7. [Huffman Coding](#huffman-coding)
8. [Coin Change](#coin-change)
9. [Advanced Greedy Patterns](#advanced-greedy-patterns)
10. [Common Problems](#common-problems)

---

## Greedy Fundamentals

### What is Greedy?

**Greedy Algorithm:** Makes locally optimal choice at each step, hoping to find global optimum.

**Key idea:** 
```
At each decision point:
  1. Choose the option that looks best RIGHT NOW
  2. Never reconsider past choices
  3. Hope this leads to overall optimal solution
```

**Example (Coin change with [1, 5, 10, 25]):**
```
Make 41 cents:

Greedy approach:
  25 (largest ‚â§ 41): Use 1 quarter, remaining = 16
  10 (largest ‚â§ 16): Use 1 dime, remaining = 6
  5 (largest ‚â§ 6): Use 1 nickel, remaining = 1
  1: Use 1 penny
  
Result: 4 coins (25 + 10 + 5 + 1) ‚úì OPTIMAL
```

### Greedy vs Dynamic Programming

| Greedy | Dynamic Programming |
|--------|---------------------|
| Makes choice once | Considers all choices |
| Never looks back | Stores subproblem results |
| O(n) or O(n log n) typically | O(n¬≤) or worse typically |
| May not find optimal | Always finds optimal |
| Fast, simple | Slower, complex |

**Visual comparison:**
```
Problem: Make 6 cents with coins [1, 3, 4]

Greedy:
  4 (largest): Use 1, remaining = 2
  1: Use 2
  Result: 3 coins (4 + 1 + 1) ‚úó

DP:
  Considers: 4+1+1=3 coins OR 3+3=2 coins
  Result: 2 coins (3 + 3) ‚úì

Greedy FAILS here!
```

### Greedy Choice Property

**Two key properties for greedy to work:**

1. **Greedy Choice Property:** Locally optimal choice leads to globally optimal solution
2. **Optimal Substructure:** Optimal solution contains optimal solutions to subproblems

**Example: Activity Selection**
```
Activities with finish times:
  A: [1, 4]
  B: [3, 5]
  C: [0, 6]
  D: [5, 7]
  E: [8, 9]

Greedy: Always pick activity that finishes earliest
  Pick A (finishes at 4)
  Pick D (finishes at 7, starts after 4)
  Pick E (finishes at 9, starts after 7)
  
Result: 3 activities ‚úì OPTIMAL
```

---

## When Greedy Works

### Problems Where Greedy Works

‚úÖ **Greedy works:**
- Activity selection
- Interval scheduling
- Fractional knapsack
- Huffman coding
- Dijkstra's shortest path
- Prim's/Kruskal's MST
- Coin change (specific denominations)
- Jump game

‚ùå **Greedy fails:**
- 0/1 Knapsack (need DP)
- Longest increasing subsequence (need DP)
- Coin change (arbitrary denominations)
- Traveling salesman
- Subset sum

### How to Identify Greedy Problems

**Red flags (greedy might work):**
- "Maximum/minimum number of..."
- "Earliest/latest finish time"
- "Non-overlapping intervals"
- "Partition into groups"
- "Optimal prefix code"

**Verification steps:**
1. Identify greedy choice (what to pick each step?)
2. Prove greedy choice property (why is local choice globally optimal?)
3. Prove optimal substructure (does reducing problem maintain optimality?)

**Example proof template:**
```
Claim: Always picking interval with earliest finish time is optimal

Proof (exchange argument):
  Suppose optimal solution O doesn't pick earliest-finishing interval i
  O picks some other interval j that finishes later
  
  Replace j with i in O:
    - i finishes earlier, so doesn't conflict with later intervals
    - O' = O with j replaced by i is also optimal
    - Contradiction or O' is at least as good as O
  
  Therefore, greedy choice is safe ‚úì
```

---

## Interval Scheduling

### Maximum Non-Overlapping Intervals

**Problem:** Given intervals, select maximum number that don't overlap.

**Greedy strategy:** Always pick interval with **earliest finish time**.

```cpp
int maxNonOverlapping(vector<vector<int>>& intervals) {
    if (intervals.empty()) return 0;
    
    // Sort by finish time (end time)
    sort(intervals.begin(), intervals.end(), [](const auto& a, const auto& b) {
        return a[1] < b[1];
    });
    
    int count = 1;
    int lastEnd = intervals[0][1];
    
    for (int i = 1; i < intervals.size(); i++) {
        // If current interval starts after last one ends
        if (intervals[i][0] >= lastEnd) {
            count++;
            lastEnd = intervals[i][1];
        }
    }
    
    return count;
}
```

**How it works:**
```
Intervals: [[1,3], [2,4], [3,5], [0,2]]

Step 1: Sort by end time
  [[0,2], [1,3], [2,4], [3,5]]
   ‚Üì end  ‚Üì end  ‚Üì end  ‚Üì end

Step 2: Pick intervals greedily
  Pick [0,2]: count=1, lastEnd=2
  
  Check [1,3]: starts at 1 < 2 (overlap) ‚Üí Skip
  
  Check [2,4]: starts at 2 ‚â• 2 ‚úì
    Pick [2,4]: count=2, lastEnd=4
  
  Check [3,5]: starts at 3 < 4 (overlap) ‚Üí Skip

Result: 2 intervals ([0,2] and [2,4])
```

**Visual:**
```
Time:  0  1  2  3  4  5
       [--0--]
          [--1--]
             [--2--]    ‚Üê Selected
                [--3--]

Timeline:
  [0,2]: ‚ñà‚ñà‚ñà‚ñà
  [2,4]:    ‚ñà‚ñà‚ñà‚ñà  ‚Üê No overlap!
```

**Why earliest finish time?**
```
Intuition: Finishing early leaves more room for future intervals

Counterexample if we pick longest first:
  [1,10] (longest)
  [2,3], [4,5], [6,7], [8,9]
  
  Pick [1,10]: count=1 (all others overlap)
  Optimal: Pick [2,3], [4,5], [6,7], [8,9]: count=4
  
  Greedy by length fails!

Earliest finish time:
  Pick [2,3]: leaves most room
  Pick [4,5]: continues optimally
  ...
```

**Time:** O(n log n) for sorting  
**Space:** O(1)

---

## Activity Selection

### Classical Activity Selection

**Problem:** Select maximum activities a person can do (can't do two at once).

**Same as interval scheduling!** Pick earliest-finishing activity each time.

```cpp
int activitySelection(vector<int>& start, vector<int>& finish) {
    int n = start.size();
    
    // Create pairs and sort by finish time
    vector<pair<int,int>> activities(n);
    for (int i = 0; i < n; i++) {
        activities[i] = {start[i], finish[i]};
    }
    
    sort(activities.begin(), activities.end(), [](const auto& a, const auto& b) {
        return a.second < b.second;
    });
    
    int count = 1;
    int lastFinish = activities[0].second;
    
    for (int i = 1; i < n; i++) {
        if (activities[i].first >= lastFinish) {
            count++;
            lastFinish = activities[i].second;
        }
    }
    
    return count;
}
```

**Example:**
```
Activities:
  A: start=1, finish=4
  B: start=3, finish=5
  C: start=0, finish=6
  D: start=5, finish=7
  E: start=3, finish=9
  F: start=5, finish=9
  G: start=6, finish=10
  H: start=8, finish=11
  I: start=8, finish=12
  J: start=2, finish=14
  K: start=12, finish=16

Sorted by finish:
  A[1,4], B[3,5], C[0,6], D[5,7], E[3,9], F[5,9], G[6,10], H[8,11], I[8,12], J[2,14], K[12,16]

Selection:
  Pick A (finish=4)
  Skip B (start=3 < 4)
  Skip C (start=0 < 4)
  Pick D (start=5 ‚â• 4, finish=7)
  Skip E, F, G (all start before 7)
  Pick H (start=8 ‚â• 7, finish=11)
  Skip I, J (start before 11)
  Pick K (start=12 ‚â• 11)

Selected: A, D, H, K ‚Üí 4 activities ‚úì
```

**Visual timeline:**
```
Time:  0  2  4  6  8  10 12 14 16
A:        |‚ñà‚ñà|
B:           |‚ñà‚ñà|
C:     |‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà|
D:              |‚ñà‚ñà|        ‚Üê Selected
E:           |‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà|
F:              |‚ñà‚ñà‚ñà‚ñà‚ñà|
G:                |‚ñà‚ñà‚ñà‚ñà|
H:                   |‚ñà‚ñà‚ñà‚ñà|  ‚Üê Selected
I:                   |‚ñà‚ñà‚ñà‚ñà‚ñà|
J:        |‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà|
K:                       |‚ñà‚ñà‚ñà‚ñà| ‚Üê Selected
```

---

## Interval Partitioning

### Minimum Groups for Non-Overlapping

**Problem:** Partition intervals into minimum number of groups where intervals in same group don't overlap.

**Greedy strategy:** Sort by start time, assign to earliest-available group.

```cpp
int minGroups(vector<vector<int>>& intervals) {
    // Sort by start time
    sort(intervals.begin(), intervals.end());
    
    // Min heap: tracks end time of each group
    priority_queue<int, vector<int>, greater<int>> minHeap;
    
    for (auto& interval : intervals) {
        int start = interval[0];
        int end = interval[1];
        
        // If earliest-ending group finishes before this starts, reuse it
        if (!minHeap.empty() && minHeap.top() <= start) {
            minHeap.pop();
        }
        
        // Add current interval's end time
        minHeap.push(end);
    }
    
    // Number of groups = heap size
    return minHeap.size();
}
```

**How it works:**
```
Intervals: [[1,3], [2,4], [3,5], [4,6]]

Sorted: [[1,3], [2,4], [3,5], [4,6]]

Process [1,3]:
  Heap empty, create group 1
  Heap: [3] (group 1 ends at 3)
  Groups: 1

Process [2,4]:
  Min end = 3 > 2 (start), can't reuse
  Create group 2
  Heap: [3, 4]
  Groups: 2

Process [3,5]:
  Min end = 3 ‚â§ 3 (start), reuse group 1 ‚úì
  Remove 3, add 5
  Heap: [4, 5]
  Groups: 2

Process [4,6]:
  Min end = 4 ‚â§ 4 (start), reuse group 2 ‚úì
  Remove 4, add 6
  Heap: [5, 6]
  Groups: 2

Answer: 2 groups
```

**Visual:**
```
Group 1: [1,3] ‚Üí [3,5] ‚Üí ...
         |‚ñà‚ñà|    |‚ñà‚ñà|

Group 2: [2,4] ‚Üí [4,6]
           |‚ñà‚ñà|  |‚ñà‚ñà|

Timeline:
Time:  1  2  3  4  5  6
G1:    |‚ñà‚ñà|  |‚ñà‚ñà|
G2:       |‚ñà‚ñà|  |‚ñà‚ñà|
```

**Why this works:**
```
Key insight: Minimum groups = maximum depth (overlapping intervals)

At any time t, depth = number of intervals containing t
Maximum depth across all time = minimum groups needed

Greedy approach finds this by:
  - Reusing earliest-finishing group when possible
  - Creating new group only when necessary (all groups busy)
```

**Time:** O(n log n)  
**Space:** O(n)

---

## Meeting Rooms Problems

### Meeting Rooms I: Can Attend All?

**Problem:** Can one person attend all meetings?

```cpp
bool canAttendMeetings(vector<vector<int>>& intervals) {
    sort(intervals.begin(), intervals.end());
    
    for (int i = 1; i < intervals.size(); i++) {
        // If current meeting starts before previous ends
        if (intervals[i][0] < intervals[i-1][1]) {
            return false;  // Overlap!
        }
    }
    
    return true;
}
```

**Example:**
```
Meetings: [[0,30], [5,10], [15,20]]

Sorted: [[0,30], [5,10], [15,20]]

Check [5,10]:
  5 < 30 (previous end) ‚Üí Overlap! ‚úó

Answer: false (can't attend all)
```

### Meeting Rooms II: Minimum Rooms

**Problem:** Minimum conference rooms needed.

```cpp
int minMeetingRooms(vector<vector<int>>& intervals) {
    vector<int> starts, ends;
    
    for (auto& interval : intervals) {
        starts.push_back(interval[0]);
        ends.push_back(interval[1]);
    }
    
    sort(starts.begin(), starts.end());
    sort(ends.begin(), ends.end());
    
    int rooms = 0, maxRooms = 0;
    int i = 0, j = 0;
    
    while (i < starts.size()) {
        if (starts[i] < ends[j]) {
            // Meeting starts before earliest one ends
            rooms++;
            maxRooms = max(maxRooms, rooms);
            i++;
        } else {
            // A meeting ends, free up room
            rooms--;
            j++;
        }
    }
    
    return maxRooms;
}
```

**How it works:**
```
Meetings: [[0,30], [5,10], [15,20]]

Starts: [0, 5, 15]
Ends:   [10, 20, 30]

Simulation (two pointers):
  i=0, j=0: starts[0]=0 < ends[0]=10
    Meeting starts, rooms++ ‚Üí rooms=1, max=1

  i=1, j=0: starts[1]=5 < ends[0]=10
    Meeting starts, rooms++ ‚Üí rooms=2, max=2

  i=2, j=0: starts[2]=15 > ends[0]=10
    Meeting ends, rooms-- ‚Üí rooms=1, j=1

  i=2, j=1: starts[2]=15 < ends[1]=20
    Meeting starts, rooms++ ‚Üí rooms=2

  i=3 (done)

Answer: 2 rooms needed
```

**Visual:**
```
Time:  0    5    10   15   20   30
Room1: |--------30--------|
Room2:      |--10--|  |--20--|
       ‚Üë    ‚Üë         ‚Üë
       2    Peak=2    1 room freed
```

**Alternative: Heap approach (same complexity)**
```cpp
int minMeetingRooms(vector<vector<int>>& intervals) {
    sort(intervals.begin(), intervals.end());
    
    priority_queue<int, vector<int>, greater<int>> minHeap;
    
    for (auto& interval : intervals) {
        if (!minHeap.empty() && minHeap.top() <= interval[0]) {
            minHeap.pop();  // Reuse room
        }
        minHeap.push(interval[1]);
    }
    
    return minHeap.size();
}
```

**Time:** O(n log n)  
**Space:** O(n)

### Meeting Rooms III: Weighted Intervals

**Problem:** Select non-overlapping intervals with maximum total weight.

**This needs DP! Greedy by weight/length fails.**

```cpp
int maxWeight(vector<vector<int>>& intervals) {
    int n = intervals.size();
    
    // Sort by end time
    sort(intervals.begin(), intervals.end(), [](auto& a, auto& b) {
        return a[1] < b[1];
    });
    
    // dp[i] = max weight using intervals 0..i
    vector<int> dp(n);
    dp[0] = intervals[0][2];  // weight
    
    for (int i = 1; i < n; i++) {
        // Option 1: Don't take interval i
        int exclude = dp[i-1];
        
        // Option 2: Take interval i
        int include = intervals[i][2];
        
        // Find latest non-overlapping interval
        int j = i - 1;
        while (j >= 0 && intervals[j][1] > intervals[i][0]) {
            j--;
        }
        
        if (j >= 0) {
            include += dp[j];
        }
        
        dp[i] = max(include, exclude);
    }
    
    return dp[n-1];
}
```

---

## Huffman Coding

### What is Huffman Coding?

**Goal:** Compress data by assigning variable-length codes to characters.

**Key idea:** 
- Frequent characters get short codes
- Rare characters get long codes

**Greedy approach:** Build optimal prefix tree bottom-up.

### Huffman Algorithm

```cpp
struct Node {
    char ch;
    int freq;
    Node *left, *right;
    
    Node(char c, int f) : ch(c), freq(f), left(nullptr), right(nullptr) {}
};

struct Compare {
    bool operator()(Node* a, Node* b) {
        return a->freq > b->freq;  // Min heap by frequency
    }
};

Node* buildHuffmanTree(unordered_map<char, int>& freq) {
    priority_queue<Node*, vector<Node*>, Compare> minHeap;
    
    // Create leaf node for each character
    for (auto& [ch, f] : freq) {
        minHeap.push(new Node(ch, f));
    }
    
    // Build tree bottom-up
    while (minHeap.size() > 1) {
        // Take two nodes with smallest frequency
        Node* left = minHeap.top(); minHeap.pop();
        Node* right = minHeap.top(); minHeap.pop();
        
        // Create internal node with combined frequency
        Node* parent = new Node('\0', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        
        minHeap.push(parent);
    }
    
    return minHeap.top();  // Root of Huffman tree
}

void generateCodes(Node* root, string code, unordered_map<char, string>& codes) {
    if (!root) return;
    
    // Leaf node: save code
    if (!root->left && !root->right) {
        codes[root->ch] = code;
        return;
    }
    
    generateCodes(root->left, code + "0", codes);
    generateCodes(root->right, code + "1", codes);
}
```

**How it works:**
```
Text: "ABRACADABRA"

Frequencies:
  A: 5
  B: 2
  R: 2
  C: 1
  D: 1

Step 1: Create leaf nodes
  Heap: [C:1, D:1, B:2, R:2, A:5]

Step 2: Merge two smallest (C:1, D:1)
  Create internal node: freq=2
       [2]
       / \
      C   D
  Heap: [B:2, R:2, (C+D):2, A:5]

Step 3: Merge (B:2, R:2)
       [4]
       / \
      B   R
  Heap: [(C+D):2, (B+R):4, A:5]

Step 4: Merge (C+D):2, (B+R):4
       [6]
       / \
     [2] [4]
     / \  / \
    C  D B  R
  Heap: [(C+D+B+R):6, A:5]

Step 5: Merge all
         [11]
         /  \
       [5]  [6]
        A   / \
          [2] [4]
          / \  / \
         C  D B  R

Final tree (codes):
  A: 0
  C: 100
  D: 101
  B: 110
  R: 111

Encoding "ABRACADABRA":
  0 110 111 0 100 0 101 0 110 111 0
  = 25 bits (vs 11√ó8=88 bits with ASCII)
```

**Why greedy works:**

**Proof idea:**
1. Characters with lower frequency should be deeper in tree (longer codes)
2. Two lowest-frequency characters should be siblings (at deepest level)
3. Replacing them with parent node reduces problem size
4. Optimal substructure: Optimal tree for n chars contains optimal subtree for n-1 chars

**Visual:**
```
Original:           After merge:
  A:5                    A:5
  B:2                  [C+D]:2
  R:2                    B:2
  C:1                    R:2
  D:1

Merging lowest maintains optimality!
```

**Properties:**
- No code is prefix of another (prefix-free)
- Average code length is minimized
- Decoding is unambiguous

**Time:** O(n log n) where n = number of unique characters  
**Space:** O(n)

---

## Coin Change

### When Greedy Works

**Greedy works for coin systems with special property:**

**Canonical coin systems:** Each denomination is factor/multiple pattern.
- US coins: {1, 5, 10, 25} ‚úì
- Powers of 2: {1, 2, 4, 8, 16} ‚úì
- Arbitrary: {1, 3, 4} ‚úó

```cpp
int coinChangeGreedy(vector<int>& coins, int amount) {
    // Only works for canonical systems!
    sort(coins.rbegin(), coins.rend());  // Sort descending
    
    int count = 0;
    
    for (int coin : coins) {
        while (amount >= coin) {
            amount -= coin;
            count++;
        }
    }
    
    return amount == 0 ? count : -1;
}
```

**Example (works):**
```
Coins: [1, 5, 10, 25]
Amount: 41

Greedy:
  25: 41/25 = 1, use 1 quarter, remaining = 16
  10: 16/10 = 1, use 1 dime, remaining = 6
  5:  6/5 = 1, use 1 nickel, remaining = 1
  1:  1/1 = 1, use 1 penny, remaining = 0

Result: 4 coins ‚úì OPTIMAL
```

**Example (fails):**
```
Coins: [1, 3, 4]
Amount: 6

Greedy:
  4: 6/4 = 1, use 1√ó4, remaining = 2
  3: 2/3 = 0, skip
  1: 2/1 = 2, use 2√ó1, remaining = 0
  
  Result: 3 coins (4 + 1 + 1) ‚úó

Optimal (DP):
  3 + 3 = 2 coins ‚úì

Greedy FAILS!
```

### Coin Change with DP (Always Works)

```cpp
int coinChange(vector<int>& coins, int amount) {
    vector<int> dp(amount + 1, INT_MAX);
    dp[0] = 0;
    
    for (int i = 1; i <= amount; i++) {
        for (int coin : coins) {
            if (coin <= i && dp[i - coin] != INT_MAX) {
                dp[i] = min(dp[i], dp[i - coin] + 1);
            }
        }
    }
    
    return dp[amount] == INT_MAX ? -1 : dp[amount];
}
```

**When to use greedy vs DP:**

| Coin System | Greedy Works? | Use |
|-------------|---------------|-----|
| {1, 5, 10, 25} | ‚úì Yes | Greedy (O(n)) |
| {1, 2, 5, 10, 20, 50} | ‚úì Yes | Greedy |
| {1, 3, 4} | ‚úó No | DP (O(amount √ó n)) |
| {1, 6, 10} | ‚úó No | DP |
| Powers of k | ‚úì Yes | Greedy |

**Rule of thumb:** If each coin is multiple of smaller coins, greedy likely works.

---

## Advanced Greedy Patterns

### Pattern 1: Jump Game

**Problem:** Can reach last index? Each element is max jump length.

```cpp
bool canJump(vector<int>& nums) {
    int maxReach = 0;
    
    for (int i = 0; i < nums.size(); i++) {
        if (i > maxReach) return false;  // Can't reach here
        
        maxReach = max(maxReach, i + nums[i]);
        
        if (maxReach >= nums.size() - 1) return true;
    }
    
    return false;
}
```

**How it works:**
```
nums = [2, 3, 1, 1, 4]

i=0: maxReach = max(0, 0+2) = 2
i=1: maxReach = max(2, 1+3) = 4
     4 ‚â• 4 (last index) ‚úì

Answer: true
```

**Minimum jumps:**
```cpp
int jump(vector<int>& nums) {
    int jumps = 0;
    int currentEnd = 0;
    int farthest = 0;
    
    for (int i = 0; i < nums.size() - 1; i++) {
        farthest = max(farthest, i + nums[i]);
        
        if (i == currentEnd) {
            jumps++;
            currentEnd = farthest;
        }
    }
    
    return jumps;
}
```

**Example:**
```
nums = [2, 3, 1, 1, 4]

i=0: farthest=2, currentEnd=0
     i==0 (reached end of jump), jumps=1, currentEnd=2

i=1: farthest=max(2, 1+3)=4
i=2: i==currentEnd, jumps=2, currentEnd=4

Answer: 2 jumps (0‚Üí1‚Üí4)
```

### Pattern 2: Gas Station

**Problem:** Find starting station to complete circle.

```cpp
int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
    int totalGas = 0, totalCost = 0;
    int tank = 0, start = 0;
    
    for (int i = 0; i < gas.size(); i++) {
        totalGas += gas[i];
        totalCost += cost[i];
        tank += gas[i] - cost[i];
        
        // If tank negative, can't start from any station up to i
        if (tank < 0) {
            start = i + 1;
            tank = 0;
        }
    }
    
    // If total gas < total cost, impossible
    return totalGas >= totalCost ? start : -1;
}
```

**Why this works:**
```
Key insight: If total gas ‚â• total cost, solution exists!

If we fail starting from station i (run out at station j):
  - Can't start from any station i to j (all fail earlier)
  - Try starting from j+1

Proof: If A‚ÜíB fails and total is enough, then B‚ÜíA must succeed
```

### Pattern 3: Partition Labels

**Problem:** Partition string so each letter appears in at most one part.

```cpp
vector<int> partitionLabels(string s) {
    // Record last occurrence of each character
    unordered_map<char, int> last;
    for (int i = 0; i < s.size(); i++) {
        last[s[i]] = i;
    }
    
    vector<int> result;
    int start = 0, end = 0;
    
    for (int i = 0; i < s.size(); i++) {
        end = max(end, last[s[i]]);  // Extend partition
        
        if (i == end) {  // Reached end of partition
            result.push_back(end - start + 1);
            start = i + 1;
        }
    }
    
    return result;
}
```

**How it works:**
```
s = "ababcbacadefegdehijhklij"

Last occurrence:
  a: 8, b: 5, c: 7, d: 14, e: 15, ...

Process:
  i=0 (a): end = max(0, 8) = 8
  i=1 (b): end = max(8, 5) = 8
  ...
  i=8 (a): end = 8, i==end ‚úì
    Partition [0,8]: "ababcbaca" (length 9)

  i=9 (d): end = max(9, 14) = 14
  ...
  i=15 (e): i==end ‚úì
    Partition [9,15]: "defegde" (length 7)

  ...

Result: [9, 7, 8]
```

### Pattern 4: Remove K Digits

**Problem:** Remove k digits to get smallest number.

```cpp
string removeKdigits(string num, int k) {
    string result;
    
    for (char digit : num) {
        // Remove larger digits from end
        while (!result.empty() && k > 0 && result.back() > digit) {
            result.pop_back();
            k--;
        }
        result.push_back(digit);
    }
    
    // Remove remaining k digits from end
    while (k > 0) {
        result.pop_back();
        k--;
    }
    
    // Remove leading zeros
    int start = 0;
    while (start < result.size() && result[start] == '0') {
        start++;
    }
    
    result = result.substr(start);
    
    return result.empty() ? "0" : result;
}
```

**Example:**
```
num = "1432219", k = 3

Process:
  Add '1': result = "1"
  Add '4': result = "14"
  Add '3': 4 > 3 and k > 0, remove '4'
    result = "13", k = 2
  Add '2': 3 > 2 and k > 0, remove '3'
    result = "12", k = 1
  Add '2': result = "122"
  Add '1': 2 > 1 and k > 0, remove '2'
    result = "121", k = 0
  Add '9': result = "1219"

Answer: "1219"
```

### Pattern 5: Wiggle Subsequence

**Problem:** Find longest subsequence where differences alternate.

```cpp
int wiggleMaxLength(vector<int>& nums) {
    if (nums.size() < 2) return nums.size();
    
    int up = 1, down = 1;
    
    for (int i = 1; i < nums.size(); i++) {
        if (nums[i] > nums[i-1]) {
            up = down + 1;
        } else if (nums[i] < nums[i-1]) {
            down = up + 1;
        }
    }
    
    return max(up, down);
}
```

**How it works:**
```
nums = [1, 7, 4, 9, 2, 5]

i=1: 7 > 1 (up), up = down + 1 = 2
     up=2, down=1

i=2: 4 < 7 (down), down = up + 1 = 3
     up=2, down=3

i=3: 9 > 4 (up), up = down + 1 = 4
     up=4, down=3

i=4: 2 < 9 (down), down = up + 1 = 5
     up=4, down=5

i=5: 5 > 2 (up), up = down + 1 = 6
     up=6, down=5

Answer: 6 (entire sequence is wiggle)
```

---

## Common Problems

### Problem 1: Assign Cookies

```cpp
int findContentChildren(vector<int>& g, vector<int>& s) {
    sort(g.begin(), g.end());  // Greed factors
    sort(s.begin(), s.end());  // Cookie sizes
    
    int child = 0, cookie = 0;
    
    while (child < g.size() && cookie < s.size()) {
        if (s[cookie] >= g[child]) {
            child++;  // Satisfied
        }
        cookie++;
    }
    
    return child;
}
```

### Problem 2: Best Time to Buy and Sell Stock II

```cpp
int maxProfit(vector<int>& prices) {
    int profit = 0;
    
    for (int i = 1; i < prices.size(); i++) {
        // Take every positive difference
        if (prices[i] > prices[i-1]) {
            profit += prices[i] - prices[i-1];
        }
    }
    
    return profit;
}
```

**Why this works:**
```
prices = [7, 1, 5, 3, 6, 4]

Profit opportunities:
  1‚Üí5: +4
  3‚Üí6: +3
  
Total: 7

Greedy: Sum all increases
  5-1 = 4
  6-3 = 3
  Total: 7 ‚úì

Equivalent to buying at every valley, selling at every peak!
```

### Problem 3: Boats to Save People

```cpp
int numRescueBoats(vector<int>& people, int limit) {
    sort(people.begin(), people.end());
    
    int left = 0, right = people.size() - 1;
    int boats = 0;
    
    while (left <= right) {
        if (people[left] + people[right] <= limit) {
            left++;  // Pair lightest with heaviest
        }
        right--;  // Heaviest always goes
        boats++;
    }
    
    return boats;
}
```

### Problem 4: Task Scheduler

**Greedy with frequency:**
```cpp
int leastInterval(vector<char>& tasks, int n) {
    vector<int> freq(26, 0);
    for (char task : tasks) {
        freq[task - 'A']++;
    }
    
    sort(freq.rbegin(), freq.rend());
    
    int maxFreq = freq[0];
    int idleSlots = (maxFreq - 1) * n;
    
    for (int i = 1; i < 26 && freq[i] > 0; i++) {
        idleSlots -= min(freq[i], maxFreq - 1);
    }
    
    return tasks.size() + max(0, idleSlots);
}
```

---

## Summary Tables

### Greedy vs DP

| Problem | Greedy | DP | Why |
|---------|--------|----|-----|
| Activity selection | ‚úì | ‚ùå | Earliest finish optimal |
| Fractional knapsack | ‚úì | ‚ùå | Take highest value/weight |
| 0/1 Knapsack | ‚ùå | ‚úì | Can't split items |
| Coin change (canonical) | ‚úì | ‚ùå | Each coin is multiple |
| Coin change (arbitrary) | ‚ùå | ‚úì | Greedy suboptimal |
| Huffman coding | ‚úì | ‚ùå | Merge smallest optimal |

### Interval Problems

| Problem | Sort By | Strategy | Time |
|---------|---------|----------|------|
| Max non-overlapping | End time | Pick earliest finish | O(n log n) |
| Min groups | Start time | Heap of end times | O(n log n) |
| Weighted intervals | End time | DP (not greedy!) | O(n¬≤) or O(n log n) |
| Can attend all | Start time | Check overlaps | O(n log n) |

### Greedy Proof Techniques

| Technique | When to Use |
|-----------|-------------|
| **Exchange argument** | Show swapping greedy choice maintains optimality |
| **Staying ahead** | Show greedy is always ‚â• any other solution |
| **Structural induction** | Prove by building optimal solution incrementally |

---

## Practice Problems

### Intervals
- [ ] Non-overlapping Intervals
- [ ] Minimum Number of Arrows to Burst Balloons
- [ ] Meeting Rooms I & II
- [ ] Merge Intervals
- [ ] Insert Interval

### Greedy Choice
- [ ] Jump Game I & II
- [ ] Gas Station
- [ ] Candy
- [ ] Assign Cookies
- [ ] Partition Labels

### Scheduling
- [ ] Task Scheduler
- [ ] Course Schedule III
- [ ] Single-Threaded CPU
- [ ] Maximum CPU Load

### Advanced
- [ ] Remove K Digits
- [ ] Create Maximum Number
- [ ] Wiggle Subsequence
- [ ] Minimum Number of Refueling Stops
- [ ] Video Stitching

---

## Key Takeaways

1. **Greedy = local optimum ‚Üí global optimum** - But doesn't always work!
2. **Interval scheduling: sort by END time** - Earliest finish leaves most room
3. **Interval partitioning: sort by START time** - Use heap for end times
4. **Huffman: merge smallest frequencies** - Builds optimal prefix tree
5. **Coin change: greedy works for canonical systems** - US coins, powers, etc.
6. **Prove greedy with exchange argument** - Show swapping maintains optimality
7. **Jump game: track maximum reachable** - O(n) greedy solution
8. **Meeting rooms: two approaches** - Two pointers or heap (both O(n log n))
9. **When greedy fails, try DP** - Weighted intervals, arbitrary coins
10. **Sort first almost always** - Enables greedy decisions

Master these greedy patterns and recognize when local choices lead to global optimality! üéØ

