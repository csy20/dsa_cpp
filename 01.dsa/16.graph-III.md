# Graph III - Advanced Graph Algorithms

## Table of Contents
1. [Critical Connections Overview](#critical-connections-overview)
2. [Bridges (Critical Edges)](#bridges-critical-edges)
3. [Articulation Points (Cut Vertices)](#articulation-points-cut-vertices)
4. [Strongly Connected Components (SCC)](#strongly-connected-components-scc)
5. [Kosaraju's Algorithm](#kosarajus-algorithm)
6. [Tarjan's Algorithm for SCC](#tarjans-algorithm-for-scc)
7. [Tarjan's Algorithm for Bridges](#tarjans-algorithm-for-bridges)
8. [Euler Tour Technique](#euler-tour-technique)
9. [Euler Tour for Trees](#euler-tour-for-trees)
10. [Flattening Trees to Arrays](#flattening-trees-to-arrays)
11. [Range Queries on Trees](#range-queries-on-trees)
12. [Common Problems](#common-problems)

---

## Critical Connections Overview

### Definitions

**Bridge (Critical Edge):** Edge whose removal increases number of connected components.

**Articulation Point (Cut Vertex):** Vertex whose removal increases number of connected components.

**Visual:**
```
Graph:
    0 --- 1 --- 2
          |
          3 --- 4

Bridges: (0,1), (2,1), (1,3), (3,4)
  Removing any disconnects graph

Articulation points: 1, 3
  Removing 1: {0} {2} {3,4} (3 components)
  Removing 3: {0,1,2} {4} (2 components)
```

**Non-example:**
```
Graph (cycle):
    0 --- 1
    |     |
    3 --- 2

No bridges: Can reach any vertex via alternate path
No articulation points: Graph stays connected
```

**Applications:**
- Network vulnerability analysis
- Road/bridge infrastructure
- Circuit design
- Social network analysis

---

## Bridges (Critical Edges)

### How to Find Bridges

**Naive approach:** Remove each edge, check if connected. O(E(V+E)) - too slow!

**Tarjan's approach:** DFS with discovery times and low values. O(V+E)!

**Key idea:**
- `disc[u]`: Discovery time of vertex u
- `low[u]`: Minimum discovery time reachable from u via back edges

**Bridge condition:** Edge (u,v) is a bridge if:
```
low[v] > disc[u]
```

**Why this works:**
```
If low[v] > disc[u]:
  v cannot reach any ancestor of u using back edges
  ‚Üí Only path from u to v is the edge (u,v)
  ‚Üí Removing (u,v) disconnects u and v
  ‚Üí (u,v) is a bridge!

If low[v] <= disc[u]:
  v can reach u or ancestor of u via back edge
  ‚Üí Alternate path exists
  ‚Üí Not a bridge
```

### Implementation

```cpp
class BridgeFinder {
    vector<vector<int>> adj;
    vector<int> disc, low;
    vector<bool> visited;
    vector<pair<int,int>> bridges;
    int timer;
    
    void dfs(int u, int parent) {
        visited[u] = true;
        disc[u] = low[u] = timer++;
        
        for (int v : adj[u]) {
            if (v == parent) continue;  // Skip parent edge
            
            if (visited[v]) {
                // Back edge: update low value
                low[u] = min(low[u], disc[v]);
            } else {
                // Tree edge: recurse
                dfs(v, u);
                
                // Update low value from child
                low[u] = min(low[u], low[v]);
                
                // Check bridge condition
                if (low[v] > disc[u]) {
                    bridges.push_back({u, v});
                }
            }
        }
    }
    
public:
    vector<pair<int,int>> findBridges(vector<vector<int>>& graph) {
        int n = graph.size();
        adj = graph;
        disc.resize(n);
        low.resize(n);
        visited.resize(n, false);
        timer = 0;
        
        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                dfs(i, -1);
            }
        }
        
        return bridges;
    }
};
```

### Complete Trace

```
Graph:
    0 --- 1 --- 2
          |
          3

adj[0] = [1]
adj[1] = [0, 2, 3]
adj[2] = [1]
adj[3] = [1]

DFS from 0:

Call dfs(0, -1):
  disc[0] = 0, low[0] = 0, timer = 1
  Neighbors: [1]
  
  Call dfs(1, 0):
    disc[1] = 1, low[1] = 1, timer = 2
    Neighbors: [0, 2, 3]
    
    Skip 0 (parent)
    
    Call dfs(2, 1):
      disc[2] = 2, low[2] = 2, timer = 3
      Neighbors: [1]
      
      Skip 1 (parent)
      
      Return: low[2] = 2
    
    Back in dfs(1):
      low[1] = min(low[1], low[2]) = min(1, 2) = 1
      Check bridge: low[2] > disc[1]?
        2 > 1? YES ‚Üí (1,2) is a bridge ‚úì
    
    Call dfs(3, 1):
      disc[3] = 3, low[3] = 3, timer = 4
      Neighbors: [1]
      
      Skip 1 (parent)
      
      Return: low[3] = 3
    
    Back in dfs(1):
      low[1] = min(low[1], low[3]) = min(1, 3) = 1
      Check bridge: low[3] > disc[1]?
        3 > 1? YES ‚Üí (1,3) is a bridge ‚úì
    
    Return: low[1] = 1
  
  Back in dfs(0):
    low[0] = min(low[0], low[1]) = min(0, 1) = 0
    Check bridge: low[1] > disc[0]?
      1 > 0? YES ‚Üí (0,1) is a bridge ‚úì

Final state:
  disc = [0, 1, 2, 3]
  low  = [0, 1, 2, 3]
  
Bridges: (0,1), (1,2), (1,3)
```

**Visual with discovery/low times:**
```
    0 --- 1 --- 2
    0/0   1/1   2/2
          |
          3
          3/3

disc[u]/low[u]

All edges are bridges because no back edges exist!
```

**Example with cycle (no bridges):**
```
Graph:
    0 --- 1
    |     |
    3 --- 2

DFS from 0:
  disc[0] = 0, low[0] = 0
  
  dfs(1, 0):
    disc[1] = 1, low[1] = 1
    
    dfs(2, 1):
      disc[2] = 2, low[2] = 2
      
      dfs(3, 2):
        disc[3] = 3, low[3] = 3
        
        Visit 0: visited! Back edge!
        low[3] = min(low[3], disc[0]) = min(3, 0) = 0
        
        Return: low[3] = 0
      
      low[2] = min(low[2], low[3]) = min(2, 0) = 0
      Check: low[3] > disc[2]? 0 > 2? NO (not a bridge)
      
      Return: low[2] = 0
    
    low[1] = min(low[1], low[2]) = min(1, 0) = 0
    Check: low[2] > disc[1]? 0 > 1? NO (not a bridge)
    
    Return: low[1] = 0
  
  low[0] = min(low[0], low[1]) = min(0, 0) = 0
  Check: low[1] > disc[0]? 0 > 0? NO (not a bridge)

Bridges: [] (none!)

disc = [0, 1, 2, 3]
low  = [0, 0, 0, 0]  ‚Üê All can reach vertex 0!
```

**Time:** O(V + E)  
**Space:** O(V)

---

## Articulation Points (Cut Vertices)

### How to Find Articulation Points

**Similar to bridges, but conditions differ.**

**Articulation point conditions:**

**1. Root of DFS tree:** Articulation point if it has ‚â• 2 children.
```
    0 (root)
   / \
  1   2

Removing 0 disconnects {1} and {2}
```

**2. Non-root vertex u:** Articulation point if it has a child v where:
```
low[v] >= disc[u]
```

**Why this works:**
```
If low[v] >= disc[u]:
  v cannot reach any proper ancestor of u
  ‚Üí All paths from v's subtree to ancestors pass through u
  ‚Üí Removing u disconnects v's subtree
  ‚Üí u is articulation point!
```

### Implementation

```cpp
class ArticulationPointFinder {
    vector<vector<int>> adj;
    vector<int> disc, low;
    vector<bool> visited, isAP;
    int timer;
    
    void dfs(int u, int parent) {
        visited[u] = true;
        disc[u] = low[u] = timer++;
        int children = 0;
        
        for (int v : adj[u]) {
            if (v == parent) continue;
            
            if (visited[v]) {
                low[u] = min(low[u], disc[v]);
            } else {
                children++;
                dfs(v, u);
                low[u] = min(low[u], low[v]);
                
                // Check articulation point conditions
                if (parent == -1 && children > 1) {
                    // Root with multiple children
                    isAP[u] = true;
                }
                
                if (parent != -1 && low[v] >= disc[u]) {
                    // Non-root: child can't reach ancestor
                    isAP[u] = true;
                }
            }
        }
    }
    
public:
    vector<int> findArticulationPoints(vector<vector<int>>& graph) {
        int n = graph.size();
        adj = graph;
        disc.resize(n);
        low.resize(n);
        visited.resize(n, false);
        isAP.resize(n, false);
        timer = 0;
        
        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                dfs(i, -1);
            }
        }
        
        vector<int> result;
        for (int i = 0; i < n; i++) {
            if (isAP[i]) result.push_back(i);
        }
        return result;
    }
};
```

### Complete Trace

```
Graph:
    0 --- 1 --- 2
          |
          3 --- 4

DFS from 0:

Call dfs(0, -1):
  disc[0] = 0, low[0] = 0, children = 0
  Neighbors: [1]
  
  Call dfs(1, 0):
    disc[1] = 1, low[1] = 1, children = 0
    Neighbors: [0, 2, 3]
    
    Skip 0 (parent)
    
    Call dfs(2, 1):
      disc[2] = 2, low[2] = 2, children = 0
      Neighbors: [1]
      Skip 1 (parent)
      Return: low[2] = 2
    
    children = 1
    low[1] = min(low[1], low[2]) = min(1, 2) = 1
    Check: parent != -1 && low[2] >= disc[1]?
      true && (2 >= 1)? YES ‚Üí isAP[1] = true ‚úì
    
    Call dfs(3, 1):
      disc[3] = 3, low[3] = 3, children = 0
      Neighbors: [1, 4]
      
      Skip 1 (parent)
      
      Call dfs(4, 3):
        disc[4] = 4, low[4] = 4, children = 0
        Neighbors: [3]
        Skip 3 (parent)
        Return: low[4] = 4
      
      children = 1
      low[3] = min(low[3], low[4]) = min(3, 4) = 3
      Check: parent != -1 && low[4] >= disc[3]?
        true && (4 >= 3)? YES ‚Üí isAP[3] = true ‚úì
      
      Return: low[3] = 3
    
    children = 2
    low[1] = min(low[1], low[3]) = min(1, 3) = 1
    Check: parent != -1 && low[3] >= disc[1]?
      true && (3 >= 1)? YES ‚Üí isAP[1] = true (already set)
    
    Return: low[1] = 1
  
  children = 1
  low[0] = min(low[0], low[1]) = min(0, 1) = 0
  Check: parent == -1 && children > 1?
    false && false? NO ‚Üí isAP[0] = false

Articulation points: [1, 3]

Verification:
  Remove 1: {0} {2} {3,4} ‚Üí 3 components ‚úì
  Remove 3: {0,1,2} {4} ‚Üí 2 components ‚úì
```

**Time:** O(V + E)  
**Space:** O(V)

---

## Strongly Connected Components (SCC)

### What are SCCs?

**Strongly Connected Component:** Maximal set of vertices where every vertex can reach every other vertex.

**Only for directed graphs!**

**Visual:**
```
Graph:
    0 ‚Üí 1 ‚Üí 2
    ‚Üë   ‚Üì   ‚Üì
    4 ‚Üê 3 ‚Üê 2

SCCs:
  {0, 1, 3, 4} - all can reach each other
  {2} - can't reach back to others

Check {0,1,3,4}:
  0‚Üí1? Yes (0‚Üí1)
  1‚Üí0? Yes (1‚Üí3‚Üí4‚Üí0)
  1‚Üí3? Yes (1‚Üí3)
  3‚Üí1? Yes (3‚Üí4‚Üí0‚Üí1)
  ... all pairs connected ‚úì
```

**Applications:**
- Call graph analysis
- Recommendation systems
- Compiler optimization
- Web page ranking

**Two main algorithms:**
1. **Kosaraju's:** Two DFS passes, easy to understand
2. **Tarjan's:** One DFS pass, more complex but faster

---

## Kosaraju's Algorithm

### How Kosaraju Works

**Key insight:** SCCs are the same in G and G^T (transpose graph).

**Algorithm:**
```
1. DFS on original graph, record finish times
2. Create transpose graph (reverse all edges)
3. DFS on transpose in decreasing finish time order
4. Each DFS tree in step 3 is one SCC
```

**Why it works:**
```
Step 1: Orders vertices by "leadership"
  - Vertices finishing last are in "source" SCCs

Step 3: DFS from source SCCs first
  - In transpose, can only reach vertices in same SCC
  - Each DFS tree = one SCC!

Proof sketch:
  If u, v in same SCC of G:
    - u can reach v in G
    - v can reach u in G
  Then in G^T:
    - v can reach u in G^T (reversed u‚Üív)
    - u can reach v in G^T (reversed v‚Üíu)
  So same SCC in G^T!
```

### Implementation

```cpp
class KosarajuSCC {
    vector<vector<int>> adj, adjRev;
    vector<bool> visited;
    stack<int> finishStack;
    vector<vector<int>> sccs;
    
    void dfs1(int u) {
        visited[u] = true;
        
        for (int v : adj[u]) {
            if (!visited[v]) {
                dfs1(v);
            }
        }
        
        finishStack.push(u);  // Add after visiting all descendants
    }
    
    void dfs2(int u, vector<int>& component) {
        visited[u] = true;
        component.push_back(u);
        
        for (int v : adjRev[u]) {
            if (!visited[v]) {
                dfs2(v, component);
            }
        }
    }
    
public:
    vector<vector<int>> findSCCs(vector<vector<int>>& graph) {
        int n = graph.size();
        adj = graph;
        visited.resize(n, false);
        
        // Step 1: DFS on original graph
        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                dfs1(i);
            }
        }
        
        // Step 2: Create transpose graph
        adjRev.resize(n);
        for (int u = 0; u < n; u++) {
            for (int v : adj[u]) {
                adjRev[v].push_back(u);  // Reverse edge
            }
        }
        
        // Step 3: DFS on transpose in reverse finish order
        fill(visited.begin(), visited.end(), false);
        
        while (!finishStack.empty()) {
            int u = finishStack.top();
            finishStack.pop();
            
            if (!visited[u]) {
                vector<int> component;
                dfs2(u, component);
                sccs.push_back(component);
            }
        }
        
        return sccs;
    }
};
```

### Complete Trace

```
Graph:
    0 ‚Üí 1 ‚Üí 2
    ‚Üë   ‚Üì
    3 ‚Üê 4

adj[0] = [1]
adj[1] = [2, 4]
adj[2] = []
adj[3] = [0]
adj[4] = [3]

Step 1: DFS from 0

dfs1(0):
  Visit 0
  dfs1(1):
    Visit 1
    dfs1(2):
      Visit 2, no neighbors
      Push 2 to stack
    dfs1(4):
      Visit 4
      dfs1(3):
        Visit 3
        0 already visited
        Push 3 to stack
      Push 4 to stack
    Push 1 to stack
  Push 0 to stack

Finish stack (bottom to top): [2, 3, 4, 1, 0]
Finish order: 2, 3, 4, 1, 0

Step 2: Create transpose

Original:          Transpose:
  0 ‚Üí 1              0 ‚Üê 1
  ‚Üë   ‚Üì              ‚Üì   ‚Üë
  3 ‚Üê 4              3 ‚Üí 4
      ‚Üì                  ‚Üì
      2                  2

adjRev[0] = [3]
adjRev[1] = [0]
adjRev[2] = [1]
adjRev[3] = [4]
adjRev[4] = [1]

Step 3: DFS on transpose in reverse finish order

Pop 0: Not visited
  dfs2(0):
    Visit 0
    dfs2(3):
      Visit 3
      dfs2(4):
        Visit 4
        dfs2(1):
          Visit 1
          0 already visited
        Component: [0, 3, 4, 1]
  SCC 1: [0, 3, 4, 1]

Pop 1: Already visited, skip

Pop 4: Already visited, skip

Pop 3: Already visited, skip

Pop 2: Not visited
  dfs2(2):
    Visit 2
    1 already visited
    Component: [2]
  SCC 2: [2]

SCCs: [[0, 3, 4, 1], [2]]
```

**Verification:**
```
SCC 1: {0, 1, 3, 4}
  0‚Üí1? Yes (0‚Üí1)
  1‚Üí0? Yes (1‚Üí4‚Üí3‚Üí0)
  0‚Üí3? Yes (0‚Üí1‚Üí4‚Üí3)
  3‚Üí0? Yes (3‚Üí0)
  ... all pairs connected ‚úì

SCC 2: {2}
  2 can't reach any other vertex ‚úì
```

**Time:** O(V + E)  
**Space:** O(V)

---

## Tarjan's Algorithm for SCC

### How Tarjan Works

**Key idea:** Single DFS pass with stack and low values.

**Variables:**
- `disc[u]`: Discovery time
- `low[u]`: Minimum discovery time reachable via subtree + one back edge
- `onStack[u]`: Is u currently on stack?
- `stack`: Vertices in current DFS path

**SCC root detection:** `low[u] == disc[u]`
- u is root of SCC
- Pop stack until u to get SCC

**Why it works:**
```
If low[u] == disc[u]:
  - u can't reach any vertex discovered before u
  - All vertices that can reach u are in u's subtree
  - All vertices in stack after u belong to u's SCC
```

### Implementation

```cpp
class TarjanSCC {
    vector<vector<int>> adj;
    vector<int> disc, low;
    vector<bool> onStack;
    stack<int> st;
    vector<vector<int>> sccs;
    int timer;
    
    void dfs(int u) {
        disc[u] = low[u] = timer++;
        st.push(u);
        onStack[u] = true;
        
        for (int v : adj[u]) {
            if (disc[v] == -1) {
                // Tree edge
                dfs(v);
                low[u] = min(low[u], low[v]);
            } else if (onStack[v]) {
                // Back edge to vertex in current SCC
                low[u] = min(low[u], disc[v]);
            }
            // Forward/cross edge to completed SCC: ignore
        }
        
        // Check if u is root of SCC
        if (low[u] == disc[u]) {
            vector<int> component;
            while (true) {
                int v = st.top();
                st.pop();
                onStack[v] = false;
                component.push_back(v);
                if (v == u) break;
            }
            sccs.push_back(component);
        }
    }
    
public:
    vector<vector<int>> findSCCs(vector<vector<int>>& graph) {
        int n = graph.size();
        adj = graph;
        disc.resize(n, -1);
        low.resize(n, -1);
        onStack.resize(n, false);
        timer = 0;
        
        for (int i = 0; i < n; i++) {
            if (disc[i] == -1) {
                dfs(i);
            }
        }
        
        return sccs;
    }
};
```

### Complete Trace

```
Graph:
    0 ‚Üí 1 ‚Üí 2
    ‚Üë   ‚Üì
    3 ‚Üê 4

DFS from 0:

dfs(0):
  disc[0] = 0, low[0] = 0, timer = 1
  Push 0 to stack: [0]
  onStack[0] = true
  
  Neighbors: [1]
  
  dfs(1):
    disc[1] = 1, low[1] = 1, timer = 2
    Push 1 to stack: [0, 1]
    onStack[1] = true
    
    Neighbors: [2, 4]
    
    dfs(2):
      disc[2] = 2, low[2] = 2, timer = 3
      Push 2 to stack: [0, 1, 2]
      onStack[2] = true
      
      No neighbors
      
      Check: low[2] == disc[2]? 2 == 2? YES
      Pop stack until 2:
        Pop 2: component = [2]
      SCC: [2]
      onStack[2] = false
    
    low[1] = min(low[1], low[2]) = min(1, 2) = 1
    
    dfs(4):
      disc[4] = 3, low[4] = 3, timer = 4
      Push 4 to stack: [0, 1, 4]
      onStack[4] = true
      
      Neighbors: [3]
      
      dfs(3):
        disc[3] = 4, low[3] = 4, timer = 5
        Push 3 to stack: [0, 1, 4, 3]
        onStack[3] = true
        
        Neighbors: [0]
        
        0 already visited, onStack[0] = true
        Back edge! low[3] = min(low[3], disc[0]) = min(4, 0) = 0
        
        Check: low[3] == disc[3]? 0 == 4? NO
      
      low[4] = min(low[4], low[3]) = min(3, 0) = 0
      
      Check: low[4] == disc[4]? 0 == 3? NO
    
    low[1] = min(low[1], low[4]) = min(1, 0) = 0
    
    Check: low[1] == disc[1]? 0 == 1? NO
  
  low[0] = min(low[0], low[1]) = min(0, 0) = 0
  
  Check: low[0] == disc[0]? 0 == 0? YES
  Pop stack until 0:
    Pop 3: component = [3]
    Pop 4: component = [3, 4]
    Pop 1: component = [3, 4, 1]
    Pop 0: component = [3, 4, 1, 0]
  SCC: [3, 4, 1, 0]

SCCs: [[2], [3, 4, 1, 0]]
  Or: [[2], [0, 1, 4, 3]] (reverse order)
```

**Visual with disc/low:**
```
    0 ‚Üí 1 ‚Üí 2
    0/0 1/0 2/2
    ‚Üë   ‚Üì
    3 ‚Üê 4
    4/0 3/0

disc[u]/low[u]

Vertices with low=0: {0,1,3,4} form SCC
Vertex 2 has low=2 (separate SCC)
```

**Time:** O(V + E)  
**Space:** O(V)

---

## Tarjan's Algorithm for Bridges

### Differences from Articulation Points

**Already covered in Bridges section!**

**Quick recap:**
- `low[u]`: Minimum discovery time reachable from u
- Edge (u,v) is bridge if `low[v] > disc[u]`
- No alternate path exists

**Key difference from SCC Tarjan:**
```
SCC Tarjan: low[v] updated from onStack vertices
Bridge Tarjan: low[v] updated from all back edges
```

---

## Euler Tour Technique

### What is Euler Tour?

**Euler path:** Path that visits every **edge** exactly once.

**Euler cycle:** Euler path that starts and ends at same vertex.

**Existence conditions:**

**Undirected graph:**
- Euler cycle: All vertices have even degree
- Euler path: Exactly 0 or 2 vertices have odd degree

**Directed graph:**
- Euler cycle: All vertices have in-degree = out-degree
- Euler path: At most one vertex with out-deg - in-deg = 1, one with in-deg - out-deg = 1

**Visual:**
```
Euler cycle exists:
    0 --- 1
    |     |
    3 --- 2

All vertices have degree 2 (even) ‚úì
Path: 0‚Üí1‚Üí2‚Üí3‚Üí0

No Euler cycle:
    0 --- 1 --- 2
          |
          3

Vertex 1 has degree 3 (odd) ‚úó
```

### Hierholzer's Algorithm

```cpp
vector<int> findEulerPath(vector<vector<int>>& adj) {
    int n = adj.size();
    
    // Find start vertex (odd degree or any)
    int start = 0;
    for (int i = 0; i < n; i++) {
        if (adj[i].size() % 2 == 1) {
            start = i;
            break;
        }
    }
    
    stack<int> st;
    vector<int> path;
    
    st.push(start);
    
    while (!st.empty()) {
        int u = st.top();
        
        if (!adj[u].empty()) {
            int v = adj[u].back();
            adj[u].pop_back();
            
            // Remove reverse edge (undirected)
            adj[v].erase(find(adj[v].begin(), adj[v].end(), u));
            
            st.push(v);
        } else {
            path.push_back(u);
            st.pop();
        }
    }
    
    reverse(path.begin(), path.end());
    return path;
}
```

**Time:** O(E)

---

## Euler Tour for Trees

### Flatten Tree to Array

**Different from Euler path! This is a technique for tree queries.**

**Idea:** DFS traversal records entry and exit times.

**Uses:**
- Subtree queries
- Path queries (with LCA)
- Range updates on subtrees

### How It Works

**DFS records two times for each vertex:**
- `in[u]`: Entry time (when first visiting u)
- `out[u]`: Exit time (when leaving u)

**Property:** Subtree of u = vertices with `in[v] ‚àà [in[u], out[u]]`

**Visual:**
```
Tree:
      0
     / \
    1   2
   / \
  3   4

DFS traversal:
  Visit 0 (in[0] = 0)
    Visit 1 (in[1] = 1)
      Visit 3 (in[3] = 2)
      Leave 3 (out[3] = 3)
      Visit 4 (in[4] = 4)
      Leave 4 (out[4] = 5)
    Leave 1 (out[1] = 6)
    Visit 2 (in[2] = 7)
    Leave 2 (out[2] = 8)
  Leave 0 (out[0] = 9)

Times:
  Vertex: 0  1  2  3  4
  in:     0  1  7  2  4
  out:    9  6  8  3  5

Subtree of 1: vertices with in ‚àà [1, 6]
  ‚Üí {1, 3, 4} ‚úì
```

### Implementation

```cpp
class EulerTour {
    vector<vector<int>> adj;
    vector<int> euler;      // Flattened tree
    vector<int> in, out;    // Entry/exit times
    int timer;
    
    void dfs(int u, int parent) {
        in[u] = timer++;
        euler.push_back(u);
        
        for (int v : adj[u]) {
            if (v != parent) {
                dfs(v, u);
            }
        }
        
        out[u] = timer - 1;
    }
    
public:
    void build(vector<vector<int>>& tree, int root = 0) {
        int n = tree.size();
        adj = tree;
        in.resize(n);
        out.resize(n);
        timer = 0;
        
        dfs(root, -1);
    }
    
    // Get all vertices in subtree of u
    vector<int> getSubtree(int u) {
        return vector<int>(euler.begin() + in[u], 
                          euler.begin() + out[u] + 1);
    }
    
    int getIn(int u) { return in[u]; }
    int getOut(int u) { return out[u]; }
};
```

### Complete Trace

```
Tree:
      0
     / \
    1   2
   /|
  3 4

DFS from 0:

dfs(0, -1):
  in[0] = 0, timer = 1
  euler = [0]
  
  dfs(1, 0):
    in[1] = 1, timer = 2
    euler = [0, 1]
    
    dfs(3, 1):
      in[3] = 2, timer = 3
      euler = [0, 1, 3]
      No children
      out[3] = 2
    
    dfs(4, 1):
      in[4] = 3, timer = 4
      euler = [0, 1, 3, 4]
      No children
      out[4] = 3
    
    out[1] = 3
  
  dfs(2, 0):
    in[2] = 4, timer = 5
    euler = [0, 1, 3, 4, 2]
    No children
    out[2] = 4
  
  out[0] = 4

Final:
  in  = [0, 1, 4, 2, 3]
  out = [4, 3, 4, 2, 3]
  euler = [0, 1, 3, 4, 2]

Subtree ranges:
  0: [0, 4] ‚Üí {0, 1, 3, 4, 2} (all)
  1: [1, 3] ‚Üí {1, 3, 4}
  2: [4, 4] ‚Üí {2}
  3: [2, 2] ‚Üí {3}
  4: [3, 3] ‚Üí {4}
```

---

## Flattening Trees to Arrays

### Why Flatten?

**Convert tree queries to array range queries!**

**Benefits:**
- Use segment trees, BIT, etc.
- O(log n) queries instead of O(n)
- Subtree updates become range updates

### Subtree Sum Queries

```cpp
class SubtreeSumQueries {
    vector<vector<int>> adj;
    vector<int> values;
    vector<int> flatValues;  // Values in Euler tour order
    vector<int> in, out;
    int timer;
    
    void dfs(int u, int parent) {
        in[u] = timer++;
        flatValues.push_back(values[u]);
        
        for (int v : adj[u]) {
            if (v != parent) {
                dfs(v, u);
            }
        }
        
        out[u] = timer - 1;
    }
    
public:
    void build(vector<vector<int>>& tree, vector<int>& nodeValues) {
        int n = tree.size();
        adj = tree;
        values = nodeValues;
        in.resize(n);
        out.resize(n);
        timer = 0;
        
        dfs(0, -1);
    }
    
    // Sum of all values in subtree of u
    // Can use segment tree or BIT for O(log n)
    int subtreeSum(int u) {
        int sum = 0;
        for (int i = in[u]; i <= out[u]; i++) {
            sum += flatValues[i];
        }
        return sum;
    }
};
```

**Example:**
```
Tree with values:
      0(5)
     /    \
   1(3)   2(7)
   /  \
 3(2) 4(4)

Euler tour:
  Position: 0  1  2  3  4
  Vertex:   0  1  3  4  2
  Value:    5  3  2  4  7

Subtree sum of 1:
  Range: [1, 3]
  Sum: 3 + 2 + 4 = 9 ‚úì
```

---

## Range Queries on Trees

### Path Queries with LCA

**Query:** Sum of values on path from u to v.

**Approach:**
1. Find LCA of u and v
2. Sum = path(u ‚Üí LCA) + path(v ‚Üí LCA) - value(LCA)

**With Euler tour + sparse table:**
```cpp
class TreePathQueries {
    vector<int> depth, parent;
    vector<vector<int>> up;  // Binary lifting
    int LOG;
    
    void dfs(int u, int p, vector<vector<int>>& adj, int d) {
        depth[u] = d;
        parent[u] = p;
        
        for (int v : adj[u]) {
            if (v != p) {
                dfs(v, u, adj, d + 1);
            }
        }
    }
    
    void buildLCA(int n) {
        LOG = ceil(log2(n));
        up.assign(n, vector<int>(LOG, -1));
        
        for (int i = 0; i < n; i++) {
            up[i][0] = parent[i];
        }
        
        for (int j = 1; j < LOG; j++) {
            for (int i = 0; i < n; i++) {
                if (up[i][j-1] != -1) {
                    up[i][j] = up[up[i][j-1]][j-1];
                }
            }
        }
    }
    
    int lca(int u, int v) {
        if (depth[u] < depth[v]) swap(u, v);
        
        // Bring u to same level as v
        int diff = depth[u] - depth[v];
        for (int i = 0; i < LOG; i++) {
            if ((diff >> i) & 1) {
                u = up[u][i];
            }
        }
        
        if (u == v) return u;
        
        // Binary search for LCA
        for (int i = LOG - 1; i >= 0; i--) {
            if (up[u][i] != up[v][i]) {
                u = up[u][i];
                v = up[v][i];
            }
        }
        
        return up[u][0];
    }
    
public:
    void build(vector<vector<int>>& tree, int root = 0) {
        int n = tree.size();
        depth.resize(n);
        parent.resize(n);
        
        dfs(root, -1, tree, 0);
        buildLCA(n);
    }
    
    int getLCA(int u, int v) {
        return lca(u, v);
    }
};
```

**Time:** 
- Build: O(n log n)
- Query: O(log n)

---

## Common Problems

### Problem 1: Critical Connections in a Network

```cpp
vector<vector<int>> criticalConnections(int n, vector<vector<int>>& connections) {
    vector<vector<int>> adj(n);
    
    for (auto& conn : connections) {
        adj[conn[0]].push_back(conn[1]);
        adj[conn[1]].push_back(conn[0]);
    }
    
    BridgeFinder finder;
    return finder.findBridges(adj);
}
```

### Problem 2: Articulation Points

```cpp
vector<int> articulationPoints(vector<vector<int>>& adj) {
    ArticulationPointFinder finder;
    return finder.findArticulationPoints(adj);
}
```

### Problem 3: Strongly Connected Components

```cpp
// Kosaraju's
vector<vector<int>> sccKosaraju(vector<vector<int>>& adj) {
    KosarajuSCC finder;
    return finder.findSCCs(adj);
}

// Tarjan's
vector<vector<int>> sccTarjan(vector<vector<int>>& adj) {
    TarjanSCC finder;
    return finder.findSCCs(adj);
}
```

### Problem 4: Subtree Queries

```cpp
class Solution {
    vector<int> in, out;
    int timer = 0;
    
    void dfs(vector<vector<int>>& adj, int u, int parent) {
        in[u] = timer++;
        for (int v : adj[u]) {
            if (v != parent) dfs(adj, v, u);
        }
        out[u] = timer - 1;
    }
    
public:
    bool isInSubtree(int u, int v, vector<vector<int>>& tree) {
        int n = tree.size();
        in.resize(n);
        out.resize(n);
        
        dfs(tree, 0, -1);
        
        // Is v in subtree of u?
        return in[u] <= in[v] && in[v] <= out[u];
    }
};
```

---

## Summary Tables

### Graph Algorithms Comparison

| Algorithm | Purpose | Complexity | Key Technique |
|-----------|---------|------------|---------------|
| **Bridges** | Critical edges | O(V+E) | Tarjan with low values |
| **Articulation Points** | Cut vertices | O(V+E) | Tarjan with root check |
| **Kosaraju SCC** | SCCs | O(V+E) | Two DFS + transpose |
| **Tarjan SCC** | SCCs | O(V+E) | One DFS + stack |
| **Euler Tour** | Tree flattening | O(V) | DFS with in/out times |

### Bridge vs Articulation Point

| Aspect | Bridge | Articulation Point |
|--------|--------|-------------------|
| **Graph type** | Undirected | Undirected |
| **Removes** | Edge | Vertex |
| **Condition** | `low[v] > disc[u]` | `low[v] >= disc[u]` or root with ‚â•2 children |
| **Meaning** | No alternate path | Disconnects components |

### SCC Algorithms

| Algorithm | Passes | Space | Complexity | Easier? |
|-----------|--------|-------|------------|---------|
| **Kosaraju** | 2 DFS | O(V) + transpose | O(V+E) | Yes ‚úì |
| **Tarjan** | 1 DFS | O(V) + stack | O(V+E) | No |

---

## Practice Problems

### Bridges & Articulation Points
- [ ] Critical Connections in a Network
- [ ] Articulation Points in Graph
- [ ] Bridges in a Graph
- [ ] Redundant Connection II

### SCC
- [ ] Strongly Connected Components
- [ ] Course Schedule IV
- [ ] Maximum Employees to Be Invited
- [ ] Critical Routers (Amazon)

### Euler Tour
- [ ] Reconstruct Itinerary
- [ ] Valid Arrangement of Pairs
- [ ] Cracking the Safe

### Tree Flattening
- [ ] Subtree Sum Queries
- [ ] Path Queries
- [ ] Tree Ancestor
- [ ] Kth Ancestor of a Tree Node

---

## Key Takeaways

1. **Bridges: low[v] > disc[u]** - No back edge to ancestors
2. **Articulation points: low[v] >= disc[u] OR root with ‚â•2 children** - Child can't bypass u
3. **Kosaraju: Two DFS passes, easier to understand** - Finish times + transpose
4. **Tarjan SCC: One DFS with stack** - Root when low[u] == disc[u]
5. **SCC only for directed graphs** - All pairs mutually reachable
6. **Euler path exists: ‚â§2 odd degree vertices** - Visit every edge once
7. **Euler tour for trees: Record in/out times** - Not same as Euler path!
8. **Subtree of u: vertices with in[v] ‚àà [in[u], out[u]]** - Flatten tree to array
9. **Tree queries ‚Üí array range queries** - Use segment tree/BIT
10. **Tarjan uses low values for many algorithms** - Bridges, APs, SCCs
11. **Back edge: Points to ancestor in DFS tree** - Updates low values
12. **Cross edge: Between different DFS trees** - Ignored in many algorithms

Master these advanced graph algorithms and you'll handle complex connectivity problems! üéØ

