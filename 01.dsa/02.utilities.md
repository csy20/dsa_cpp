# Mathematical Algorithms for Competitive Programming

## Table of Contents
1. [GCD & LCM](#gcd--lcm)
2. [Fast Power (Binary Exponentiation)](#fast-power)
3. [Modular Arithmetic](#modular-arithmetic)
4. [Factorials & Combinations](#factorials--combinations)
5. [Prime Sieve](#prime-sieve)
6. [Prime Factorization](#prime-factorization)
7. [Prefix/Suffix Sums](#prefixsuffix-sums)
8. [Difference Arrays](#difference-arrays)

---

## GCD & LCM

### Greatest Common Divisor (GCD)

**What it is:** The largest number that divides both numbers without remainder.

**How it works:** Uses the Euclidean algorithm based on this fact:
- `gcd(a, b) = gcd(b, a % b)`
- When `b = 0`, the answer is `a`

**Why it works:** If `d` divides both `a` and `b`, then `d` also divides `a - k*b` for any integer `k`. The remainder `a % b` is just `a - k*b` where `k = a/b`.

```cpp
// Recursive GCD - Euclidean Algorithm
int gcd(int a, int b) {
    if (b == 0) return a;
    return gcd(b, a % b);
}

// Iterative version (preferred for performance)
int gcd_iter(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

// C++17 has built-in gcd
#include <numeric>
// std::gcd(a, b)
```

**Example trace:**
```
gcd(48, 18)
= gcd(18, 48 % 18)  // 48 % 18 = 12
= gcd(18, 12)
= gcd(12, 18 % 12)  // 18 % 12 = 6
= gcd(12, 6)
= gcd(6, 12 % 6)    // 12 % 6 = 0
= gcd(6, 0)
= 6
```

**Time Complexity:** O(log(min(a, b)))

### Least Common Multiple (LCM)

**What it is:** The smallest number that both numbers divide evenly.

**Formula:** `lcm(a, b) = (a * b) / gcd(a, b)`

**Why it works:** The product `a * b` contains all prime factors we need, but some are duplicated. Dividing by GCD removes the duplicates.

```cpp
long long lcm(long long a, long long b) {
    return (a / gcd(a, b)) * b;  // Divide first to avoid overflow!
}

// C++17 has built-in lcm
#include <numeric>
// std::lcm(a, b)
```

**⚠️ Overflow Warning:** Always divide first, then multiply!
```cpp
// BAD:  (a * b) / gcd(a, b)  // Can overflow!
// GOOD: (a / gcd(a, b)) * b  // Safe
```

---

## Fast Power (Binary Exponentiation)

### Basic Concept

**Goal:** Compute `a^n` efficiently.

**Naive approach:** Multiply `a` by itself `n` times → O(n)

**Smart approach:** Use the binary representation of `n` → O(log n)

**Key insight:**
```
a^n = (a^2)^(n/2)           if n is even
a^n = a * (a^2)^((n-1)/2)   if n is odd
```

**How it works:** 
- Example: `3^13 = 3^(1101 in binary) = 3^8 * 3^4 * 3^1`
- We only multiply powers of 2: `3^1, 3^2, 3^4, 3^8, ...`

```cpp
// Recursive version
long long fast_power(long long a, long long n) {
    if (n == 0) return 1;
    
    long long half = fast_power(a, n / 2);
    
    if (n % 2 == 0) {
        return half * half;
    } else {
        return half * half * a;
    }
}

// Iterative version (preferred)
long long fast_power_iter(long long a, long long n) {
    long long result = 1;
    
    while (n > 0) {
        if (n & 1) {          // If n is odd
            result *= a;
        }
        a *= a;               // Square the base
        n >>= 1;              // Divide n by 2
    }
    
    return result;
}
```

**Example trace:** Compute `3^13`
```
n = 13 (binary: 1101)
result = 1, a = 3

Step 1: n=13 (odd)  → result = 1*3 = 3,     a = 3*3 = 9,    n = 6
Step 2: n=6  (even) → result = 3,           a = 9*9 = 81,   n = 3
Step 3: n=3  (odd)  → result = 3*81 = 243,  a = 81*81 = 6561, n = 1
Step 4: n=1  (odd)  → result = 243*6561 = 1594323, n = 0

Answer: 1594323
```

**Time Complexity:** O(log n)

---

## Modular Arithmetic

### Why We Need It

Large powers like `2^1000000` overflow. We use modulo to keep numbers manageable.

### Basic Properties

```
(a + b) % m = ((a % m) + (b % m)) % m
(a - b) % m = ((a % m) - (b % m) + m) % m  // +m handles negative
(a * b) % m = ((a % m) * (b % m)) % m
```

**⚠️ Division doesn't work this way!** `(a/b) % m ≠ ((a%m)/(b%m)) % m`

### Modular Exponentiation

```cpp
long long mod_power(long long a, long long n, long long mod) {
    long long result = 1;
    a %= mod;  // Handle case where a >= mod
    
    while (n > 0) {
        if (n & 1) {
            result = (result * a) % mod;
        }
        a = (a * a) % mod;
        n >>= 1;
    }
    
    return result;
}
```

### Modular Inverse

**Problem:** Compute `(a / b) % m`

**Solution:** Find `b^(-1)` such that `(b * b^(-1)) % m = 1`

**Method 1:** Fermat's Little Theorem (when `m` is prime)
- `a^(m-1) ≡ 1 (mod m)` for prime `m`
- So `a^(-1) ≡ a^(m-2) (mod m)`

```cpp
long long mod_inverse(long long a, long long mod) {
    // Only works when mod is prime!
    return mod_power(a, mod - 2, mod);
}

long long mod_divide(long long a, long long b, long long mod) {
    return (a * mod_inverse(b, mod)) % mod;
}
```

**Method 2:** Extended Euclidean Algorithm (works for any coprime numbers)

```cpp
// Returns {gcd, x, y} such that ax + by = gcd(a,b)
tuple<long long, long long, long long> extended_gcd(long long a, long long b) {
    if (b == 0) {
        return {a, 1, 0};
    }
    
    auto [g, x1, y1] = extended_gcd(b, a % b);
    long long x = y1;
    long long y = x1 - (a / b) * y1;
    
    return {g, x, y};
}

long long mod_inverse_general(long long a, long long mod) {
    auto [g, x, y] = extended_gcd(a, mod);
    if (g != 1) return -1;  // Inverse doesn't exist
    return (x % mod + mod) % mod;
}
```

---

## Factorials & Combinations

### Basic Factorial

```cpp
const int MAXN = 1e6;
long long fact[MAXN];

void precompute_factorial() {
    fact[0] = 1;
    for (int i = 1; i < MAXN; i++) {
        fact[i] = fact[i-1] * i;
    }
}

// nCr = n! / (r! * (n-r)!)
long long nCr(int n, int r) {
    if (r > n || r < 0) return 0;
    return fact[n] / (fact[r] * fact[n - r]);
}
```

**Problem:** Factorials overflow very quickly! `21! > 10^18`

### Factorial with Modulus

```cpp
const long long MOD = 1e9 + 7;
const int MAXN = 1e6;
long long fact[MAXN], inv_fact[MAXN];

void precompute_factorial_mod() {
    fact[0] = 1;
    for (int i = 1; i < MAXN; i++) {
        fact[i] = (fact[i-1] * i) % MOD;
    }
    
    // Precompute inverse factorials
    inv_fact[MAXN - 1] = mod_power(fact[MAXN - 1], MOD - 2, MOD);
    for (int i = MAXN - 2; i >= 0; i--) {
        inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD;
    }
}

long long nCr_mod(int n, int r) {
    if (r > n || r < 0) return 0;
    
    long long result = fact[n];
    result = (result * inv_fact[r]) % MOD;
    result = (result * inv_fact[n - r]) % MOD;
    
    return result;
}
```

**How precomputing inverse factorials works:**
```
inv_fact[n] = 1 / n!
inv_fact[n-1] = 1 / (n-1)! = (1/n!) * n = inv_fact[n] * n
```

### Pascal's Triangle (Small n, r)

**Recurrence:** `C(n, r) = C(n-1, r-1) + C(n-1, r)`

```cpp
const int MAXN = 1001;
long long C[MAXN][MAXN];

void precompute_pascals_triangle() {
    for (int i = 0; i < MAXN; i++) {
        C[i][0] = C[i][i] = 1;
        for (int j = 1; j < i; j++) {
            C[i][j] = C[i-1][j-1] + C[i-1][j];
            // With mod: C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD;
        }
    }
}
```

**Time:** O(n²), **Space:** O(n²)

---

## Prime Sieve

### Sieve of Eratosthenes

**Goal:** Find all primes up to `n`.

**How it works:**
1. Assume all numbers are prime
2. Start from 2 (first prime)
3. Mark all multiples of 2 as composite
4. Move to next unmarked number (3), mark its multiples
5. Repeat until √n

**Why √n is enough:** If `n = a * b` and `a > √n`, then `b < √n`, so `b` would have already marked `n` as composite.

```cpp
const int MAXN = 1e7;
bool is_prime[MAXN];
vector<int> primes;

void sieve(int n) {
    fill(is_prime, is_prime + n + 1, true);
    is_prime[0] = is_prime[1] = false;
    
    for (int i = 2; i <= n; i++) {
        if (is_prime[i]) {
            primes.push_back(i);
            
            // Mark all multiples as composite
            for (long long j = (long long)i * i; j <= n; j += i) {
                is_prime[j] = false;
            }
        }
    }
}
```

**Optimization:** Start marking from `i*i` because smaller multiples were already marked by smaller primes.

**Time Complexity:** O(n log log n) ≈ O(n)  
**Space Complexity:** O(n)

### Optimized Sieve (Linear Sieve)

**Goal:** Mark each composite exactly once.

```cpp
const int MAXN = 1e7;
int smallest_prime_factor[MAXN];
vector<int> primes;

void linear_sieve(int n) {
    for (int i = 2; i <= n; i++) {
        if (smallest_prime_factor[i] == 0) {
            smallest_prime_factor[i] = i;
            primes.push_back(i);
        }
        
        for (int p : primes) {
            if (p > smallest_prime_factor[i] || i * p > n) break;
            smallest_prime_factor[i * p] = p;
        }
    }
}
```

**Time Complexity:** O(n) - truly linear!

---

## Prime Factorization

### Method 1: Trial Division

**How it works:** Divide by all primes up to √n.

```cpp
vector<pair<int, int>> prime_factorize(int n) {
    vector<pair<int, int>> factors;  // {prime, count}
    
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            int count = 0;
            while (n % i == 0) {
                n /= i;
                count++;
            }
            factors.push_back({i, count});
        }
    }
    
    if (n > 1) {
        factors.push_back({n, 1});  // Remaining prime
    }
    
    return factors;
}
```

**Time Complexity:** O(√n)

### Method 2: Using Precomputed SPF

**How it works:** Use smallest prime factor from sieve.

```cpp
vector<pair<int, int>> prime_factorize_spf(int n) {
    vector<pair<int, int>> factors;
    
    while (n > 1) {
        int p = smallest_prime_factor[n];
        int count = 0;
        
        while (n % p == 0) {
            n /= p;
            count++;
        }
        
        factors.push_back({p, count});
    }
    
    return factors;
}
```

**Time Complexity:** O(log n) after O(n) preprocessing

### Applications

```cpp
// Count number of divisors
int count_divisors(int n) {
    auto factors = prime_factorize(n);
    int count = 1;
    
    for (auto [p, exp] : factors) {
        count *= (exp + 1);  // (e+1) choices: p^0, p^1, ..., p^e
    }
    
    return count;
}

// Sum of divisors
int sum_divisors(int n) {
    auto factors = prime_factorize(n);
    int sum = 1;
    
    for (auto [p, exp] : factors) {
        // Sum of geometric series: (p^(e+1) - 1) / (p - 1)
        int term_sum = (pow(p, exp + 1) - 1) / (p - 1);
        sum *= term_sum;
    }
    
    return sum;
}
```

---

## Prefix/Suffix Sums

### Prefix Sum

**Goal:** Answer "sum of elements from index `l` to `r`" in O(1).

**How it works:**
- Precompute: `prefix[i] = sum of arr[0...i-1]`
- Query: `sum(l, r) = prefix[r+1] - prefix[l]`

```cpp
vector<int> arr = {3, 1, 4, 1, 5, 9, 2, 6};
vector<long long> prefix(arr.size() + 1, 0);

// Build prefix sum
for (int i = 0; i < arr.size(); i++) {
    prefix[i + 1] = prefix[i] + arr[i];
}

// Query: sum from index l to r (inclusive)
long long range_sum(int l, int r) {
    return prefix[r + 1] - prefix[l];
}
```

**Example:**
```
arr    = [3, 1, 4, 1, 5, 9, 2, 6]
prefix = [0, 3, 4, 8, 9, 14, 23, 25, 31]

sum(2, 5) = prefix[6] - prefix[2] = 23 - 4 = 19
           = arr[2] + arr[3] + arr[4] + arr[5]
           = 4 + 1 + 5 + 9 = 19 ✓
```

**Time Complexity:**
- Build: O(n)
- Query: O(1)

### 2D Prefix Sum

**Goal:** Sum of submatrix in O(1).

```cpp
vector<vector<int>> matrix(n, vector<int>(m));
vector<vector<long long>> prefix(n + 1, vector<long long>(m + 1, 0));

// Build 2D prefix sum
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        prefix[i][j] = matrix[i-1][j-1] 
                     + prefix[i-1][j] 
                     + prefix[i][j-1] 
                     - prefix[i-1][j-1];
    }
}

// Query: sum of submatrix from (r1,c1) to (r2,c2)
long long submatrix_sum(int r1, int c1, int r2, int c2) {
    r1++; c1++; r2++; c2++;  // Convert to 1-indexed
    return prefix[r2][c2] 
         - prefix[r1-1][c2] 
         - prefix[r2][c1-1] 
         + prefix[r1-1][c1-1];
}
```

**Why the formula works:**
- We want the green area
- Add full rectangle to (r2, c2)
- Subtract the left rectangle
- Subtract the top rectangle
- But we subtracted the corner twice, so add it back

### Suffix Sum

```cpp
vector<long long> suffix(arr.size() + 1, 0);

// Build suffix sum (from right to left)
for (int i = arr.size() - 1; i >= 0; i--) {
    suffix[i] = suffix[i + 1] + arr[i];
}

// sum from index l to end
long long suffix_sum(int l) {
    return suffix[l];
}
```

---

## Difference Arrays

### 1D Difference Array

**Goal:** Apply range updates efficiently, then compute final array.

**Problem:** Add `x` to all elements from index `l` to `r`. Do this for `q` queries.

**Naive:** O(n) per query → O(nq) total

**Smart:** Use difference array → O(1) per query + O(n) final computation

**How it works:**
- `diff[i] = arr[i] - arr[i-1]`
- To add `x` to range `[l, r]`: 
  - `diff[l] += x`
  - `diff[r+1] -= x`
- Reconstruct: `arr[i] = arr[i-1] + diff[i]`

```cpp
vector<int> arr(n, 0);
vector<int> diff(n + 1, 0);

// Apply range update: add val to [l, r]
void range_add(int l, int r, int val) {
    diff[l] += val;
    diff[r + 1] -= val;
}

// After all updates, build final array
void build_array() {
    arr[0] = diff[0];
    for (int i = 1; i < n; i++) {
        arr[i] = arr[i-1] + diff[i];
    }
}
```

**Example:**
```
Initial: arr = [0, 0, 0, 0, 0, 0]
         diff = [0, 0, 0, 0, 0, 0, 0]

Query 1: Add 5 to [1, 3]
diff[1] += 5  → diff = [0, 5, 0, 0, -5, 0, 0]

Query 2: Add 3 to [2, 5]
diff[2] += 3  → diff = [0, 5, 3, 0, -5, 0, -3]
diff[6] -= 3

Build array:
arr[0] = 0
arr[1] = 0 + 5 = 5
arr[2] = 5 + 3 = 8
arr[3] = 8 + 0 = 8
arr[4] = 8 + (-5) = 3
arr[5] = 3 + 0 = 3
arr[6] = 3 + (-3) = 0

Final: arr = [0, 5, 8, 8, 3, 3]
```

### 2D Difference Array

**Goal:** Add value to a submatrix efficiently.

```cpp
vector<vector<int>> diff(n + 2, vector<int>(m + 2, 0));

// Add val to submatrix from (r1,c1) to (r2,c2)
void range_add_2d(int r1, int c1, int r2, int c2, int val) {
    diff[r1][c1] += val;
    diff[r1][c2 + 1] -= val;
    diff[r2 + 1][c1] -= val;
    diff[r2 + 1][c2 + 1] += val;
}

// Build final 2D array
void build_2d_array(vector<vector<int>>& arr) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (i > 0) diff[i][j] += diff[i-1][j];
            if (j > 0) diff[i][j] += diff[i][j-1];
            if (i > 0 && j > 0) diff[i][j] -= diff[i-1][j-1];
            arr[i][j] = diff[i][j];
        }
    }
}
```

**Time Complexity:**
- Each update: O(1)
- Build final array: O(nm)

---

## Common Pitfalls & Tips

### Integer Overflow

```cpp
// BAD
int a = 1e9, b = 1e9;
long long result = a * b;  // Overflow! Multiplies as int first

// GOOD
long long result = (long long)a * b;  // Cast before multiply
```

### Modulo with Negative Numbers

```cpp
// BAD
int mod(int a, int m) {
    return a % m;  // Can be negative!
}

// GOOD
int mod(int a, int m) {
    return ((a % m) + m) % m;
}
```

### Division in Modular Arithmetic

```cpp
// BAD
long long ans = (a / b) % MOD;  // Wrong!

// GOOD
long long ans = (a * mod_inverse(b, MOD)) % MOD;
```

### Sieve Memory

```cpp
// For n = 1e8, bool array = 100 MB
// Use bitset for larger n
bitset<100000001> is_prime;
```

---

## Complete Example Program

```cpp
#include <bits/stdc++.h>
using namespace std;

const long long MOD = 1e9 + 7;
const int MAXN = 1e6 + 5;

// Precomputed arrays
bool is_prime[MAXN];
int spf[MAXN];
vector<int> primes;
long long fact[MAXN], inv_fact[MAXN];

long long mod_power(long long a, long long n, long long mod) {
    long long res = 1;
    a %= mod;
    while (n > 0) {
        if (n & 1) res = (res * a) % mod;
        a = (a * a) % mod;
        n >>= 1;
    }
    return res;
}

void sieve(int n) {
    fill(is_prime, is_prime + n + 1, true);
    is_prime[0] = is_prime[1] = false;
    
    for (int i = 2; i <= n; i++) {
        if (is_prime[i]) {
            primes.push_back(i);
            spf[i] = i;
            for (long long j = (long long)i * i; j <= n; j += i) {
                is_prime[j] = false;
                if (spf[j] == 0) spf[j] = i;
            }
        }
    }
}

void precompute_factorials(int n) {
    fact[0] = 1;
    for (int i = 1; i <= n; i++) {
        fact[i] = (fact[i-1] * i) % MOD;
    }
    
    inv_fact[n] = mod_power(fact[n], MOD - 2, MOD);
    for (int i = n - 1; i >= 0; i--) {
        inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD;
    }
}

long long nCr(int n, int r) {
    if (r > n || r < 0) return 0;
    long long res = fact[n];
    res = (res * inv_fact[r]) % MOD;
    res = (res * inv_fact[n - r]) % MOD;
    return res;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    sieve(MAXN - 1);
    precompute_factorials(MAXN - 1);
    
    // Example usage
    cout << "GCD(48, 18) = " << __gcd(48, 18) << "\n";
    cout << "2^10 = " << mod_power(2, 10, MOD) << "\n";
    cout << "10C3 = " << nCr(10, 3) << "\n";
    cout << "Is 97 prime? " << (is_prime[97] ? "Yes" : "No") << "\n";
    
    return 0;
}
```

---

## Summary Table

| Algorithm | Time | Space | Use Case |
|-----------|------|-------|----------|
| GCD (Euclidean) | O(log min(a,b)) | O(1) | Finding GCD/LCM |
| Fast Power | O(log n) | O(1) | Large exponents |
| Mod Power | O(log n) | O(1) | Exponents with mod |
| Factorial Precompute | O(n) | O(n) | Multiple nCr queries |
| Sieve of Eratosthenes | O(n log log n) | O(n) | All primes ≤ n |
| Linear Sieve | O(n) | O(n) | All primes + SPF |
| Prime Factorization | O(√n) | O(log n) | Factor single number |
| Prefix Sum (1D) | O(n) build, O(1) query | O(n) | Range sum queries |
| Prefix Sum (2D) | O(nm) build, O(1) query | O(nm) | Submatrix sum |
| Difference Array | O(1) update, O(n) build | O(n) | Range updates |

