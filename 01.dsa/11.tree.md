# Trees - Complete Guide

## Table of Contents
1. [Tree Fundamentals](#tree-fundamentals)
2. [Tree Traversals](#tree-traversals)
3. [Recursion vs Iterative](#recursion-vs-iterative)
4. [Level Order Traversal](#level-order-traversal)
5. [Tree Properties](#tree-properties)
6. [Diameter and Height](#diameter-and-height)
7. [Lowest Common Ancestor (LCA)](#lowest-common-ancestor-lca)
8. [Binary Search Trees (BST)](#binary-search-trees-bst)
9. [BST Operations](#bst-operations)
10. [Validate BST](#validate-bst)
11. [Advanced Patterns](#advanced-patterns)
12. [Common Problems](#common-problems)

---

## Tree Fundamentals

### Tree Structure

**Definition:** A tree is a hierarchical data structure with nodes connected by edges.

```
Tree terminology:
        1       ‚Üê Root (topmost node)
       / \
      2   3     ‚Üê Level 1 (depth = 1)
     / \   \
    4   5   6   ‚Üê Level 2 (depth = 2, leaves)
```

**Key terms:**
- **Root:** Top node (1)
- **Parent:** Node with children (1 is parent of 2, 3)
- **Child:** Node below parent (2, 3 are children of 1)
- **Leaf:** Node with no children (4, 5, 6)
- **Sibling:** Nodes with same parent (2 and 3)
- **Ancestor:** Nodes on path to root (1, 2 are ancestors of 4)
- **Descendant:** Nodes in subtree (4, 5 are descendants of 2)
- **Depth:** Distance from root (depth of 5 = 2)
- **Height:** Distance to deepest leaf (height of tree = 2)

### Binary Tree Node

```cpp
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};
```

### Tree Types

**1. Binary Tree:** Each node has at most 2 children
```
    1
   / \
  2   3
```

**2. Full Binary Tree:** Every node has 0 or 2 children
```
    1
   / \
  2   3
 / \
4   5
```

**3. Complete Binary Tree:** All levels filled except possibly last (filled left to right)
```
    1
   / \
  2   3
 / \
4   5
```

**4. Perfect Binary Tree:** All internal nodes have 2 children, all leaves at same level
```
    1
   / \
  2   3
 / \ / \
4 5 6 7
```

**5. Balanced Binary Tree:** Height difference between left and right subtrees ‚â§ 1
```
    1
   / \
  2   3
 /
4
Height difference: |2 - 1| = 1 ‚úì
```

**6. Binary Search Tree (BST):** Left < Node < Right
```
    4
   / \
  2   6
 / \ / \
1  3 5  7
```

### Tree Properties

| Property | Formula |
|----------|---------|
| Max nodes at level i | 2^i |
| Max nodes in tree of height h | 2^(h+1) - 1 |
| Min height for n nodes | ‚åàlog‚ÇÇ(n+1)‚åâ - 1 |
| Max height for n nodes | n - 1 |
| Leaf nodes in full binary tree | (n+1)/2 |

---

## Tree Traversals

### Three Main Traversals

**Visual tree:**
```
    1
   / \
  2   3
 / \
4   5
```

**1. Preorder (Root ‚Üí Left ‚Üí Right)**
- Process root first
- Then left subtree
- Then right subtree

**Order:** 1, 2, 4, 5, 3

```cpp
void preorder(TreeNode* root) {
    if (!root) return;
    
    cout << root->val << " ";  // 1. Visit root
    preorder(root->left);      // 2. Left subtree
    preorder(root->right);     // 3. Right subtree
}
```

**How it works:**
```
Call stack:

preorder(1)
  print 1
  preorder(2)
    print 2
    preorder(4)
      print 4
      preorder(null)  // left of 4
      preorder(null)  // right of 4
    preorder(5)
      print 5
      preorder(null)
      preorder(null)
  preorder(3)
    print 3
    preorder(null)
    preorder(null)

Output: 1 2 4 5 3
```

**2. Inorder (Left ‚Üí Root ‚Üí Right)**
- Process left subtree
- Then root
- Then right subtree

**Order:** 4, 2, 5, 1, 3

```cpp
void inorder(TreeNode* root) {
    if (!root) return;
    
    inorder(root->left);       // 1. Left subtree
    cout << root->val << " ";  // 2. Visit root
    inorder(root->right);      // 3. Right subtree
}
```

**Special property:** For BST, inorder gives **sorted** sequence!

**3. Postorder (Left ‚Üí Right ‚Üí Root)**
- Process left subtree
- Then right subtree
- Then root

**Order:** 4, 5, 2, 3, 1

```cpp
void postorder(TreeNode* root) {
    if (!root) return;
    
    postorder(root->left);     // 1. Left subtree
    postorder(root->right);    // 2. Right subtree
    cout << root->val << " ";  // 3. Visit root
}
```

**Use case:** Delete tree (delete children before parent)

### Traversal Mnemonics

```
Preorder:  ROOT first     ‚Üí Use for copying tree
Inorder:   ROOT middle    ‚Üí Use for BST sorting
Postorder: ROOT last      ‚Üí Use for deleting tree
```

**Visual comparison:**
```
Tree:
    1
   / \
  2   3
 / \
4   5

Preorder:  1 -> 2 -> 4 -> 5 -> 3  (root first)
Inorder:   4 -> 2 -> 5 -> 1 -> 3  (root middle)
Postorder: 4 -> 5 -> 2 -> 3 -> 1  (root last)
```

---

## Recursion vs Iterative

### Preorder: Recursive vs Iterative

**Recursive (natural):**
```cpp
void preorderRecursive(TreeNode* root) {
    if (!root) return;
    cout << root->val << " ";
    preorderRecursive(root->left);
    preorderRecursive(root->right);
}
```

**Iterative (using stack):**
```cpp
void preorderIterative(TreeNode* root) {
    if (!root) return;
    
    stack<TreeNode*> st;
    st.push(root);
    
    while (!st.empty()) {
        TreeNode* node = st.top();
        st.pop();
        
        cout << node->val << " ";  // Process
        
        // Push right first (so left is processed first)
        if (node->right) st.push(node->right);
        if (node->left) st.push(node->left);
    }
}
```

**How it works:**
```
Tree:
    1
   / \
  2   3
 / \
4   5

Stack simulation:

Initial: [1]

Step 1: Pop 1, print 1
  Push right (3), left (2)
  Stack: [3, 2]

Step 2: Pop 2, print 2
  Push right (5), left (4)
  Stack: [3, 5, 4]

Step 3: Pop 4, print 4
  No children
  Stack: [3, 5]

Step 4: Pop 5, print 5
  No children
  Stack: [3]

Step 5: Pop 3, print 3
  No children
  Stack: []

Output: 1 2 4 5 3 ‚úì
```

### Inorder: Recursive vs Iterative

**Recursive:**
```cpp
void inorderRecursive(TreeNode* root) {
    if (!root) return;
    inorderRecursive(root->left);
    cout << root->val << " ";
    inorderRecursive(root->right);
}
```

**Iterative (trickier!):**
```cpp
void inorderIterative(TreeNode* root) {
    stack<TreeNode*> st;
    TreeNode* curr = root;
    
    while (curr || !st.empty()) {
        // Go to leftmost node
        while (curr) {
            st.push(curr);
            curr = curr->left;
        }
        
        // Process node
        curr = st.top();
        st.pop();
        cout << curr->val << " ";
        
        // Visit right subtree
        curr = curr->right;
    }
}
```

**How it works:**
```
Tree:
    1
   / \
  2   3
 / \
4   5

Trace:

curr = 1
  Push 1, go left
  curr = 2
    Push 2, go left
    curr = 4
      Push 4, go left
      curr = null
      
Stack: [1, 2, 4]

Pop 4, print 4, curr = 4->right = null
Pop 2, print 2, curr = 2->right = 5

curr = 5
  Push 5, go left
  curr = null

Stack: [1, 5]

Pop 5, print 5, curr = null
Pop 1, print 1, curr = 1->right = 3

curr = 3
  Push 3, go left
  curr = null

Stack: [3]

Pop 3, print 3, curr = null
Stack empty, done

Output: 4 2 5 1 3 ‚úì
```

### Postorder: Recursive vs Iterative

**Recursive:**
```cpp
void postorderRecursive(TreeNode* root) {
    if (!root) return;
    postorderRecursive(root->left);
    postorderRecursive(root->right);
    cout << root->val << " ";
}
```

**Iterative (most complex!):**

**Method 1: Two stacks**
```cpp
void postorderIterative(TreeNode* root) {
    if (!root) return;
    
    stack<TreeNode*> st1, st2;
    st1.push(root);
    
    // Modified preorder: Root ‚Üí Right ‚Üí Left
    while (!st1.empty()) {
        TreeNode* node = st1.top();
        st1.pop();
        st2.push(node);
        
        if (node->left) st1.push(node->left);
        if (node->right) st1.push(node->right);
    }
    
    // Reverse gives: Left ‚Üí Right ‚Üí Root
    while (!st2.empty()) {
        cout << st2.top()->val << " ";
        st2.pop();
    }
}
```

**How it works:**
```
Tree:
    1
   / \
  2   3
 / \
4   5

st1 does reverse postorder (Root ‚Üí Right ‚Üí Left):
  Process 1: push to st2
  Process 3: push to st2
  Process 2: push to st2
  Process 5: push to st2
  Process 4: push to st2

st2: [1, 3, 2, 5, 4]

Pop st2: 4 5 2 3 1 (postorder!) ‚úì
```

**Method 2: One stack with visited tracking**
```cpp
void postorderIterative(TreeNode* root) {
    if (!root) return;
    
    stack<TreeNode*> st;
    TreeNode* curr = root;
    TreeNode* lastVisited = nullptr;
    
    while (curr || !st.empty()) {
        // Go to leftmost
        while (curr) {
            st.push(curr);
            curr = curr->left;
        }
        
        TreeNode* peekNode = st.top();
        
        // If right child exists and not visited, go right
        if (peekNode->right && peekNode->right != lastVisited) {
            curr = peekNode->right;
        } else {
            // Process node
            cout << peekNode->val << " ";
            st.pop();
            lastVisited = peekNode;
        }
    }
}
```

### Comparison Table

| Traversal | Recursive | Iterative | Difficulty |
|-----------|-----------|-----------|------------|
| Preorder | Easy | Easy | ‚≠ê |
| Inorder | Easy | Medium | ‚≠ê‚≠ê |
| Postorder | Easy | Hard | ‚≠ê‚≠ê‚≠ê |
| Level order | N/A | Easy (queue) | ‚≠ê |

**Space complexity:** All O(h) where h = height
- Recursive: Call stack
- Iterative: Explicit stack

---

## Level Order Traversal

### Breadth-First Search (BFS)

**Visit nodes level by level, left to right.**

```cpp
void levelOrder(TreeNode* root) {
    if (!root) return;
    
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        
        cout << node->val << " ";
        
        if (node->left) q.push(node->left);
        if (node->right) q.push(node->right);
    }
}
```

**How it works:**
```
Tree:
    1
   / \
  2   3
 / \   \
4   5   6

Queue simulation:

Initial: [1]

Step 1: Dequeue 1, print 1
  Enqueue 2, 3
  Queue: [2, 3]

Step 2: Dequeue 2, print 2
  Enqueue 4, 5
  Queue: [3, 4, 5]

Step 3: Dequeue 3, print 3
  Enqueue 6
  Queue: [4, 5, 6]

Step 4: Dequeue 4, print 4
  Queue: [5, 6]

Step 5: Dequeue 5, print 5
  Queue: [6]

Step 6: Dequeue 6, print 6
  Queue: []

Output: 1 2 3 4 5 6 ‚úì
```

### Level Order with Level Separation

**Return each level as separate vector:**

```cpp
vector<vector<int>> levelOrder(TreeNode* root) {
    vector<vector<int>> result;
    if (!root) return result;
    
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        int levelSize = q.size();  // Current level size
        vector<int> level;
        
        for (int i = 0; i < levelSize; i++) {
            TreeNode* node = q.front();
            q.pop();
            
            level.push_back(node->val);
            
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        
        result.push_back(level);
    }
    
    return result;
}
```

**How it works:**
```
Tree:
    1
   / \
  2   3
 / \
4   5

Iteration 1:
  levelSize = 1 (only node 1)
  Process 1: level = [1]
  Queue after: [2, 3]
  result = [[1]]

Iteration 2:
  levelSize = 2 (nodes 2, 3)
  Process 2: level = [2]
  Process 3: level = [2, 3]
  Queue after: [4, 5]
  result = [[1], [2, 3]]

Iteration 3:
  levelSize = 2 (nodes 4, 5)
  Process 4: level = [4]
  Process 5: level = [4, 5]
  Queue after: []
  result = [[1], [2, 3], [4, 5]]

Final: [[1], [2, 3], [4, 5]] ‚úì
```

**Key insight:** Use `q.size()` **before** loop to know current level size!

### Zigzag Level Order

**Alternate left-to-right and right-to-left:**

```cpp
vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
    vector<vector<int>> result;
    if (!root) return result;
    
    queue<TreeNode*> q;
    q.push(root);
    bool leftToRight = true;
    
    while (!q.empty()) {
        int levelSize = q.size();
        vector<int> level(levelSize);
        
        for (int i = 0; i < levelSize; i++) {
            TreeNode* node = q.front();
            q.pop();
            
            // Find position to insert
            int index = leftToRight ? i : (levelSize - 1 - i);
            level[index] = node->val;
            
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        
        result.push_back(level);
        leftToRight = !leftToRight;  // Flip direction
    }
    
    return result;
}
```

**Example:**
```
Tree:
    1
   / \
  2   3
 / \   \
4   5   6

Level 0 (L‚ÜíR): [1]
Level 1 (R‚ÜíL): [3, 2]
Level 2 (L‚ÜíR): [4, 5, 6]

Result: [[1], [3, 2], [4, 5, 6]]
```

---

## Tree Properties

### Calculate Height

**Height:** Maximum distance from root to any leaf.

```cpp
int height(TreeNode* root) {
    if (!root) return -1;  // or 0, depending on definition
    
    int leftHeight = height(root->left);
    int rightHeight = height(root->right);
    
    return 1 + max(leftHeight, rightHeight);
}
```

**How it works:**
```
Tree:
    1
   / \
  2   3
 / \
4   5

height(1):
  leftHeight = height(2)
    leftHeight = height(4)
      leftHeight = height(null) = -1
      rightHeight = height(null) = -1
      return 1 + max(-1, -1) = 0
    rightHeight = height(5) = 0
    return 1 + max(0, 0) = 1
    
  rightHeight = height(3)
    leftHeight = -1
    rightHeight = -1
    return 1 + max(-1, -1) = 0
    
  return 1 + max(1, 0) = 2 ‚úì
```

**Note:** 
- Height of null: -1 (edges)
- Height of leaf: 0
- Some define null height as 0, leaf as 1

### Count Nodes

```cpp
int countNodes(TreeNode* root) {
    if (!root) return 0;
    
    return 1 + countNodes(root->left) + countNodes(root->right);
}
```

### Check if Balanced

**Balanced:** Height difference ‚â§ 1 for all nodes.

```cpp
bool isBalanced(TreeNode* root) {
    return checkBalance(root) != -1;
}

int checkBalance(TreeNode* root) {
    if (!root) return 0;
    
    int leftHeight = checkBalance(root->left);
    if (leftHeight == -1) return -1;  // Left subtree unbalanced
    
    int rightHeight = checkBalance(root->right);
    if (rightHeight == -1) return -1;  // Right subtree unbalanced
    
    // Check current node
    if (abs(leftHeight - rightHeight) > 1) return -1;
    
    return 1 + max(leftHeight, rightHeight);
}
```

**Example:**
```
Balanced:
    1
   / \
  2   3
 /
4
Left height: 2, Right height: 1
|2 - 1| = 1 ‚úì

Unbalanced:
    1
   /
  2
 /
3
Left height: 2, Right height: 0
|2 - 0| = 2 ‚úó
```

---

## Diameter and Height

### Diameter of Binary Tree

**Diameter:** Longest path between any two nodes (may not pass through root).

**Key insight:** For each node, diameter is either:
1. In left subtree
2. In right subtree
3. Through this node = left_height + right_height + 2

```cpp
class Solution {
private:
    int maxDiameter;
    
    int height(TreeNode* root) {
        if (!root) return -1;
        
        int leftHeight = height(root->left);
        int rightHeight = height(root->right);
        
        // Update diameter (path through this node)
        int diameterThroughNode = leftHeight + rightHeight + 2;
        maxDiameter = max(maxDiameter, diameterThroughNode);
        
        return 1 + max(leftHeight, rightHeight);
    }
    
public:
    int diameterOfBinaryTree(TreeNode* root) {
        maxDiameter = 0;
        height(root);
        return maxDiameter;
    }
};
```

**How it works:**
```
Tree:
    1
   / \
  2   3
 / \
4   5

height(4):
  leftHeight = -1, rightHeight = -1
  diameter through 4 = -1 + -1 + 2 = 0
  maxDiameter = 0
  return 0

height(5):
  diameter through 5 = 0
  return 0

height(2):
  leftHeight = 0, rightHeight = 0
  diameter through 2 = 0 + 0 + 2 = 2
  maxDiameter = 2
  return 1

height(3):
  diameter through 3 = 0
  return 0

height(1):
  leftHeight = 1, rightHeight = 0
  diameter through 1 = 1 + 0 + 2 = 3
  maxDiameter = 3
  return 2

Answer: 3 (path: 4 ‚Üí 2 ‚Üí 5) ‚úì
```

**Visual:**
```
    1
   / \
  2   3
 / \
4   5

Longest path: 4 ‚Üí 2 ‚Üí 5 (length 2 edges)
Or: 4 ‚Üí 2 ‚Üí 1 ‚Üí 3 (length 3 edges)

If counting nodes: diameter = 3
If counting edges: diameter = 2
```

**Time:** O(n), **Space:** O(h) for recursion

---

## Lowest Common Ancestor (LCA)

### LCA in Binary Tree

**LCA:** Deepest node that is ancestor of both p and q.

```cpp
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    // Base case
    if (!root || root == p || root == q) return root;
    
    // Search in left and right subtrees
    TreeNode* left = lowestCommonAncestor(root->left, p, q);
    TreeNode* right = lowestCommonAncestor(root->right, p, q);
    
    // If both left and right are non-null, root is LCA
    if (left && right) return root;
    
    // Otherwise, return non-null side
    return left ? left : right;
}
```

**How it works:**
```
Tree:
        3
       / \
      5   1
     / \ / \
    6  2 0  8
      / \
     7   4

Find LCA(5, 1):

lca(3, 5, 1):
  left = lca(5, 5, 1)
    root == 5, return 5
  right = lca(1, 5, 1)
    root == 1, return 1
  
  Both left and right are non-null
  return 3 ‚úì

Find LCA(5, 4):

lca(3, 5, 4):
  left = lca(5, 5, 4)
    root == 5, return 5
  right = lca(1, 5, 4)
    left = lca(0, 5, 4) = null
    right = lca(8, 5, 4) = null
    return null
  
  left = 5, right = null
  return 5 ‚úì
```

**Four cases:**
```
1. Both in left subtree:
      root
      /
    LCA
   / \
  p   q
  Return: left

2. Both in right subtree:
  root
    \
    LCA
   / \
  p   q
  Return: right

3. One in each subtree:
    root (LCA)
    / \
   p   q
  Return: root

4. One is ancestor of other:
    p (LCA)
     \
      q
  Return: p (or q)
```

**Time:** O(n), **Space:** O(h)

### LCA in BST

**BST property:** Can decide direction without exploring both subtrees!

```cpp
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    // Ensure p < q
    if (p->val > q->val) swap(p, q);
    
    while (root) {
        if (root->val > q->val) {
            // Both in left subtree
            root = root->left;
        } else if (root->val < p->val) {
            // Both in right subtree
            root = root->right;
        } else {
            // Split point found
            return root;
        }
    }
    
    return nullptr;
}
```

**How it works:**
```
BST:
        6
       / \
      2   8
     / \ / \
    0  4 7  9
      / \
     3   5

Find LCA(2, 8):
  root = 6
  p = 2 < 6 < 8 = q
  Split! Return 6 ‚úì

Find LCA(2, 4):
  root = 6
  Both < 6, go left
  root = 2
  2 = p < 4 = q
  Split! Return 2 ‚úì
```

**Time:** O(h), **Space:** O(1)

### LCA with Binary Lifting (Optional)

**Binary Lifting:** Preprocess to answer LCA queries in O(log n).

**Idea:** Store 2^i-th ancestor for each node.

```cpp
class BinaryLifting {
private:
    vector<vector<int>> parent;  // parent[node][i] = 2^i-th ancestor
    vector<int> depth;
    int LOG;
    
public:
    BinaryLifting(TreeNode* root, int n) {
        LOG = ceil(log2(n)) + 1;
        parent.assign(n, vector<int>(LOG, -1));
        depth.assign(n, 0);
        
        dfs(root, -1, 0);
        
        // Fill parent table
        for (int j = 1; j < LOG; j++) {
            for (int i = 0; i < n; i++) {
                if (parent[i][j-1] != -1) {
                    parent[i][j] = parent[parent[i][j-1]][j-1];
                }
            }
        }
    }
    
    void dfs(TreeNode* node, int par, int d) {
        if (!node) return;
        
        parent[node->val][0] = par;  // Immediate parent
        depth[node->val] = d;
        
        dfs(node->left, node->val, d + 1);
        dfs(node->right, node->val, d + 1);
    }
    
    int lca(int u, int v) {
        // Make u deeper
        if (depth[u] < depth[v]) swap(u, v);
        
        // Bring u to same level as v
        int diff = depth[u] - depth[v];
        for (int i = 0; i < LOG; i++) {
            if ((diff >> i) & 1) {
                u = parent[u][i];
            }
        }
        
        if (u == v) return u;
        
        // Binary search for LCA
        for (int i = LOG - 1; i >= 0; i--) {
            if (parent[u][i] != parent[v][i]) {
                u = parent[u][i];
                v = parent[v][i];
            }
        }
        
        return parent[u][0];
    }
};
```

**How it works:**
```
Tree:
      0
     / \
    1   2
   / \
  3   4

parent table:
       [0] [1] [2]  (2^0, 2^1, 2^2 ancestors)
node 0: -1  -1  -1
node 1:  0  -1  -1
node 2:  0  -1  -1
node 3:  1   0  -1
node 4:  1   0  -1

LCA(3, 4):
  Both at depth 2
  parent[3][0] = 1 != parent[4][0] = 1... wait, they're equal!
  Actually: parent[3][0] = parent[4][0] = 1
  Return parent[3][0] = 1 ‚úì
```

**Time:** 
- Preprocessing: O(n log n)
- Query: O(log n)
- Total for q queries: O(n log n + q log n)

**Use when:** Many LCA queries (q > n)

---

## Binary Search Trees (BST)

### BST Property

**For every node:**
- All nodes in **left** subtree < node
- All nodes in **right** subtree > node

```
Valid BST:
    4
   / \
  2   6
 / \ / \
1  3 5  7

Inorder: 1 2 3 4 5 6 7 (sorted!) ‚úì

Invalid BST:
    4
   / \
  2   6
 / \
1  5  ‚Üê 5 > 4, should be in right subtree ‚úó
```

### BST Search

**Time:** O(h) where h = height

```cpp
TreeNode* search(TreeNode* root, int val) {
    if (!root || root->val == val) return root;
    
    if (val < root->val) {
        return search(root->left, val);  // Search left
    } else {
        return search(root->right, val);  // Search right
    }
}
```

**Iterative:**
```cpp
TreeNode* search(TreeNode* root, int val) {
    while (root && root->val != val) {
        if (val < root->val) {
            root = root->left;
        } else {
            root = root->right;
        }
    }
    return root;
}
```

**Trace:**
```
BST:
    4
   / \
  2   6
 / \ / \
1  3 5  7

Search for 5:
  Start at 4
  5 > 4, go right
  Now at 6
  5 < 6, go left
  Now at 5, found! ‚úì
```

### BST Insert

```cpp
TreeNode* insert(TreeNode* root, int val) {
    if (!root) return new TreeNode(val);
    
    if (val < root->val) {
        root->left = insert(root->left, val);
    } else if (val > root->val) {
        root->right = insert(root->right, val);
    }
    // If val == root->val, do nothing (no duplicates)
    
    return root;
}
```

**How it works:**
```
BST:
    4
   / \
  2   6
 / \
1  3

Insert 5:

insert(4, 5):
  5 > 4, go right
  insert(6, 5):
    5 < 6, go left
    insert(null, 5):
      return new TreeNode(5)
    6->left = 5
    return 6
  4->right = 6
  return 4

Result:
    4
   / \
  2   6
 / \ /
1  3 5 ‚úì
```

**Iterative:**
```cpp
TreeNode* insert(TreeNode* root, int val) {
    if (!root) return new TreeNode(val);
    
    TreeNode* curr = root;
    while (true) {
        if (val < curr->val) {
            if (!curr->left) {
                curr->left = new TreeNode(val);
                break;
            }
            curr = curr->left;
        } else {
            if (!curr->right) {
                curr->right = new TreeNode(val);
                break;
            }
            curr = curr->right;
        }
    }
    
    return root;
}
```

---

## BST Operations

### BST Delete (Most Complex!)

**Three cases:**
1. **Leaf node:** Just remove
2. **One child:** Replace with child
3. **Two children:** Replace with inorder successor (or predecessor)

```cpp
TreeNode* deleteNode(TreeNode* root, int key) {
    if (!root) return nullptr;
    
    if (key < root->val) {
        root->left = deleteNode(root->left, key);
    } else if (key > root->val) {
        root->right = deleteNode(root->right, key);
    } else {
        // Found node to delete
        
        // Case 1: Leaf or one child
        if (!root->left) {
            TreeNode* temp = root->right;
            delete root;
            return temp;
        } else if (!root->right) {
            TreeNode* temp = root->left;
            delete root;
            return temp;
        }
        
        // Case 2: Two children
        // Find inorder successor (smallest in right subtree)
        TreeNode* successor = findMin(root->right);
        root->val = successor->val;  // Copy value
        root->right = deleteNode(root->right, successor->val);  // Delete successor
    }
    
    return root;
}

TreeNode* findMin(TreeNode* root) {
    while (root->left) {
        root = root->left;
    }
    return root;
}
```

**How it works:**
```
BST:
      5
     / \
    3   7
   / \ / \
  2  4 6  8

Delete 3 (two children):

Step 1: Find inorder successor of 3
  Smallest in right subtree of 3
  = findMin(4) = 4

Step 2: Replace 3 with 4
      5
     / \
    4   7
   / \ / \
  2  4 6  8  ‚Üê duplicate 4!

Step 3: Delete original 4 from right subtree
  deleteNode(4, 4)
  4 is leaf, just remove

Result:
      5
     / \
    4   7
   /   / \
  2   6   8 ‚úì

Inorder: 2 4 5 6 7 8 (still sorted!)
```

**Visual trace for all cases:**

**Case 1a: Delete leaf (2)**
```
Before:        After:
    5            5
   / \          / \
  3   7        3   7
 /             
2              
```

**Case 1b: Delete one child (3, if 2 didn't exist)**
```
Before:        After:
    5            5
   / \          / \
  3   7        4   7
   \
    4
```

**Case 2: Delete two children (5)**
```
Before:        After:
      5            6  ‚Üê successor
     / \          / \
    3   7        3   7
   / \ / \      / \   \
  2  4 6  8    2  4    8
```

**Why inorder successor?**
- Successor is **smallest** node > current
- Maintains BST property!
- Alternative: Use predecessor (largest in left subtree)

### Find Minimum/Maximum

```cpp
TreeNode* findMin(TreeNode* root) {
    while (root && root->left) {
        root = root->left;
    }
    return root;
}

TreeNode* findMax(TreeNode* root) {
    while (root && root->right) {
        root = root->right;
    }
    return root;
}
```

### BST Successor/Predecessor

**Successor:** Next larger node in inorder traversal

```cpp
TreeNode* successor(TreeNode* root, TreeNode* node) {
    // Case 1: Node has right subtree
    if (node->right) {
        return findMin(node->right);
    }
    
    // Case 2: Go up until we take left turn
    TreeNode* succ = nullptr;
    while (root) {
        if (node->val < root->val) {
            succ = root;
            root = root->left;
        } else if (node->val > root->val) {
            root = root->right;
        } else {
            break;
        }
    }
    
    return succ;
}
```

**Example:**
```
BST:
      5
     / \
    3   7
   / \ / \
  2  4 6  8

Successor of 3:
  Has right child (4)
  Return findMin(4) = 4 ‚úì

Successor of 4:
  No right child
  Go up: 4 < 5, succ = 5
  Return 5 ‚úì

Successor of 8:
  No right child
  Go up: 8 > 7, 8 > 5
  Return null ‚úì
```

---

## Validate BST

### Method 1: Inorder Traversal

**BST inorder must be strictly increasing!**

```cpp
bool isValidBST(TreeNode* root) {
    vector<int> inorder;
    inorderTraversal(root, inorder);
    
    for (int i = 1; i < inorder.size(); i++) {
        if (inorder[i] <= inorder[i-1]) {
            return false;
        }
    }
    
    return true;
}

void inorderTraversal(TreeNode* root, vector<int>& result) {
    if (!root) return;
    inorderTraversal(root->left, result);
    result.push_back(root->val);
    inorderTraversal(root->right, result);
}
```

**Space optimized:**
```cpp
bool isValidBST(TreeNode* root) {
    TreeNode* prev = nullptr;
    return validate(root, prev);
}

bool validate(TreeNode* root, TreeNode*& prev) {
    if (!root) return true;
    
    // Check left subtree
    if (!validate(root->left, prev)) return false;
    
    // Check current node
    if (prev && prev->val >= root->val) return false;
    
    prev = root;
    
    // Check right subtree
    return validate(root->right, prev);
}
```

### Method 2: Range Validation (Best!)

**Track valid range for each node.**

```cpp
bool isValidBST(TreeNode* root) {
    return validate(root, LONG_MIN, LONG_MAX);
}

bool validate(TreeNode* root, long minVal, long maxVal) {
    if (!root) return true;
    
    // Check if current node is in valid range
    if (root->val <= minVal || root->val >= maxVal) {
        return false;
    }
    
    // Left subtree: values must be < root->val
    // Right subtree: values must be > root->val
    return validate(root->left, minVal, root->val) &&
           validate(root->right, root->val, maxVal);
}
```

**How it works:**
```
Tree:
    5
   / \
  3   7
 / \
1   6  ‚Üê Invalid! 6 > 5

validate(5, -‚àû, +‚àû):
  5 in (-‚àû, +‚àû) ‚úì
  
  Left: validate(3, -‚àû, 5)
    3 in (-‚àû, 5) ‚úì
    
    Left: validate(1, -‚àû, 3)
      1 in (-‚àû, 3) ‚úì
      return true
      
    Right: validate(6, 3, 5)
      6 in (3, 5)? NO! 6 >= 5 ‚úó
      return false
      
  return false ‚úó

Why invalid: 6 is in left subtree of 5, but 6 > 5!
```

**Common mistake:**
```cpp
// WRONG! Only checks immediate children
bool isValidBST(TreeNode* root) {
    if (!root) return true;
    
    if (root->left && root->left->val >= root->val) return false;
    if (root->right && root->right->val <= root->val) return false;
    
    return isValidBST(root->left) && isValidBST(root->right);
}

// Fails on:
    10
   /  \
  5    15
      /  \
     6   20
     
// 6 < 15 ‚úì but 6 < 10 ‚úó (entire right subtree must be > 10)
```

**Time:** O(n), **Space:** O(h)

---

## Advanced Patterns

### Pattern 1: Construct BST from Preorder

**Preorder:** Root first, then left, then right

```cpp
TreeNode* bstFromPreorder(vector<int>& preorder) {
    int index = 0;
    return build(preorder, index, INT_MIN, INT_MAX);
}

TreeNode* build(vector<int>& preorder, int& index, int minVal, int maxVal) {
    if (index >= preorder.size()) return nullptr;
    
    int val = preorder[index];
    
    // Check if current value is in valid range
    if (val < minVal || val > maxVal) return nullptr;
    
    TreeNode* root = new TreeNode(val);
    index++;
    
    // Build left and right subtrees
    root->left = build(preorder, index, minVal, val);
    root->right = build(preorder, index, val, maxVal);
    
    return root;
}
```

**Example:**
```
preorder = [8, 5, 1, 7, 10, 12]

index=0: Create 8, range (-‚àû, +‚àû)
  Left: range (-‚àû, 8)
    index=1: Create 5, range (-‚àû, 8)
      Left: range (-‚àû, 5)
        index=2: Create 1
      Right: range (5, 8)
        index=3: Create 7
  Right: range (8, +‚àû)
    index=4: Create 10
      Right:
        index=5: Create 12

Result:
      8
     / \
    5   10
   / \    \
  1   7   12
```

### Pattern 2: Kth Smallest in BST

**Inorder traversal gives sorted sequence!**

```cpp
int kthSmallest(TreeNode* root, int k) {
    int count = 0;
    int result = -1;
    inorder(root, k, count, result);
    return result;
}

void inorder(TreeNode* root, int k, int& count, int& result) {
    if (!root || count >= k) return;
    
    inorder(root->left, k, count, result);
    
    count++;
    if (count == k) {
        result = root->val;
        return;
    }
    
    inorder(root->right, k, count, result);
}
```

**Iterative:**
```cpp
int kthSmallest(TreeNode* root, int k) {
    stack<TreeNode*> st;
    TreeNode* curr = root;
    
    while (curr || !st.empty()) {
        while (curr) {
            st.push(curr);
            curr = curr->left;
        }
        
        curr = st.top();
        st.pop();
        
        k--;
        if (k == 0) return curr->val;
        
        curr = curr->right;
    }
    
    return -1;
}
```

### Pattern 3: Convert Sorted Array to BST

**Build balanced BST from sorted array.**

```cpp
TreeNode* sortedArrayToBST(vector<int>& nums) {
    return build(nums, 0, nums.size() - 1);
}

TreeNode* build(vector<int>& nums, int left, int right) {
    if (left > right) return nullptr;
    
    int mid = left + (right - left) / 2;
    TreeNode* root = new TreeNode(nums[mid]);
    
    root->left = build(nums, left, mid - 1);
    root->right = build(nums, mid + 1, right);
    
    return root;
}
```

**Example:**
```
nums = [1, 2, 3, 4, 5, 6, 7]

mid = 3, create 4
  Left: [1, 2, 3]
    mid = 1, create 2
      Left: [1]
      Right: [3]
  Right: [5, 6, 7]
    mid = 5, create 6
      Left: [5]
      Right: [7]

Result:
      4
     / \
    2   6
   / \ / \
  1  3 5  7

Balanced! Height = 2
```

### Pattern 4: Serialize/Deserialize BST

**Preorder is enough for BST (no need for markers)!**

```cpp
// Serialize
string serialize(TreeNode* root) {
    if (!root) return "";
    
    string result = to_string(root->val);
    
    string left = serialize(root->left);
    string right = serialize(root->right);
    
    if (!left.empty()) result += "," + left;
    if (!right.empty()) result += "," + right;
    
    return result;
}

// Deserialize
TreeNode* deserialize(string data) {
    if (data.empty()) return nullptr;
    
    vector<int> preorder;
    stringstream ss(data);
    string val;
    
    while (getline(ss, val, ',')) {
        preorder.push_back(stoi(val));
    }
    
    int index = 0;
    return buildBST(preorder, index, INT_MIN, INT_MAX);
}

TreeNode* buildBST(vector<int>& preorder, int& index, int minVal, int maxVal) {
    if (index >= preorder.size()) return nullptr;
    
    int val = preorder[index];
    if (val < minVal || val > maxVal) return nullptr;
    
    TreeNode* root = new TreeNode(val);
    index++;
    
    root->left = buildBST(preorder, index, minVal, val);
    root->right = buildBST(preorder, index, val, maxVal);
    
    return root;
}
```

---

## Common Problems

### Problem 1: Symmetric Tree

**Check if tree is mirror of itself:**

```cpp
bool isSymmetric(TreeNode* root) {
    return isMirror(root, root);
}

bool isMirror(TreeNode* t1, TreeNode* t2) {
    if (!t1 && !t2) return true;
    if (!t1 || !t2) return false;
    
    return (t1->val == t2->val) &&
           isMirror(t1->left, t2->right) &&
           isMirror(t1->right, t2->left);
}
```

### Problem 2: Invert Binary Tree

```cpp
TreeNode* invertTree(TreeNode* root) {
    if (!root) return nullptr;
    
    // Swap children
    TreeNode* temp = root->left;
    root->left = invertTree(root->right);
    root->right = invertTree(temp);
    
    return root;
}
```

### Problem 3: Path Sum

```cpp
bool hasPathSum(TreeNode* root, int targetSum) {
    if (!root) return false;
    
    // Leaf node
    if (!root->left && !root->right) {
        return root->val == targetSum;
    }
    
    int remaining = targetSum - root->val;
    return hasPathSum(root->left, remaining) ||
           hasPathSum(root->right, remaining);
}
```

### Problem 4: Maximum Path Sum

```cpp
class Solution {
private:
    int maxSum;
    
    int maxGain(TreeNode* root) {
        if (!root) return 0;
        
        // Max gain from left and right (ignore negative)
        int leftGain = max(maxGain(root->left), 0);
        int rightGain = max(maxGain(root->right), 0);
        
        // Path through current node
        int pathSum = root->val + leftGain + rightGain;
        maxSum = max(maxSum, pathSum);
        
        // Return max gain if we continue to parent
        return root->val + max(leftGain, rightGain);
    }
    
public:
    int maxPathSum(TreeNode* root) {
        maxSum = INT_MIN;
        maxGain(root);
        return maxSum;
    }
};
```

### Problem 5: Flatten Tree to Linked List

**Flatten to preorder sequence:**

```cpp
void flatten(TreeNode* root) {
    if (!root) return;
    
    flatten(root->left);
    flatten(root->right);
    
    // Save right subtree
    TreeNode* rightSubtree = root->right;
    
    // Move left subtree to right
    root->right = root->left;
    root->left = nullptr;
    
    // Find end of new right subtree
    TreeNode* curr = root;
    while (curr->right) {
        curr = curr->right;
    }
    
    // Attach old right subtree
    curr->right = rightSubtree;
}
```

---

## Summary Tables

### Traversal Comparison

| Traversal | Order | Use Case | Iterative Difficulty |
|-----------|-------|----------|---------------------|
| Preorder | Root ‚Üí L ‚Üí R | Copy tree, prefix expression | Easy |
| Inorder | L ‚Üí Root ‚Üí R | BST sorting, infix expression | Medium |
| Postorder | L ‚Üí R ‚Üí Root | Delete tree, postfix expression | Hard |
| Level order | Level by level | BFS, shortest path | Easy |

### BST Operations

| Operation | Average | Worst | Space |
|-----------|---------|-------|-------|
| Search | O(log n) | O(n) | O(1) |
| Insert | O(log n) | O(n) | O(1) |
| Delete | O(log n) | O(n) | O(1) |
| Inorder | O(n) | O(n) | O(h) |
| Min/Max | O(log n) | O(n) | O(1) |

**Worst case:** Skewed tree (linked list)

### Height vs Depth

| Term | Definition | Example |
|------|------------|---------|
| Height | Distance to deepest leaf | height(root) = 2 |
| Depth | Distance from root | depth(leaf) = 2 |
| Level | Same as depth | level 0 = root |

### Tree Properties

| Property | Value |
|----------|-------|
| Leaf count (full binary tree) | (n+1)/2 |
| Max nodes at level i | 2^i |
| Max nodes (height h) | 2^(h+1) - 1 |
| Min height (n nodes) | ‚åàlog‚ÇÇ(n+1)‚åâ - 1 |

---

## Practice Problems

### Basic Traversals
- [ ] Binary Tree Preorder Traversal
- [ ] Binary Tree Inorder Traversal
- [ ] Binary Tree Postorder Traversal
- [ ] Binary Tree Level Order Traversal
- [ ] Binary Tree Zigzag Level Order

### Tree Properties
- [ ] Maximum Depth of Binary Tree
- [ ] Minimum Depth of Binary Tree
- [ ] Balanced Binary Tree
- [ ] Diameter of Binary Tree
- [ ] Symmetric Tree

### BST Operations
- [ ] Search in BST
- [ ] Insert into BST
- [ ] Delete Node in BST
- [ ] Validate Binary Search Tree
- [ ] Kth Smallest Element in BST

### LCA Problems
- [ ] Lowest Common Ancestor (Binary Tree)
- [ ] Lowest Common Ancestor (BST)
- [ ] Lowest Common Ancestor of Deepest Leaves

### Construction
- [ ] Construct Binary Tree from Preorder and Inorder
- [ ] Construct Binary Tree from Inorder and Postorder
- [ ] Convert Sorted Array to BST
- [ ] Serialize and Deserialize Binary Tree

### Advanced
- [ ] Binary Tree Maximum Path Sum
- [ ] Flatten Binary Tree to Linked List
- [ ] Count Complete Tree Nodes
- [ ] Recover Binary Search Tree
- [ ] Unique Binary Search Trees

---

## Key Takeaways

1. **Recursion is natural for trees** - Base case: null node
2. **Inorder of BST is sorted** - Key insight for many BST problems
3. **Level order uses queue (BFS)** - DFS uses stack or recursion
4. **Validate BST needs range** - Not just checking immediate children
5. **Diameter may not pass through root** - Check all nodes
6. **BST delete has 3 cases** - Leaf, one child, two children
7. **Height = -1 for null** (or 0, be consistent!)
8. **LCA: if both non-null, root is LCA** - Classic recursion pattern
9. **Iterative traversal needs stack** - Simulate recursion
10. **BST operations are O(h)** - Can be O(n) if unbalanced

Master these tree patterns and you'll solve any tree problem recursively or iteratively! üå≤

