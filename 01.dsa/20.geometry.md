# Computational Geometry

## Table of Contents
1. [Geometry Overview](#geometry-overview)
2. [Point and Vector Basics](#point-and-vector-basics)
3. [Orientation (CCW Test)](#orientation-ccw-test)
4. [Area Calculations](#area-calculations)
5. [Distance Formulas](#distance-formulas)
6. [Line Segment Intersection](#line-segment-intersection)
7. [Convex Hull: Graham Scan](#convex-hull-graham-scan)
8. [Convex Hull: Monotone Chain](#convex-hull-monotone-chain)
9. [Common Problems](#common-problems)

---

## Geometry Overview

### Fundamental Concepts

**Computational Geometry:** Algorithms for geometric problems.

**Common tasks:**
- Point relationships (collinear, orientation)
- Distance calculations
- Line/segment intersections
- Convex hulls
- Polygon operations

### Precision Issues

**Floating-point arithmetic is imprecise!**

```cpp
double a = 0.1 + 0.2;  // 0.30000000000000004
if (a == 0.3) { ... }  // FALSE!
```

**Solutions:**

**1. Epsilon comparison**
```cpp
const double EPS = 1e-9;

bool equals(double a, double b) {
    return abs(a - b) < EPS;
}

bool less(double a, double b) {
    return a < b - EPS;
}
```

**2. Integer coordinates** (when possible)
```cpp
struct Point {
    long long x, y;  // Use exact arithmetic
};
```

**3. Cross product for orientation** (avoids division)

---

## Point and Vector Basics

### Point Structure

```cpp
struct Point {
    double x, y;
    
    Point() : x(0), y(0) {}
    Point(double x, double y) : x(x), y(y) {}
    
    // Vector operations
    Point operator+(const Point& p) const {
        return Point(x + p.x, y + p.y);
    }
    
    Point operator-(const Point& p) const {
        return Point(x - p.x, y - p.y);
    }
    
    Point operator*(double t) const {
        return Point(x * t, y * t);
    }
    
    // Dot product
    double dot(const Point& p) const {
        return x * p.x + y * p.y;
    }
    
    // Cross product (z-component)
    double cross(const Point& p) const {
        return x * p.y - y * p.x;
    }
    
    double length() const {
        return sqrt(x * x + y * y);
    }
    
    double lengthSq() const {
        return x * x + y * y;
    }
};
```

### Vector Operations

**Dot product:**
```
A ¬∑ B = |A| |B| cos(Œ∏)
      = A.x √ó B.x + A.y √ó B.y

Properties:
  - A ¬∑ B > 0 ‚Üí angle < 90¬∞
  - A ¬∑ B = 0 ‚Üí perpendicular
  - A ¬∑ B < 0 ‚Üí angle > 90¬∞
```

**Cross product:**
```
A √ó B = |A| |B| sin(Œ∏)
      = A.x √ó B.y - A.y √ó B.x  (z-component in 2D)

Properties:
  - A √ó B > 0 ‚Üí B is counterclockwise from A
  - A √ó B = 0 ‚Üí collinear
  - A √ó B < 0 ‚Üí B is clockwise from A
```

**Visual:**
```
         B (ccw)
        /
       /
      /_____ A
     O

A √ó B > 0 (positive)


     O_____ A
      \
       \
        \
         B (cw)

A √ó B < 0 (negative)
```

---

## Orientation (CCW Test)

### What is Orientation?

**Given three points P, Q, R, determine their orientation:**
- Counterclockwise (CCW)
- Clockwise (CW)
- Collinear

**Visual:**
```
    R
   /
  /
 Q----P

CCW orientation


 Q----P
  \
   \
    R

CW orientation


Q----P----R

Collinear
```

### How Orientation Works

**Use cross product!**

**Compute:** `(Q - P) √ó (R - P)`

```
Vector PQ = Q - P
Vector PR = R - P

Cross product = PQ √ó PR = (Q.x - P.x) √ó (R.y - P.y) - (Q.y - P.y) √ó (R.x - P.x)

If cross > 0: CCW (left turn)
If cross < 0: CW (right turn)
If cross = 0: Collinear
```

**Why it works:**
```
Cross product gives signed area of parallelogram:
  - Positive area ‚Üí left turn
  - Negative area ‚Üí right turn
  - Zero area ‚Üí points on line
```

### Implementation

```cpp
int orientation(Point p, Point q, Point r) {
    double val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    
    if (abs(val) < EPS) return 0;  // Collinear
    return (val > 0) ? 1 : 2;       // 1 = CW, 2 = CCW
}

// Alternative: using cross product directly
int orientationCross(Point p, Point q, Point r) {
    Point pq = q - p;
    Point pr = r - p;
    
    double cross = pq.cross(pr);
    
    if (abs(cross) < EPS) return 0;  // Collinear
    return (cross > 0) ? 1 : -1;      // 1 = CCW, -1 = CW
}
```

### Complete Trace

```
Points:
  P = (0, 0)
  Q = (4, 4)
  R = (1, 2)

Compute orientation(P, Q, R):

PQ = Q - P = (4, 4)
PR = R - P = (1, 2)

Cross product = PQ √ó PR
              = 4 √ó 2 - 4 √ó 1
              = 8 - 4
              = 4

Result: 4 > 0 ‚Üí CCW ‚úì

Visual verification:
     Q(4,4)
    /
   /
  R(1,2)
 /
P(0,0)

R is to the left of line PQ ‚Üí CCW ‚úì
```

**Time:** O(1)

---

## Area Calculations

### Triangle Area

**Method 1: Cross product**
```cpp
double triangleArea(Point p, Point q, Point r) {
    Point pq = q - p;
    Point pr = r - p;
    
    return abs(pq.cross(pr)) / 2.0;
}
```

**Why it works:**
```
Cross product = |PQ| √ó |PR| √ó sin(Œ∏)
Triangle area = (1/2) √ó base √ó height
              = (1/2) √ó |PQ| √ó |PR| √ó sin(Œ∏)
              = |PQ √ó PR| / 2
```

**Method 2: Shoelace formula**
```cpp
double triangleAreaShoelace(Point p, Point q, Point r) {
    return abs((q.x - p.x) * (r.y - p.y) - (r.x - p.x) * (q.y - p.y)) / 2.0;
}
```

### Polygon Area

**Shoelace formula (Gauss's area formula):**

```cpp
double polygonArea(vector<Point>& points) {
    int n = points.size();
    double area = 0;
    
    for (int i = 0; i < n; i++) {
        int j = (i + 1) % n;
        area += points[i].x * points[j].y;
        area -= points[j].x * points[i].y;
    }
    
    return abs(area) / 2.0;
}
```

**How it works:**
```
Sum of cross products of consecutive vertices:

Area = (1/2) |Œ£ (x[i] √ó y[i+1] - x[i+1] √ó y[i])|

Visual:
  Positive contributions: counterclockwise edges
  Negative contributions: clockwise edges
  Net result: polygon area
```

### Complete Trace

```
Polygon: Square with vertices (0,0), (2,0), (2,2), (0,2)

Area calculation:

i=0: (0,0) to (2,0)
  area += 0 √ó 0 = 0
  area -= 2 √ó 0 = 0

i=1: (2,0) to (2,2)
  area += 2 √ó 2 = 4
  area -= 2 √ó 0 = 4

i=2: (2,2) to (0,2)
  area += 2 √ó 2 = 8
  area -= 0 √ó 2 = 8

i=3: (0,2) to (0,0)
  area += 0 √ó 0 = 8
  area -= 0 √ó 2 = 8

Final: |8| / 2 = 4 ‚úì
```

**Signed area:**
```
If you want orientation:
  Positive area ‚Üí CCW polygon
  Negative area ‚Üí CW polygon
  
Don't take absolute value!
```

---

## Distance Formulas

### Point to Point

```cpp
double distance(Point p1, Point p2) {
    double dx = p1.x - p2.x;
    double dy = p1.y - p2.y;
    return sqrt(dx * dx + dy * dy);
}

// Often sufficient to compare squared distances (avoid sqrt)
double distanceSq(Point p1, Point p2) {
    double dx = p1.x - p2.x;
    double dy = p1.y - p2.y;
    return dx * dx + dy * dy;
}
```

### Point to Line

**Line defined by two points A and B:**

```cpp
double pointToLine(Point p, Point a, Point b) {
    Point ab = b - a;
    Point ap = p - a;
    
    // Area of triangle = (1/2) √ó base √ó height
    // height = 2 √ó area / base
    double area = abs(ab.cross(ap));
    return area / ab.length();
}
```

**How it works:**
```
      p
     /|
    / |
   /  | h (distance)
  /   |
 a----+----b

Triangle area = (1/2) √ó |AB| √ó h
h = 2 √ó area / |AB|
area = |AB √ó AP| / 2
h = |AB √ó AP| / |AB|
```

### Point to Segment

**Segment has endpoints, unlike infinite line:**

```cpp
double pointToSegment(Point p, Point a, Point b) {
    Point ab = b - a;
    Point ap = p - a;
    Point bp = p - b;
    
    // If projection is before A
    if (ab.dot(ap) <= 0) {
        return ap.length();
    }
    
    // If projection is after B
    if (ab.dot(bp) >= 0) {
        return bp.length();
    }
    
    // Projection is on segment
    return pointToLine(p, a, b);
}
```

**Visual:**
```
Case 1: Projection before A
  p
   \
    \
     a--------b
     
Distance = |PA|


Case 2: Projection after B
     a--------b
               \
                \
                 p
                 
Distance = |PB|


Case 3: Projection on segment
      p
      |
      |
     a+-------b
     
Distance = perpendicular to line
```

### Complete Trace

```
Point p = (2, 3)
Segment: a = (0, 0), b = (4, 0)

Compute pointToSegment:

ab = (4, 0)
ap = (2, 3)
bp = (-2, 3)

ab ¬∑ ap = 4 √ó 2 + 0 √ó 3 = 8 > 0  (not before A)
ab ¬∑ bp = 4 √ó (-2) + 0 √ó 3 = -8 < 0  (not after B)

Projection is on segment, use pointToLine:

area = |ab √ó ap| = |4 √ó 3 - 0 √ó 2| = 12
|ab| = sqrt(16) = 4
distance = 12 / 4 = 3 ‚úì

Visual:
      p(2,3)
      |
      | 3
      |
     a(0,0)----(2,0)----b(4,0)
```

---

## Line Segment Intersection

### Do Segments Intersect?

**Two conditions must hold:**

**1. Orientation check:**
- Points of segment 1 must be on opposite sides of segment 2
- Points of segment 2 must be on opposite sides of segment 1

**2. Bounding box check** (for collinear case)

### Implementation

```cpp
bool onSegment(Point p, Point q, Point r) {
    // Check if q lies on segment pr (given p, q, r are collinear)
    return q.x <= max(p.x, r.x) && q.x >= min(p.x, r.x) &&
           q.y <= max(p.y, r.y) && q.y >= min(p.y, r.y);
}

bool segmentsIntersect(Point p1, Point q1, Point p2, Point q2) {
    int o1 = orientation(p1, q1, p2);
    int o2 = orientation(p1, q1, q2);
    int o3 = orientation(p2, q2, p1);
    int o4 = orientation(p2, q2, q1);
    
    // General case: different orientations
    if (o1 != o2 && o3 != o4) {
        return true;
    }
    
    // Special cases: collinear points
    if (o1 == 0 && onSegment(p1, p2, q1)) return true;
    if (o2 == 0 && onSegment(p1, q2, q1)) return true;
    if (o3 == 0 && onSegment(p2, p1, q2)) return true;
    if (o4 == 0 && onSegment(p2, q1, q2)) return true;
    
    return false;
}
```

### How It Works

**Orientation test:**
```
Segment 1: p1---q1
Segment 2: p2---q2

Check orientation(p1, q1, p2) and orientation(p1, q1, q2):
  - If different ‚Üí p2 and q2 are on opposite sides of line p1-q1
  
Check orientation(p2, q2, p1) and orientation(p2, q2, q1):
  - If different ‚Üí p1 and q1 are on opposite sides of line p2-q2

Both conditions ‚Üí segments intersect!
```

**Visual:**
```
Intersecting segments:

    q2
    |
  p1+---q1
    |
    p2

o1 = orientation(p1, q1, p2) = CCW
o2 = orientation(p1, q1, q2) = CW (different!)
o3 = orientation(p2, q2, p1) = CW
o4 = orientation(p2, q2, q1) = CCW (different!)

o1 ‚â† o2 AND o3 ‚â† o4 ‚Üí INTERSECT ‚úì


Non-intersecting segments:

    q2
    |
    |
    p2
    
p1-------q1

o1 = orientation(p1, q1, p2) = CCW
o2 = orientation(p1, q1, q2) = CCW (same!)

o1 = o2 ‚Üí NO INTERSECTION
```

### Complete Trace

```
Segment 1: p1 = (0, 0), q1 = (4, 4)
Segment 2: p2 = (0, 4), q2 = (4, 0)

Check intersection:

o1 = orientation(p1, q1, p2):
  PQ = (4, 4), PR = (0, 4)
  cross = 4√ó4 - 4√ó0 = 16 > 0 ‚Üí CCW (1)

o2 = orientation(p1, q1, q2):
  PQ = (4, 4), PR = (4, 0)
  cross = 4√ó0 - 4√ó4 = -16 < 0 ‚Üí CW (2)

o3 = orientation(p2, q2, p1):
  PQ = (4, -4), PR = (0, -4)
  cross = 4√ó(-4) - (-4)√ó0 = -16 < 0 ‚Üí CW (2)

o4 = orientation(p2, q2, q1):
  PQ = (4, -4), PR = (4, 0)
  cross = 4√ó0 - (-4)√ó4 = 16 > 0 ‚Üí CCW (1)

o1 ‚â† o2? YES (1 ‚â† 2)
o3 ‚â† o4? YES (2 ‚â† 1)

INTERSECT ‚úì

Visual:
  (0,4) p2
    ‚ï≤   ‚ï±
     ‚ï≤ ‚ï±  (segments cross at (2,2))
      ‚ï≥
     ‚ï± ‚ï≤
    ‚ï±   ‚ï≤
p1 (0,0)  (4,4) q1
              q2 (4,0)
```

### Finding Intersection Point

```cpp
Point intersectionPoint(Point p1, Point q1, Point p2, Point q2) {
    // Line 1: p1 + t √ó (q1 - p1)
    // Line 2: p2 + s √ó (q2 - p2)
    
    Point d1 = q1 - p1;
    Point d2 = q2 - p2;
    
    double cross = d1.cross(d2);
    if (abs(cross) < EPS) {
        // Parallel or collinear
        return Point(-1, -1);  // Invalid
    }
    
    Point p1p2 = p2 - p1;
    double t = p1p2.cross(d2) / cross;
    
    return p1 + d1 * t;
}
```

---

## Convex Hull: Graham Scan

### What is Convex Hull?

**Smallest convex polygon containing all points.**

**Convex:** No internal angle > 180¬∞

**Visual:**
```
Points:        Convex hull:

  ‚Ä¢  ‚Ä¢            *---*
 ‚Ä¢ ‚Ä¢ ‚Ä¢           / ‚Ä¢ ‚Ä¢ \
  ‚Ä¢ ‚Ä¢           *   ‚Ä¢   *
   ‚Ä¢             \  ‚Ä¢  /
                  *---*
```

### Graham Scan Algorithm

**Steps:**
1. Find point with lowest y-coordinate (bottom-most)
2. Sort points by polar angle from this point
3. Process points, keeping only left turns

**Key insight:** Use orientation test!
- Keep making left turns (CCW)
- If right turn (CW), pop previous point

### How Graham Scan Works

**Visual trace:**
```
Points: A, B, C, D, E, F, G

Step 1: Find lowest point (A)
        B
       /
      C
     /
    D
   /
  E---F
 /
A       G

Step 2: Sort by angle from A
Order: A, G, F, E, D, C, B

Step 3: Build hull
  Start: [A, G, F]
  
  Add E:
    Check orientation(G, F, E)
    If CW ‚Üí pop F
    
  Continue for all points...
```

### Implementation

```cpp
// Global reference point for sorting
Point p0;

// Compare by polar angle
bool compareAngle(const Point& p1, const Point& p2) {
    int o = orientation(p0, p1, p2);
    
    if (o == 0) {
        // Collinear: closer point first
        return p0.distanceSq(p1) < p0.distanceSq(p2);
    }
    
    return (o == 2);  // CCW (left turn)
}

vector<Point> grahamScan(vector<Point> points) {
    int n = points.size();
    if (n < 3) return points;
    
    // Find bottom-most point (or leftmost if tie)
    int minIdx = 0;
    for (int i = 1; i < n; i++) {
        if (points[i].y < points[minIdx].y ||
            (points[i].y == points[minIdx].y && points[i].x < points[minIdx].x)) {
            minIdx = i;
        }
    }
    
    swap(points[0], points[minIdx]);
    p0 = points[0];
    
    // Sort by polar angle
    sort(points.begin() + 1, points.end(), compareAngle);
    
    // Build convex hull
    vector<Point> hull;
    hull.push_back(points[0]);
    hull.push_back(points[1]);
    hull.push_back(points[2]);
    
    for (int i = 3; i < n; i++) {
        // Remove points that make right turn
        while (hull.size() > 1 &&
               orientation(hull[hull.size()-2], hull[hull.size()-1], points[i]) != 2) {
            hull.pop_back();
        }
        hull.push_back(points[i]);
    }
    
    return hull;
}
```

### Complete Trace

```
Points: (0,0), (1,1), (2,2), (0,2), (4,0)

Step 1: Find lowest point
  (0,0) has lowest y ‚Üí p0 = (0,0)

Step 2: Sort by angle from (0,0)
  Points: (0,0), (4,0), (1,1), (2,2), (0,2)
          p0     0¬∞     45¬∞    45¬∞    90¬∞
  
  (2,2) and (1,1) both at 45¬∞:
    distance from (0,0): (1,1) closer
    Order: (1,1) before (2,2)
  
  Final: (0,0), (4,0), (1,1), (2,2), (0,2)

Step 3: Build hull
  hull = [(0,0), (4,0), (1,1)]
  
  i=3: Add (2,2)
    orientation((4,0), (1,1), (2,2)):
      PQ = (-3, 1), PR = (-2, 2)
      cross = -3√ó2 - 1√ó(-2) = -4 ‚â† CCW
    Pop (1,1)
    
    hull = [(0,0), (4,0)]
    
    orientation((0,0), (4,0), (2,2)):
      PQ = (4, 0), PR = (2, 2)
      cross = 4√ó2 - 0√ó2 = 8 > 0 ‚Üí CCW ‚úì
    Add (2,2)
    
    hull = [(0,0), (4,0), (2,2)]
  
  i=4: Add (0,2)
    orientation((4,0), (2,2), (0,2)):
      PQ = (-2, 2), PR = (-4, 2)
      cross = -2√ó2 - 2√ó(-4) = 4 > 0 ‚Üí CCW ‚úì
    Add (0,2)
    
    hull = [(0,0), (4,0), (2,2), (0,2)]

Final hull: [(0,0), (4,0), (2,2), (0,2)]

Visual:
  (0,2)-----(2,2)
    |         /
    |       /
    |     /
  (0,0)-----(4,0)
```

**Time:** O(n log n) - dominated by sorting  
**Space:** O(n)

---

## Convex Hull: Monotone Chain

### What is Monotone Chain?

**Andrew's algorithm:** Build upper and lower hulls separately.

**Advantages over Graham Scan:**
- No polar angle calculation (more stable)
- No global reference point
- Easier to implement correctly

### How Monotone Chain Works

**Steps:**
1. Sort points by x-coordinate (then y)
2. Build lower hull (left to right)
3. Build upper hull (right to left)
4. Concatenate hulls

**Why it works:**
```
Lower hull: bottommost boundary
Upper hull: topmost boundary
Combined: complete convex hull

      Upper hull
     ‚Üê-----------
    /             \
   /               \
  /                 \
 -------------------‚Üí
     Lower hull
```

### Implementation

```cpp
vector<Point> monotoneChain(vector<Point> points) {
    int n = points.size();
    if (n < 3) return points;
    
    // Sort by x, then y
    sort(points.begin(), points.end(), [](const Point& a, const Point& b) {
        return a.x < b.x || (a.x == b.x && a.y < b.y);
    });
    
    vector<Point> hull;
    
    // Build lower hull
    for (int i = 0; i < n; i++) {
        while (hull.size() >= 2 &&
               orientation(hull[hull.size()-2], hull[hull.size()-1], points[i]) != 2) {
            hull.pop_back();
        }
        hull.push_back(points[i]);
    }
    
    // Build upper hull
    int lowerSize = hull.size();
    for (int i = n - 2; i >= 0; i--) {
        while (hull.size() > lowerSize &&
               orientation(hull[hull.size()-2], hull[hull.size()-1], points[i]) != 2) {
            hull.pop_back();
        }
        hull.push_back(points[i]);
    }
    
    hull.pop_back();  // Remove duplicate endpoint
    
    return hull;
}
```

### Complete Trace

```
Points: (0,0), (2,0), (1,1), (2,2), (0,2)

Step 1: Sort by x, then y
  Sorted: (0,0), (0,2), (1,1), (2,0), (2,2)

Step 2: Build lower hull (left to right)
  
  i=0: Add (0,0)
    hull = [(0,0)]
  
  i=1: Add (0,2)
    hull = [(0,0), (0,2)]
  
  i=2: Add (1,1)
    orientation((0,0), (0,2), (1,1)):
      PQ = (0, 2), PR = (1, 1)
      cross = 0√ó1 - 2√ó1 = -2 < 0 ‚Üí CW
    Pop (0,2)
    
    hull = [(0,0), (1,1)]
  
  i=3: Add (2,0)
    orientation((0,0), (1,1), (2,0)):
      PQ = (1, 1), PR = (2, 0)
      cross = 1√ó0 - 1√ó2 = -2 < 0 ‚Üí CW
    Pop (1,1)
    
    orientation((0,0), (2,0)):
      Can't check with < 2 points
    
    hull = [(0,0), (2,0)]
  
  i=4: Add (2,2)
    orientation((0,0), (2,0), (2,2)):
      PQ = (2, 0), PR = (2, 2)
      cross = 2√ó2 - 0√ó2 = 4 > 0 ‚Üí CCW ‚úì
    
    hull = [(0,0), (2,0), (2,2)]
  
  lowerSize = 3

Step 3: Build upper hull (right to left)
  
  i=3: Add (2,0)
    orientation((2,0), (2,2), (2,0)):
      Points include duplicate, will be removed
    
    hull = [(0,0), (2,0), (2,2), (2,0)]
  
  i=2: Add (1,1)
    orientation((2,2), (2,0), (1,1)):
      PQ = (0, -2), PR = (-1, -1)
      cross = 0√ó(-1) - (-2)√ó(-1) = -2 < 0 ‚Üí CW
    Pop (2,0)
    
    hull = [(0,0), (2,0), (2,2), (1,1)]
  
  i=1: Add (0,2)
    orientation((2,2), (1,1), (0,2)):
      PQ = (-1, -1), PR = (-2, 0)
      cross = -1√ó0 - (-1)√ó(-2) = -2 < 0 ‚Üí CW
    Pop (1,1)
    
    orientation((2,0), (2,2), (0,2)):
      PQ = (0, 2), PR = (-2, 2)
      cross = 0√ó2 - 2√ó(-2) = 4 > 0 ‚Üí CCW ‚úì
    
    hull = [(0,0), (2,0), (2,2), (0,2)]
  
  i=0: Add (0,0) - duplicate of start

Step 4: Remove duplicate
  hull.pop_back() ‚Üí remove (0,0)
  
Final hull: [(0,0), (2,0), (2,2), (0,2)]

Visual:
  (0,2)-----(2,2)
    |         |
    |         |
  (0,0)-----(2,0)
```

**Time:** O(n log n)  
**Space:** O(n)

### Graham Scan vs Monotone Chain

| Feature | Graham Scan | Monotone Chain |
|---------|-------------|----------------|
| **Sorting** | Polar angle | x, y coordinates |
| **Stability** | Angle calculation tricky | More numerically stable |
| **Complexity** | O(n log n) | O(n log n) |
| **Implementation** | Moderate | Easier |
| **Degenerate cases** | Needs care | Handles naturally |

**Recommendation:** Use Monotone Chain for most problems!

---

## Common Problems

### Problem 1: Convex Hull

```cpp
vector<vector<int>> outerTrees(vector<vector<int>>& trees) {
    vector<Point> points;
    for (auto& t : trees) {
        points.push_back(Point(t[0], t[1]));
    }
    
    vector<Point> hull = monotoneChain(points);
    
    vector<vector<int>> result;
    for (auto& p : hull) {
        result.push_back({(int)p.x, (int)p.y});
    }
    
    return result;
}
```

### Problem 2: Erect the Fence (with collinear points)

```cpp
// Need to include collinear points on hull edges
vector<Point> convexHullWithCollinear(vector<Point> points) {
    // Use monotone chain but modify to keep collinear points
    // On last edge, add all collinear points
    
    vector<Point> hull = monotoneChain(points);
    
    // Check for collinear points on last edge
    if (hull.size() < 3) return hull;
    
    vector<Point> result = hull;
    Point last = hull.back();
    Point first = hull.front();
    
    for (auto& p : points) {
        if (orientation(last, first, p) == 0 && onSegment(last, p, first)) {
            bool exists = false;
            for (auto& h : hull) {
                if (abs(h.x - p.x) < EPS && abs(h.y - p.y) < EPS) {
                    exists = true;
                    break;
                }
            }
            if (!exists) result.push_back(p);
        }
    }
    
    return result;
}
```

### Problem 3: Minimum Area Rectangle

```cpp
int minAreaRect(vector<vector<int>>& points) {
    set<pair<int, int>> pointSet;
    for (auto& p : points) {
        pointSet.insert({p[0], p[1]});
    }
    
    int minArea = INT_MAX;
    
    // Try all pairs of points as diagonal
    for (int i = 0; i < points.size(); i++) {
        for (int j = i + 1; j < points.size(); j++) {
            int x1 = points[i][0], y1 = points[i][1];
            int x2 = points[j][0], y2 = points[j][1];
            
            // Check if other two corners exist
            if (x1 != x2 && y1 != y2) {
                if (pointSet.count({x1, y2}) && pointSet.count({x2, y1})) {
                    int area = abs(x1 - x2) * abs(y1 - y2);
                    minArea = min(minArea, area);
                }
            }
        }
    }
    
    return minArea == INT_MAX ? 0 : minArea;
}
```

### Problem 4: Valid Boomerang

```cpp
bool isBoomerang(vector<vector<int>>& points) {
    Point p1(points[0][0], points[0][1]);
    Point p2(points[1][0], points[1][1]);
    Point p3(points[2][0], points[2][1]);
    
    // Check if not collinear
    return orientation(p1, p2, p3) != 0;
}
```

### Problem 5: Max Points on a Line

```cpp
int maxPoints(vector<vector<int>>& points) {
    int n = points.size();
    if (n <= 2) return n;
    
    int maxCount = 0;
    
    for (int i = 0; i < n; i++) {
        map<pair<int, int>, int> slopes;
        int duplicate = 1;
        int localMax = 0;
        
        for (int j = i + 1; j < n; j++) {
            int dx = points[j][0] - points[i][0];
            int dy = points[j][1] - points[i][1];
            
            if (dx == 0 && dy == 0) {
                duplicate++;
                continue;
            }
            
            int g = __gcd(dx, dy);
            dx /= g;
            dy /= g;
            
            // Normalize: make dx positive
            if (dx < 0) {
                dx = -dx;
                dy = -dy;
            }
            
            slopes[{dx, dy}]++;
            localMax = max(localMax, slopes[{dx, dy}]);
        }
        
        maxCount = max(maxCount, localMax + duplicate);
    }
    
    return maxCount;
}
```

---

## Summary Tables

### Geometric Primitives

| Operation | Formula | Time |
|-----------|---------|------|
| **Distance** | ‚àö((x‚ÇÇ-x‚ÇÅ)¬≤ + (y‚ÇÇ-y‚ÇÅ)¬≤) | O(1) |
| **Dot product** | x‚ÇÅx‚ÇÇ + y‚ÇÅy‚ÇÇ | O(1) |
| **Cross product** | x‚ÇÅy‚ÇÇ - x‚ÇÇy‚ÇÅ | O(1) |
| **Triangle area** | \|cross\| / 2 | O(1) |
| **Orientation** | sign(cross) | O(1) |

### Algorithm Complexity

| Algorithm | Preprocessing | Query | Space |
|-----------|---------------|-------|-------|
| **Orientation** | - | O(1) | O(1) |
| **Segment intersection** | - | O(1) | O(1) |
| **Convex hull (Graham)** | O(n log n) | - | O(n) |
| **Convex hull (Monotone)** | O(n log n) | - | O(n) |

### Common Patterns

| Problem Type | Approach |
|--------------|----------|
| **Point orientation** | Cross product |
| **Collinearity** | Cross product = 0 |
| **Left/right turn** | Sign of cross product |
| **Segment intersection** | Orientation test |
| **Convex hull** | Graham scan or Monotone chain |
| **Point in polygon** | Ray casting or winding number |

---

## Practice Problems

### Orientation & Area
- [ ] Valid Boomerang
- [ ] Check if Point is Inside Triangle
- [ ] Max Points on a Line
- [ ] Largest Triangle Area

### Distance
- [ ] K Closest Points to Origin
- [ ] Minimum Distance Between Points
- [ ] Nearest Point to Path

### Line Segment Intersection
- [ ] Line Reflection
- [ ] Mirror Reflection
- [ ] Rectangle Overlap

### Convex Hull
- [ ] Erect the Fence
- [ ] Convex Polygon
- [ ] Minimum Area Rectangle
- [ ] Number of Points Inside Circle

---

## Key Takeaways

1. **Cross product determines orientation** - Positive = CCW, negative = CW, zero = collinear
2. **Cross product = 2 √ó triangle area** - Signed area
3. **Use epsilon for floating-point comparison** - Never use `==` for doubles
4. **Prefer integer coordinates when possible** - Avoid floating-point errors
5. **Dot product for angle/projection** - Perpendicularity, distance to line
6. **Orientation test: (Q-P) √ó (R-P)** - Which side of line PQ is R?
7. **Segment intersection: check orientations** - Must differ on both segments
8. **Collinear special case** - Always check with bounding box
9. **Convex hull: keep only left turns** - Pop on right turn
10. **Graham scan: sort by polar angle** - From bottom-most point
11. **Monotone chain: sort by x-coordinate** - Build lower then upper hull
12. **Monotone chain more stable** - No angle calculation needed
13. **Shoelace formula for polygon area** - Sum of cross products
14. **Point to segment: check projection** - Three cases: before, on, after
15. **Always handle degenerate cases** - Duplicate points, collinearity, etc.

Master these geometry fundamentals and you'll handle any computational geometry problem! üìê

