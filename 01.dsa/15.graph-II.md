# Graph II - Shortest Paths & MST

## Table of Contents
1. [Shortest Path Overview](#shortest-path-overview)
2. [Dijkstra's Algorithm](#dijkstras-algorithm)
3. [0-1 BFS](#0-1-bfs)
4. [Bellman-Ford Algorithm](#bellman-ford-algorithm)
5. [Floyd-Warshall Algorithm](#floyd-warshall-algorithm)
6. [Minimum Spanning Tree (MST)](#minimum-spanning-tree-mst)
7. [Kruskal's Algorithm](#kruskals-algorithm)
8. [Prim's Algorithm](#prims-algorithm)
9. [Disjoint Set Union (DSU)](#disjoint-set-union-dsu)
10. [Union by Rank](#union-by-rank)
11. [Path Compression](#path-compression)
12. [Common Problems](#common-problems)

---

## Shortest Path Overview

### Problem Types

| Problem | Algorithm | Complexity | Constraints |
|---------|-----------|------------|-------------|
| **Single-source, non-negative** | Dijkstra | O(E log V) | Weights ‚â• 0 |
| **Single-source, 0-1 weights** | 0-1 BFS | O(V + E) | Weights ‚àà {0, 1} |
| **Single-source, negative** | Bellman-Ford | O(VE) | Detects neg cycles |
| **All-pairs shortest path** | Floyd-Warshall | O(V¬≥) | Works with negatives |

### When to Use Each

**Dijkstra:**
‚úÖ Single source to all vertices  
‚úÖ Non-negative weights  
‚úÖ Sparse or dense graphs  
‚úÖ Need shortest path tree  
‚ùå **FAILS with negative weights!**

**0-1 BFS:**
‚úÖ Weights are only 0 or 1  
‚úÖ Faster than Dijkstra for this case  
‚úÖ Common in grid problems

**Bellman-Ford:**
‚úÖ Negative edge weights allowed  
‚úÖ Detect negative cycles  
‚ùå Slower than Dijkstra

**Floyd-Warshall:**
‚úÖ All-pairs shortest paths  
‚úÖ Dense graphs (V ‚â§ 400)  
‚úÖ Negative edges (no neg cycles)  
‚úÖ Need path reconstruction

---

## Dijkstra's Algorithm

### How Dijkstra Works

**Key Idea:** Greedily pick closest unvisited vertex, relax its edges.

**Greedy choice:** Current shortest distance is final (proof: no negative weights).

**Algorithm:**
```
1. Initialize dist[source] = 0, others = ‚àû
2. Use min-heap with (distance, vertex)
3. While heap not empty:
   a. Extract min distance vertex u
   b. For each neighbor v of u:
      If dist[u] + weight(u,v) < dist[v]:
        Update dist[v]
        Add (dist[v], v) to heap
```

**Why it works:**
```
At each step, we pick the vertex u with smallest dist[u].
Claim: dist[u] is FINAL (won't improve).

Proof by contradiction:
  Assume better path exists: source ‚Üí ... ‚Üí x ‚Üí u
  Then dist[x] < dist[u] (negative weights impossible)
  So x would have been chosen before u.
  Contradiction! ‚úì
```

### Implementation

```cpp
vector<int> dijkstra(vector<vector<pair<int,int>>>& adj, int source) {
    int n = adj.size();
    vector<int> dist(n, INT_MAX);
    priority_queue<pair<int,int>, 
                   vector<pair<int,int>>, 
                   greater<pair<int,int>>> pq;  // Min heap
    
    dist[source] = 0;
    pq.push({0, source});  // {distance, vertex}
    
    while (!pq.empty()) {
        auto [d, u] = pq.top();
        pq.pop();
        
        // Skip if already processed with better distance
        if (d > dist[u]) continue;
        
        // Relax edges
        for (auto [v, w] : adj[u]) {
            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                pq.push({dist[v], v});
            }
        }
    }
    
    return dist;
}
```

**Complete trace:**
```
Graph:
    0 --1-- 1
    |       |
    4       2
    |       |
    2 --1-- 3

adj[0] = {(1,1), (2,4)}
adj[1] = {(0,1), (3,2)}
adj[2] = {(0,4), (3,1)}
adj[3] = {(1,2), (2,1)}

Dijkstra from 0:

Initial:
  dist = [0, ‚àû, ‚àû, ‚àû]
  pq = [(0, 0)]

Step 1: Extract (0, 0)
  Process vertex 0
  Relax edges:
    0‚Üí1 weight 1: dist[1] = min(‚àû, 0+1) = 1
    0‚Üí2 weight 4: dist[2] = min(‚àû, 0+4) = 4
  dist = [0, 1, 4, ‚àû]
  pq = [(1, 1), (4, 2)]

Step 2: Extract (1, 1)
  Process vertex 1
  Relax edges:
    1‚Üí0 weight 1: dist[0] = min(0, 1+1) = 0 (no change)
    1‚Üí3 weight 2: dist[3] = min(‚àû, 1+2) = 3
  dist = [0, 1, 4, 3]
  pq = [(3, 3), (4, 2)]

Step 3: Extract (3, 3)
  Process vertex 3
  Relax edges:
    3‚Üí1 weight 2: dist[1] = min(1, 3+2) = 1 (no change)
    3‚Üí2 weight 1: dist[2] = min(4, 3+1) = 4 (no change)
  dist = [0, 1, 4, 3]
  pq = [(4, 2)]

Step 4: Extract (4, 2)
  Process vertex 2
  Relax edges:
    2‚Üí0 weight 4: dist[0] = min(0, 4+4) = 0 (no change)
    2‚Üí3 weight 1: dist[3] = min(3, 4+1) = 3 (no change)
  dist = [0, 1, 4, 3]
  pq = []

Final: dist = [0, 1, 4, 3]
```

**Visual (shortest path tree):**
```
        0
       / \
      1   4
     /     \
    1       2
   /         \
  1           3
```

### With Path Reconstruction

```cpp
struct Result {
    vector<int> dist;
    vector<int> parent;
};

Result dijkstraWithPath(vector<vector<pair<int,int>>>& adj, int source) {
    int n = adj.size();
    vector<int> dist(n, INT_MAX);
    vector<int> parent(n, -1);
    priority_queue<pair<int,int>, 
                   vector<pair<int,int>>, 
                   greater<>> pq;
    
    dist[source] = 0;
    pq.push({0, source});
    
    while (!pq.empty()) {
        auto [d, u] = pq.top();
        pq.pop();
        
        if (d > dist[u]) continue;
        
        for (auto [v, w] : adj[u]) {
            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                parent[v] = u;
                pq.push({dist[v], v});
            }
        }
    }
    
    return {dist, parent};
}

vector<int> reconstructPath(vector<int>& parent, int target) {
    vector<int> path;
    for (int v = target; v != -1; v = parent[v]) {
        path.push_back(v);
    }
    reverse(path.begin(), path.end());
    return path;
}
```

**Time:** O((V + E) log V) with binary heap  
**Space:** O(V)

**Why log V?** Each vertex added to heap at most once per edge, heap ops are O(log V).

---

## 0-1 BFS

### When to Use

**Edges have weights 0 or 1 only.**

Examples:
- Move in grid: free (0) or through wall (1)
- State transitions: some free, some costly

**Key insight:** Can use deque instead of priority queue!

### How 0-1 BFS Works

**Idea:** Maintain deque where front has smallest distance.

**Rules:**
- **Weight 0:** Add to front (no cost increase)
- **Weight 1:** Add to back (cost increases by 1)

**Why it works:**
```
Deque maintains sorted order by distance:
  [dist=2, dist=2, dist=3, dist=3, dist=4]
  
When we process vertex with dist=d:
  - Edge weight 0 ‚Üí dist=d ‚Üí add to front
  - Edge weight 1 ‚Üí dist=d+1 ‚Üí add to back
  
Order preserved! No need for priority queue.
```

### Implementation

```cpp
vector<int> bfs01(vector<vector<pair<int,int>>>& adj, int source) {
    int n = adj.size();
    vector<int> dist(n, INT_MAX);
    deque<int> dq;
    
    dist[source] = 0;
    dq.push_back(source);
    
    while (!dq.empty()) {
        int u = dq.front();
        dq.pop_front();
        
        for (auto [v, w] : adj[u]) {
            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                
                if (w == 0) {
                    dq.push_front(v);  // No cost, higher priority
                } else {
                    dq.push_back(v);   // Cost 1, lower priority
                }
            }
        }
    }
    
    return dist;
}
```

**Complete trace:**
```
Graph (0-1 weights):
    0 -0‚Üí 1
    |     |
    1     0
    ‚Üì     ‚Üì
    2 -1‚Üí 3

adj[0] = {(1,0), (2,1)}
adj[1] = {(3,0)}
adj[2] = {(3,1)}
adj[3] = {}

0-1 BFS from 0:

Initial:
  dist = [0, ‚àû, ‚àû, ‚àû]
  dq = [0]

Step 1: Pop front = 0
  Edges:
    0‚Üí1 weight 0: dist[1] = 0+0 = 0, push_front(1)
    0‚Üí2 weight 1: dist[2] = 0+1 = 1, push_back(2)
  dist = [0, 0, 1, ‚àû]
  dq = [1, 2]  (1 at front!)

Step 2: Pop front = 1
  Edges:
    1‚Üí3 weight 0: dist[3] = 0+0 = 0, push_front(3)
  dist = [0, 0, 1, 0]
  dq = [3, 2]

Step 3: Pop front = 3
  No edges
  dq = [2]

Step 4: Pop front = 2
  Edges:
    2‚Üí3 weight 1: dist[3] = min(0, 1+1) = 0 (no change)
  dq = []

Final: dist = [0, 0, 1, 0]
```

**Why faster than Dijkstra:**
```
Dijkstra: O(E log V)  - heap operations
0-1 BFS: O(V + E)     - deque operations O(1)

For 0-1 weights, deque maintains order automatically!
```

**Time:** O(V + E)  
**Space:** O(V)

---

## Bellman-Ford Algorithm

### Why Bellman-Ford?

**Handles negative edge weights!**

Dijkstra fails with negative weights:
```
    0 -5‚Üí 1
    ‚Üì
    -10
    ‚Üì
    2

Dijkstra picks 0‚Üí1 (cost 5) as final.
But 0‚Üí2‚Üí? might be better if negative edges exist!
```

**Bellman-Ford:** Relax all edges V-1 times.

### How Bellman-Ford Works

**Key insight:** Shortest path has at most V-1 edges.

**Algorithm:**
```
1. Initialize dist[source] = 0, others = ‚àû
2. Repeat V-1 times:
   For each edge (u, v, w):
     dist[v] = min(dist[v], dist[u] + w)
3. Check for negative cycles:
   If any edge can still relax, negative cycle exists
```

**Why V-1 iterations?**
```
Shortest path from source to any vertex uses ‚â§ V-1 edges.
(Can't use all V vertices without a cycle)

After k iterations, distances up to k edges are correct.
After V-1 iterations, all distances are correct.
```

### Implementation

```cpp
struct Edge {
    int u, v, w;
};

vector<int> bellmanFord(vector<Edge>& edges, int n, int source) {
    vector<int> dist(n, INT_MAX);
    dist[source] = 0;
    
    // Relax all edges V-1 times
    for (int i = 0; i < n - 1; i++) {
        for (auto& [u, v, w] : edges) {
            if (dist[u] != INT_MAX && dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
            }
        }
    }
    
    // Check for negative cycles
    for (auto& [u, v, w] : edges) {
        if (dist[u] != INT_MAX && dist[u] + w < dist[v]) {
            // Negative cycle detected
            return {};  // Or mark vertices in cycle
        }
    }
    
    return dist;
}
```

**Complete trace:**
```
Graph:
    0 -1‚Üí 1
    ‚Üì     ‚Üì
   -2     2
    ‚Üì     ‚Üì
    2 -1‚Üí 3

Edges: (0,1,1), (0,2,-2), (1,3,2), (2,3,1)

Bellman-Ford from 0:

Initial:
  dist = [0, ‚àû, ‚àû, ‚àû]

Iteration 1:
  (0,1,1): dist[1] = min(‚àû, 0+1) = 1
  (0,2,-2): dist[2] = min(‚àû, 0-2) = -2
  (1,3,2): dist[3] = min(‚àû, 1+2) = 3
  (2,3,1): dist[3] = min(3, -2+1) = -1
  dist = [0, 1, -2, -1]

Iteration 2:
  (0,1,1): dist[1] = min(1, 0+1) = 1
  (0,2,-2): dist[2] = min(-2, 0-2) = -2
  (1,3,2): dist[3] = min(-1, 1+2) = -1
  (2,3,1): dist[3] = min(-1, -2+1) = -1
  dist = [0, 1, -2, -1] (no change)

Iteration 3 (V-1 = 3):
  No changes
  
Check for negative cycles:
  All edges satisfied, no negative cycle.

Final: dist = [0, 1, -2, -1]
```

**Negative cycle detection:**
```
Graph with negative cycle:
    0 -1‚Üí 1
    ‚Üë     ‚Üì
    2     -3
    ‚Üë     ‚Üì
    ‚Üê 1 ‚Üê 2

Cycle: 1‚Üí2‚Üí0‚Üí1 = -3 + 1 + 2 = 0? No wait:
Actually: 1‚Üí2 (-3), 2‚Üí0 (doesn't exist)

Better example:
    0 ‚Üí 1
    ‚Üë   ‚Üì
   -2  -1
    ‚Üë   ‚Üì
    ‚Üê 2 ‚Üê

Cycle: 0‚Üí1‚Üí2‚Üí0 = 1 + (-1) + (-2) = -2 (negative!)

After V-1 iterations, can still improve:
  dist[0] can decrease again ‚Üí negative cycle!
```

### Negative Cycle Detection

```cpp
vector<int> findNegativeCycle(vector<Edge>& edges, int n, int source) {
    vector<int> dist(n, INT_MAX);
    vector<int> parent(n, -1);
    dist[source] = 0;
    
    int cycleVertex = -1;
    
    for (int i = 0; i < n; i++) {
        cycleVertex = -1;
        for (auto& [u, v, w] : edges) {
            if (dist[u] != INT_MAX && dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                parent[v] = u;
                cycleVertex = v;  // Part of negative cycle
            }
        }
    }
    
    if (cycleVertex == -1) {
        return {};  // No negative cycle
    }
    
    // Trace back to find cycle
    for (int i = 0; i < n; i++) {
        cycleVertex = parent[cycleVertex];
    }
    
    vector<int> cycle;
    for (int v = cycleVertex; ; v = parent[v]) {
        cycle.push_back(v);
        if (v == cycleVertex && cycle.size() > 1) break;
    }
    reverse(cycle.begin(), cycle.end());
    
    return cycle;
}
```

**Time:** O(VE)  
**Space:** O(V)

---

## Floyd-Warshall Algorithm

### All-Pairs Shortest Path (APSP)

**Find shortest paths between ALL pairs of vertices.**

**Alternatives:**
- Run Dijkstra V times: O(V¬≤E log V) ‚âà O(V¬≥ log V)
- Run Bellman-Ford V times: O(V¬≤E) ‚âà O(V¬≥)
- Floyd-Warshall: O(V¬≥) - **simpler and works with negatives!**

### How Floyd-Warshall Works

**Key idea:** Dynamic programming with intermediate vertices.

**State:** `dist[k][i][j]` = shortest path from i to j using only vertices {0, 1, ..., k-1} as intermediates.

**Recurrence:**
```
dist[k][i][j] = min(
  dist[k-1][i][j],           // Don't use vertex k
  dist[k-1][i][k] + dist[k-1][k][j]  // Use vertex k
)
```

**Space optimization:** Use same matrix (order doesn't matter).

**Visual:**
```
Path from i to j using vertex k:
    i ‚Üí ... ‚Üí k ‚Üí ... ‚Üí j
    
Try adding k as intermediate:
  If i‚Üík‚Üíj is shorter than current i‚Üíj, update!
```

### Implementation

```cpp
vector<vector<int>> floydWarshall(int n, vector<vector<int>>& edges) {
    // Initialize distances
    vector<vector<int>> dist(n, vector<int>(n, INT_MAX / 2));
    
    // Distance to self = 0
    for (int i = 0; i < n; i++) {
        dist[i][i] = 0;
    }
    
    // Add edges
    for (auto& edge : edges) {
        int u = edge[0], v = edge[1], w = edge[2];
        dist[u][v] = w;
        // dist[v][u] = w;  // If undirected
    }
    
    // DP: Try each vertex as intermediate
    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                dist[i][j] = min(dist[i][j], 
                                 dist[i][k] + dist[k][j]);
            }
        }
    }
    
    return dist;
}
```

**Complete trace:**
```
Graph:
    0 -3‚Üí 1
    ‚Üì     ‚Üì
    8     1
    ‚Üì     ‚Üì
    2 -4‚Üí 3

Edges: (0,1,3), (0,2,8), (1,3,1), (2,3,4)

Initial distance matrix:
    0   1   2   3
0 [ 0   3   8   ‚àû ]
1 [ ‚àû   0   ‚àû   1 ]
2 [ ‚àû   ‚àû   0   4 ]
3 [ ‚àû   ‚àû   ‚àû   0 ]

k=0 (use vertex 0 as intermediate):
  Check all pairs (i,j):
    dist[1][2] = min(‚àû, dist[1][0] + dist[0][2]) = min(‚àû, ‚àû) = ‚àû
    dist[2][1] = min(‚àû, dist[2][0] + dist[0][1]) = min(‚àû, ‚àû) = ‚àû
    ... all ‚àû paths, no change

k=1 (use vertex 1):
  dist[0][3] = min(‚àû, dist[0][1] + dist[1][3]) 
             = min(‚àû, 3 + 1) = 4 ‚úì
  Other pairs don't improve
  
    0   1   2   3
0 [ 0   3   8   4 ]
1 [ ‚àû   0   ‚àû   1 ]
2 [ ‚àû   ‚àû   0   4 ]
3 [ ‚àû   ‚àû   ‚àû   0 ]

k=2 (use vertex 2):
  dist[0][3] = min(4, dist[0][2] + dist[2][3])
             = min(4, 8 + 4) = 4 (no change)

k=3 (use vertex 3):
  No improvements (3 is sink)

Final:
    0   1   2   3
0 [ 0   3   8   4 ]
1 [ ‚àû   0   ‚àû   1 ]
2 [ ‚àû   ‚àû   0   4 ]
3 [ ‚àû   ‚àû   ‚àû   0 ]

Path 0‚Üí3: 0‚Üí1‚Üí3 (cost 4)
```

### Path Reconstruction

```cpp
vector<vector<int>> floydWarshallWithPath(int n, vector<vector<int>>& edges) {
    vector<vector<int>> dist(n, vector<int>(n, INT_MAX / 2));
    vector<vector<int>> next(n, vector<int>(n, -1));
    
    for (int i = 0; i < n; i++) {
        dist[i][i] = 0;
        next[i][i] = i;
    }
    
    for (auto& edge : edges) {
        int u = edge[0], v = edge[1], w = edge[2];
        dist[u][v] = w;
        next[u][v] = v;
    }
    
    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (dist[i][k] + dist[k][j] < dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                    next[i][j] = next[i][k];  // Path goes through k
                }
            }
        }
    }
    
    return dist;
}

vector<int> reconstructPath(vector<vector<int>>& next, int u, int v) {
    if (next[u][v] == -1) return {};  // No path
    
    vector<int> path = {u};
    while (u != v) {
        u = next[u][v];
        path.push_back(u);
    }
    return path;
}
```

**Negative cycle detection:**
```cpp
bool hasNegativeCycle(vector<vector<int>>& dist, int n) {
    for (int i = 0; i < n; i++) {
        if (dist[i][i] < 0) {
            return true;  // Negative cycle through i
        }
    }
    return false;
}
```

**Time:** O(V¬≥)  
**Space:** O(V¬≤)

---

## Minimum Spanning Tree (MST)

### What is MST?

**Spanning tree:** Subgraph that:
- Connects all vertices
- Is a tree (no cycles)
- Uses V-1 edges

**Minimum spanning tree:** Spanning tree with minimum total edge weight.

**Visual:**
```
Graph:
    0 -1- 1
    |\   /|
    | \ / |
    4  X  2
    | / \ |
    |/   \|
    2 -3- 3

All spanning trees:
  Tree 1: edges (0,1,1), (1,3,2), (0,2,4) = weight 7
  Tree 2: edges (0,1,1), (1,3,2), (2,3,3) = weight 6 ‚úì
  ... many others

MST: minimum total weight
```

**Properties:**
- Graph must be connected
- MST is NOT unique if equal weights exist
- MST has exactly V-1 edges
- Adding any edge creates exactly one cycle

**Applications:**
- Network design (minimize cable cost)
- Clustering (minimum linkage)
- Approximation for TSP

---

## Kruskal's Algorithm

### How Kruskal Works

**Greedy approach:** Add cheapest edge that doesn't create cycle.

**Algorithm:**
```
1. Sort all edges by weight
2. Initialize empty MST
3. For each edge (u, v, w) in sorted order:
   If u and v not in same component:
     Add edge to MST
     Merge components
4. Return MST
```

**Key insight:** Use Disjoint Set Union (DSU) to check components!

### Implementation

```cpp
struct Edge {
    int u, v, w;
    bool operator<(const Edge& other) const {
        return w < other.w;
    }
};

class DSU {
    vector<int> parent, rank;
    
public:
    DSU(int n) : parent(n), rank(n, 0) {
        iota(parent.begin(), parent.end(), 0);
    }
    
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);  // Path compression
        }
        return parent[x];
    }
    
    bool unite(int x, int y) {
        int px = find(x), py = find(y);
        if (px == py) return false;  // Already in same set
        
        // Union by rank
        if (rank[px] < rank[py]) {
            parent[px] = py;
        } else if (rank[px] > rank[py]) {
            parent[py] = px;
        } else {
            parent[py] = px;
            rank[px]++;
        }
        return true;
    }
};

int kruskal(int n, vector<Edge>& edges) {
    sort(edges.begin(), edges.end());
    
    DSU dsu(n);
    int mstWeight = 0;
    int edgesUsed = 0;
    
    for (auto& [u, v, w] : edges) {
        if (dsu.unite(u, v)) {
            mstWeight += w;
            edgesUsed++;
            
            if (edgesUsed == n - 1) break;  // MST complete
        }
    }
    
    return mstWeight;
}
```

**Complete trace:**
```
Graph:
    0 -1- 1
    |     |
    4     2
    |     |
    2 -3- 3

Edges: (0,1,1), (1,3,2), (2,3,3), (0,2,4)

Kruskal:

Step 1: Sort edges by weight
  Sorted: [(0,1,1), (1,3,2), (2,3,3), (0,2,4)]

Step 2: Process edges

Edge (0,1,1):
  find(0) = 0, find(1) = 1 ‚Üí different sets
  Unite 0 and 1
  MST edges: [(0,1,1)]
  Components: {0,1}, {2}, {3}

Edge (1,3,2):
  find(1) = 0, find(3) = 3 ‚Üí different sets
  Unite 1 and 3 (really 0 and 3)
  MST edges: [(0,1,1), (1,3,2)]
  Components: {0,1,3}, {2}

Edge (2,3,3):
  find(2) = 2, find(3) = 0 ‚Üí different sets
  Unite 2 and 3 (really 2 and 0)
  MST edges: [(0,1,1), (1,3,2), (2,3,3)]
  Components: {0,1,2,3}

Edge (0,2,4):
  find(0) = 0, find(2) = 0 ‚Üí same set!
  Skip (would create cycle)

MST weight: 1 + 2 + 3 = 6
Edges used: 3 = V-1 ‚úì
```

**Visual of MST:**
```
    0 -1- 1
          |
          2
          |
    2 -3- 3

Total weight: 6
```

**Why it works (greedy proof):**
```
Cut property: For any cut (S, V-S), the minimum weight edge
crossing the cut is in some MST.

Kruskal always picks minimum weight edge not creating cycle.
This edge crosses some cut ‚Üí must be in MST.
```

**Time:** O(E log E + E Œ±(V)) ‚âà O(E log E)
- Sort edges: O(E log E)
- E union-find operations: O(E Œ±(V)) ‚âà O(E)
- Œ±(V) is inverse Ackermann, effectively constant

**Space:** O(V)

---

## Prim's Algorithm

### How Prim Works

**Greedy approach:** Grow MST from single vertex, always add cheapest edge.

**Algorithm:**
```
1. Start with arbitrary vertex in MST
2. Repeat until MST has V vertices:
   Find minimum weight edge (u, v) where:
     u in MST, v not in MST
   Add v to MST
3. Return MST
```

**Like Dijkstra, but minimize edge weight instead of distance!**

### Implementation

```cpp
int prim(vector<vector<pair<int,int>>>& adj, int n) {
    vector<bool> inMST(n, false);
    priority_queue<pair<int,int>,
                   vector<pair<int,int>>,
                   greater<>> pq;  // {weight, vertex}
    
    int mstWeight = 0;
    
    // Start from vertex 0
    pq.push({0, 0});
    
    while (!pq.empty()) {
        auto [w, u] = pq.top();
        pq.pop();
        
        if (inMST[u]) continue;  // Already in MST
        
        inMST[u] = true;
        mstWeight += w;
        
        // Add all edges from u to heap
        for (auto [v, weight] : adj[u]) {
            if (!inMST[v]) {
                pq.push({weight, v});
            }
        }
    }
    
    return mstWeight;
}
```

**Complete trace:**
```
Graph:
    0 -1- 1
    |     |
    4     2
    |     |
    2 -3- 3

adj[0] = {(1,1), (2,4)}
adj[1] = {(0,1), (3,2)}
adj[2] = {(0,4), (3,3)}
adj[3] = {(1,2), (2,3)}

Prim from 0:

Initial:
  inMST = [F, F, F, F]
  pq = [(0, 0)]
  mstWeight = 0

Step 1: Pop (0, 0)
  Add 0 to MST, weight += 0
  Add edges from 0:
    (1, 1) ‚Üí pq
    (4, 2) ‚Üí pq
  inMST = [T, F, F, F]
  pq = [(1, 1), (4, 2)]
  mstWeight = 0

Step 2: Pop (1, 1)
  Add 1 to MST, weight += 1
  Add edges from 1:
    (1, 0) ‚Üí 0 in MST, skip
    (2, 3) ‚Üí pq
  inMST = [T, T, F, F]
  pq = [(2, 3), (4, 2)]
  mstWeight = 1

Step 3: Pop (2, 3)
  Add 3 to MST, weight += 2
  Add edges from 3:
    (2, 1) ‚Üí 1 in MST, skip
    (3, 2) ‚Üí pq
  inMST = [T, T, F, T]
  pq = [(3, 2), (4, 2)]
  mstWeight = 3

Step 4: Pop (3, 2)
  Add 2 to MST, weight += 3
  Add edges from 2:
    (4, 0) ‚Üí 0 in MST, skip
    (3, 3) ‚Üí 3 in MST, skip
  inMST = [T, T, T, T]
  pq = [(4, 2)]  (will be skipped)
  mstWeight = 6

Step 5: Pop (4, 2)
  2 already in MST, skip

MST weight: 6 ‚úì
```

**With edge tracking:**
```cpp
vector<pair<int,int>> primWithEdges(vector<vector<pair<int,int>>>& adj, int n) {
    vector<bool> inMST(n, false);
    priority_queue<tuple<int,int,int>,
                   vector<tuple<int,int,int>>,
                   greater<>> pq;  // {weight, from, to}
    
    vector<pair<int,int>> mstEdges;
    
    pq.push({0, -1, 0});  // Start from 0, no parent
    
    while (!pq.empty()) {
        auto [w, from, u] = pq.top();
        pq.pop();
        
        if (inMST[u]) continue;
        
        inMST[u] = true;
        if (from != -1) {
            mstEdges.push_back({from, u});
        }
        
        for (auto [v, weight] : adj[u]) {
            if (!inMST[v]) {
                pq.push({weight, u, v});
            }
        }
    }
    
    return mstEdges;
}
```

**Time:** O(E log V) with binary heap  
**Space:** O(V)

### Kruskal vs Prim

| Aspect | Kruskal | Prim |
|--------|---------|------|
| **Approach** | Edge-based | Vertex-based |
| **Data structure** | DSU | Priority queue |
| **Better for** | Sparse graphs | Dense graphs |
| **Parallelizable** | Yes | No |
| **Implementation** | Simpler with DSU | Like Dijkstra |

---

## Disjoint Set Union (DSU)

### What is DSU?

**Also called Union-Find.**

**Operations:**
- `find(x)`: Which set does x belong to?
- `unite(x, y)`: Merge sets containing x and y

**Applications:**
- Kruskal's MST
- Cycle detection
- Connected components
- Dynamic connectivity

### Naive Implementation

```cpp
class DSU {
    vector<int> parent;
    
public:
    DSU(int n) : parent(n) {
        iota(parent.begin(), parent.end(), 0);  // parent[i] = i
    }
    
    int find(int x) {
        while (parent[x] != x) {
            x = parent[x];
        }
        return x;
    }
    
    void unite(int x, int y) {
        int px = find(x);
        int py = find(y);
        parent[px] = py;  // Attach x's tree to y
    }
};
```

**Problem:** Trees can become unbalanced!

```
Initial: 0  1  2  3  4

unite(0,1): 1
            |
            0

unite(0,2): 1
           /|
          0 2

unite(0,3): 1
          / | \
         0  2  3

unite(0,4): 1
          /|\ \
         0 2 3 4

find(0) walks through 1‚Üí0 = O(1)
find(4) walks through 1‚Üí4 = O(1)

But if we united in order 1-0, 2-0, 3-0, 4-0:
            4
            |
            3
            |
            2
            |
            1
            |
            0

find(0) walks 0‚Üí1‚Üí2‚Üí3‚Üí4 = O(n)! ‚úó
```

**Optimizations:**
1. **Union by rank** - Keep trees balanced
2. **Path compression** - Flatten tree during find

---

## Union by Rank

### How Union by Rank Works

**Idea:** Always attach smaller tree under larger tree.

**Rank:** Upper bound on tree height.

**Rule:**
- If `rank[x] < rank[y]`: Attach x under y
- If `rank[x] > rank[y]`: Attach y under x
- If `rank[x] == rank[y]`: Attach either, increment rank

**Why it works:**
```
Attaching smaller under larger keeps height small.

Example:
  Tree A (rank 2):     Tree B (rank 1):
       a                    b
      / \                   |
     /   \                  c
    ...  ...

Union by rank: Attach B under A
       a
      /|\
     / | \
    ... b ...
        |
        c

Height stays 2 (didn't increase)!

If we attached A under B:
       b
      / \
     c   a
        / \
       ...  ...

Height becomes 3 (increased)! ‚úó
```

### Implementation

```cpp
class DSU {
    vector<int> parent, rank;
    
public:
    DSU(int n) : parent(n), rank(n, 0) {
        iota(parent.begin(), parent.end(), 0);
    }
    
    int find(int x) {
        while (parent[x] != x) {
            x = parent[x];
        }
        return x;
    }
    
    bool unite(int x, int y) {
        int px = find(x);
        int py = find(y);
        
        if (px == py) return false;  // Already connected
        
        // Union by rank
        if (rank[px] < rank[py]) {
            parent[px] = py;
        } else if (rank[px] > rank[py]) {
            parent[py] = px;
        } else {
            parent[py] = px;
            rank[px]++;  // Heights equal, increment rank
        }
        
        return true;
    }
};
```

**Trace:**
```
Initial: parent = [0,1,2,3,4], rank = [0,0,0,0,0]

unite(0, 1):
  find(0) = 0, find(1) = 1
  rank[0] == rank[1] == 0
  parent[1] = 0, rank[0] = 1
  
  Tree: 0
        |
        1
  
  parent = [0,0,2,3,4], rank = [1,0,0,0,0]

unite(2, 3):
  find(2) = 2, find(3) = 3
  rank[2] == rank[3] == 0
  parent[3] = 2, rank[2] = 1
  
  Trees: 0    2
         |    |
         1    3
  
  parent = [0,0,2,2,4], rank = [1,0,1,0,0]

unite(0, 2):
  find(0) = 0, find(2) = 2
  rank[0] == rank[2] == 1
  parent[2] = 0, rank[0] = 2
  
  Tree: 0
       / \
      1   2
          |
          3
  
  parent = [0,0,0,2,4], rank = [2,0,1,0,0]

Height: 2 (optimal!)
```

**Time:** O(log n) per operation with union by rank alone

---

## Path Compression

### How Path Compression Works

**Idea:** During find, make all nodes point directly to root.

**Implementation:**
```cpp
int find(int x) {
    if (parent[x] != x) {
        parent[x] = find(parent[x]);  // Recursion + assignment
    }
    return parent[x];
}
```

**How it works:**
```
Before find(0):
       4
       |
       3
       |
       2
       |
       1
       |
       0

Call find(0):
  parent[0] = find(1)
    parent[1] = find(2)
      parent[2] = find(3)
        parent[3] = find(4)
          return 4
        parent[3] = 4
        return 4
      parent[2] = 4
      return 4
    parent[1] = 4
    return 4
  parent[0] = 4
  return 4

After find(0):
       4
     / | \ \
    0  1  2  3

All nodes point to root!
Next find(0) is O(1)!
```

**Iterative with path compression:**
```cpp
int find(int x) {
    int root = x;
    while (parent[root] != root) {
        root = parent[root];
    }
    
    // Compress path
    while (parent[x] != root) {
        int next = parent[x];
        parent[x] = root;
        x = next;
    }
    
    return root;
}
```

**Path halving (simpler optimization):**
```cpp
int find(int x) {
    while (parent[x] != x) {
        parent[x] = parent[parent[x]];  // Skip one level
        x = parent[x];
    }
    return x;
}
```

### Combined: Union by Rank + Path Compression

```cpp
class DSU {
    vector<int> parent, rank;
    
public:
    DSU(int n) : parent(n), rank(n, 0) {
        iota(parent.begin(), parent.end(), 0);
    }
    
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);  // Path compression
        }
        return parent[x];
    }
    
    bool unite(int x, int y) {
        int px = find(x);
        int py = find(y);
        
        if (px == py) return false;
        
        // Union by rank
        if (rank[px] < rank[py]) {
            parent[px] = py;
        } else if (rank[px] > rank[py]) {
            parent[py] = px;
        } else {
            parent[py] = px;
            rank[px]++;
        }
        
        return true;
    }
    
    bool connected(int x, int y) {
        return find(x) == find(y);
    }
};
```

**Time complexity (BOTH optimizations):**
- **Amortized O(Œ±(n))** per operation
- Œ±(n) is inverse Ackermann function
- Œ±(n) ‚â§ 4 for all practical n (even n = 2^65536)
- **Effectively constant time!**

**Proof (simplified):**
```
Union by rank: O(log n) height
Path compression: Amortizes to O(Œ±(n))

Combined: O(Œ±(n)) amortized per operation

For n operations: O(n Œ±(n)) total
```

---

## Common Problems

### Problem 1: Network Delay Time (Dijkstra)

```cpp
int networkDelayTime(vector<vector<int>>& times, int n, int k) {
    vector<vector<pair<int,int>>> adj(n + 1);
    
    for (auto& t : times) {
        adj[t[0]].push_back({t[1], t[2]});  // u ‚Üí v, weight w
    }
    
    vector<int> dist(n + 1, INT_MAX);
    priority_queue<pair<int,int>, 
                   vector<pair<int,int>>, 
                   greater<>> pq;
    
    dist[k] = 0;
    pq.push({0, k});
    
    while (!pq.empty()) {
        auto [d, u] = pq.top();
        pq.pop();
        
        if (d > dist[u]) continue;
        
        for (auto [v, w] : adj[u]) {
            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                pq.push({dist[v], v});
            }
        }
    }
    
    int maxDist = 0;
    for (int i = 1; i <= n; i++) {
        if (dist[i] == INT_MAX) return -1;  // Unreachable
        maxDist = max(maxDist, dist[i]);
    }
    
    return maxDist;
}
```

### Problem 2: Cheapest Flights Within K Stops (Bellman-Ford variant)

```cpp
int findCheapestPrice(int n, vector<vector<int>>& flights, 
                      int src, int dst, int k) {
    vector<int> dist(n, INT_MAX);
    dist[src] = 0;
    
    // Relax edges k+1 times (k stops = k+1 edges)
    for (int i = 0; i <= k; i++) {
        vector<int> temp = dist;
        
        for (auto& f : flights) {
            int u = f[0], v = f[1], w = f[2];
            if (dist[u] != INT_MAX) {
                temp[v] = min(temp[v], dist[u] + w);
            }
        }
        
        dist = temp;
    }
    
    return dist[dst] == INT_MAX ? -1 : dist[dst];
}
```

### Problem 3: Min Cost to Connect All Points (MST)

```cpp
int minCostConnectPoints(vector<vector<int>>& points) {
    int n = points.size();
    
    // Build complete graph with Manhattan distances
    vector<tuple<int,int,int>> edges;
    
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            int dist = abs(points[i][0] - points[j][0]) +
                       abs(points[i][1] - points[j][1]);
            edges.push_back({dist, i, j});
        }
    }
    
    // Kruskal's algorithm
    sort(edges.begin(), edges.end());
    
    DSU dsu(n);
    int totalCost = 0;
    int edgesUsed = 0;
    
    for (auto [w, u, v] : edges) {
        if (dsu.unite(u, v)) {
            totalCost += w;
            edgesUsed++;
            if (edgesUsed == n - 1) break;
        }
    }
    
    return totalCost;
}
```

### Problem 4: Number of Provinces (DSU)

```cpp
int findCircleNum(vector<vector<int>>& isConnected) {
    int n = isConnected.size();
    DSU dsu(n);
    
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (isConnected[i][j]) {
                dsu.unite(i, j);
            }
        }
    }
    
    // Count unique roots
    unordered_set<int> roots;
    for (int i = 0; i < n; i++) {
        roots.insert(dsu.find(i));
    }
    
    return roots.size();
}
```

---

## Summary Tables

### Shortest Path Algorithms

| Algorithm | Single/All | Negative | Cycle Detect | Complexity |
|-----------|------------|----------|--------------|------------|
| **BFS** | Single | No | - | O(V + E) |
| **0-1 BFS** | Single | No | - | O(V + E) |
| **Dijkstra** | Single | No | - | O(E log V) |
| **Bellman-Ford** | Single | Yes | Yes | O(VE) |
| **Floyd-Warshall** | All-pairs | Yes | Yes | O(V¬≥) |

### MST Algorithms

| Algorithm | Approach | Data Structure | Complexity | Best For |
|-----------|----------|----------------|------------|----------|
| **Kruskal** | Edge-based | DSU | O(E log E) | Sparse |
| **Prim** | Vertex-based | Priority queue | O(E log V) | Dense |

### DSU Optimizations

| Optimization | Complexity | Effect |
|--------------|------------|--------|
| **Naive** | O(n) | Linear chains |
| **Union by rank** | O(log n) | Balanced trees |
| **Path compression** | O(Œ±(n)) amortized | Flattened paths |
| **Both** | O(Œ±(n)) amortized | Nearly constant! |

---

## Practice Problems

### Shortest Paths
- [ ] Network Delay Time (Dijkstra)
- [ ] Path with Minimum Effort (0-1 BFS / Dijkstra)
- [ ] Cheapest Flights Within K Stops (Bellman-Ford)
- [ ] Find the City With Smallest Number of Neighbors (Floyd-Warshall)
- [ ] Shortest Path Visiting All Nodes

### MST
- [ ] Min Cost to Connect All Points
- [ ] Connecting Cities With Minimum Cost
- [ ] Optimize Water Distribution
- [ ] Find Critical and Pseudo-Critical Edges in MST

### DSU
- [ ] Number of Provinces
- [ ] Redundant Connection
- [ ] Accounts Merge
- [ ] Smallest String With Swaps
- [ ] Evaluate Division

---

## Key Takeaways

1. **Dijkstra REQUIRES non-negative weights** - Greedy choice fails otherwise
2. **0-1 BFS uses deque: weight 0 ‚Üí front, weight 1 ‚Üí back** - O(V+E) instead of O(E log V)
3. **Bellman-Ford relaxes V-1 times** - Shortest path uses ‚â§ V-1 edges
4. **Negative cycle: Can still improve after V-1 iterations** - Distance decreases infinitely
5. **Floyd-Warshall tries each vertex as intermediate** - DP on paths
6. **Kruskal: Sort edges, use DSU for cycle detection** - Edge-based greedy
7. **Prim: Like Dijkstra but minimize edge weight** - Vertex-based greedy
8. **MST has V-1 edges, total weight minimized** - Not unique if equal weights
9. **DSU with union by rank: Attach smaller tree to larger** - Height ‚â§ log n
10. **DSU with path compression: Point all to root during find** - Amortized O(Œ±(n))
11. **Combined DSU optimizations: Effectively O(1)** - Œ±(n) ‚â§ 4 for all practical n
12. **Floyd-Warshall finds all-pairs in O(V¬≥)** - Better than V runs of Dijkstra for dense graphs

Master these algorithms and you'll handle any shortest path or MST problem! üöÄ

