# Bit Manipulation - Complete Guide

## Table of Contents
1. [Bit Fundamentals](#bit-fundamentals)
2. [Basic Bit Operations](#basic-bit-operations)
3. [Set/Clear/Toggle Bits](#setcleartoggle-bits)
4. [Bit Masks](#bit-masks)
5. [Iterating Through Subsets](#iterating-through-subsets)
6. [XOR Tricks](#xor-tricks)
7. [Single/Double Unique Problems](#singledouble-unique-problems)
8. [Bit DP Introduction](#bit-dp-introduction)
9. [Advanced Patterns](#advanced-patterns)
10. [Common Problems](#common-problems)

---

## Bit Fundamentals

### Binary Representation

**Concept:** Numbers stored as binary (base 2) - each bit is 0 or 1.

**Example:**
```
Decimal: 13
Binary:  1101

Position:  3  2  1  0
Bit:       1  1  0  1
Value:     8  4  0  1
Sum:       8 + 4 + 1 = 13

General formula:
13 = 1√ó2¬≥ + 1√ó2¬≤ + 0√ó2¬π + 1√ó2‚Å∞
   = 8 + 4 + 0 + 1
```

### Bitwise Operators

| Operator | Name | Description | Example |
|----------|------|-------------|---------|
| `&` | AND | 1 if both bits are 1 | `5 & 3 = 1` |
| `\|` | OR | 1 if either bit is 1 | `5 \| 3 = 7` |
| `^` | XOR | 1 if bits are different | `5 ^ 3 = 6` |
| `~` | NOT | Flip all bits | `~5 = -6` |
| `<<` | Left shift | Shift bits left | `5 << 1 = 10` |
| `>>` | Right shift | Shift bits right | `5 >> 1 = 2` |

### Visual Examples

**AND (&):**
```
  5:  0101
  3:  0011
      ----
5&3:  0001 = 1

Only positions where BOTH have 1
```

**OR (|):**
```
  5:  0101
  3:  0011
      ----
5|3:  0111 = 7

Positions where EITHER has 1
```

**XOR (^):**
```
  5:  0101
  3:  0011
      ----
5^3:  0110 = 6

Positions where bits are DIFFERENT
```

**NOT (~):**
```
  5:  00000101 (8-bit representation)
~5:  11111010 = -6 (two's complement)

Flips all bits (0‚Üí1, 1‚Üí0)
```

**Left Shift (<<):**
```
  5:    0101
5<<1:  01010 = 10
5<<2: 010100 = 20

Each shift left multiplies by 2
x << n = x √ó 2‚Åø
```

**Right Shift (>>):**
```
  5:    0101
5>>1:   0010 = 2
5>>2:   0001 = 1

Each shift right divides by 2
x >> n = x / 2‚Åø
```

### Why Bit Manipulation?

**Advantages:**
‚úÖ **Fast:** Direct CPU operations  
‚úÖ **Memory efficient:** Pack multiple flags in one integer  
‚úÖ **Elegant:** Solve problems with few operations  
‚úÖ **Mathematical:** Beautiful properties (XOR, etc.)

**Use cases:**
- Optimization (space/time)
- Low-level programming
- Competitive programming
- Cryptography
- Graphics/game development

---

## Basic Bit Operations

### Check if Bit is Set

**Check if i-th bit is 1:**

```cpp
bool isBitSet(int num, int i) {
    return (num & (1 << i)) != 0;
}
```

**How it works:**
```
num = 13 = 1101, check bit 2

1 << 2 = 0100 (mask with only bit 2 set)

  1101 (13)
& 0100 (1<<2)
------
  0100 = 4 ‚â† 0, so bit 2 is SET ‚úì

Check bit 1:
  1101 (13)
& 0010 (1<<1)
------
  0000 = 0, so bit 1 is NOT SET ‚úì
```

### Count Set Bits (Population Count)

**Method 1: Loop through all bits**
```cpp
int countSetBits(int n) {
    int count = 0;
    while (n > 0) {
        count += (n & 1);  // Check last bit
        n >>= 1;           // Shift right
    }
    return count;
}
```

**Method 2: Brian Kernighan's Algorithm**
```cpp
int countSetBits(int n) {
    int count = 0;
    while (n > 0) {
        n &= (n - 1);  // Remove rightmost set bit
        count++;
    }
    return count;
}
```

**How it works:**
```
n = 13 = 1101

Iteration 1:
  n - 1 = 12 = 1100
  n & (n-1) = 1101 & 1100 = 1100
  count = 1

Iteration 2:
  n - 1 = 11 = 1011
  n & (n-1) = 1100 & 1011 = 1000
  count = 2

Iteration 3:
  n - 1 = 7 = 0111
  n & (n-1) = 1000 & 0111 = 0000
  count = 3

Result: 3 set bits
```

**Why `n & (n-1)` removes rightmost 1?**
```
n     = ...10110000
n - 1 = ...10101111  (borrows from rightmost 1)
         ‚Üë rightmost 1 becomes 0
           all bits to right flip

n & (n-1) = ...10100000
              ‚Üë rightmost 1 removed!
```

**Method 3: Built-in (fastest)**
```cpp
int countSetBits(int n) {
    return __builtin_popcount(n);  // GCC built-in
}
```

**Time:**
- Method 1: O(log n) - number of bits
- Method 2: O(k) - k = number of set bits
- Method 3: O(1) - hardware instruction

### Check if Power of 2

**A number is power of 2 if it has exactly 1 set bit.**

```cpp
bool isPowerOfTwo(int n) {
    return n > 0 && (n & (n - 1)) == 0;
}
```

**How it works:**
```
Powers of 2:
1  = 0001
2  = 0010
4  = 0100
8  = 1000
16 = 10000

Each has exactly 1 set bit!

For power of 2:
n     = 1000
n - 1 = 0111
n & (n-1) = 0000 ‚úì

For non-power of 2 (6):
n     = 0110 (has 2 set bits)
n - 1 = 0101
n & (n-1) = 0100 ‚â† 0 ‚úó
```

### Find Rightmost Set Bit

```cpp
int rightmostSetBit(int n) {
    return n & (-n);
}
```

**How it works:**
```
n    = 12 = 01100
-n in two's complement:
  ~n = ...10011
  +1 = ...10100

n & (-n):
  01100 (12)
& 10100 (-12)
-------
  00100 = 4 (rightmost set bit)

Visual:
n    = ...abc100  (rightmost 1 at position)
-n   = ...xyz100  (same rightmost 1, rest flipped)
n&-n = ...000100  (only rightmost 1 remains!)
```

---

## Set/Clear/Toggle Bits

### Set Bit (Make it 1)

**Set i-th bit to 1:**

```cpp
int setBit(int num, int i) {
    return num | (1 << i);
}
```

**How it works:**
```
num = 10 = 1010, set bit 2

1 << 2 = 0100

  1010 (10)
| 0100 (1<<2)
------
  1110 = 14 ‚úì

OR ensures bit becomes 1 regardless of original value
```

**Visual:**
```
Original:  1 0 1 0
Mask:      0 1 0 0  (1 << 2)
          ---------
Result:    1 1 1 0

Position 2 is now 1!
```

### Clear Bit (Make it 0)

**Clear i-th bit (set to 0):**

```cpp
int clearBit(int num, int i) {
    return num & ~(1 << i);
}
```

**How it works:**
```
num = 14 = 1110, clear bit 2

1 << 2 = 0100
~(1 << 2) = 1011 (flip mask)

  1110 (14)
& 1011 (~(1<<2))
------
  1010 = 10 ‚úì

AND with inverted mask clears specific bit
```

**Visual:**
```
Original:  1 1 1 0
Mask:      1 0 1 1  (~(1 << 2))
          ---------
Result:    1 0 1 0

Position 2 is now 0!
```

### Toggle Bit (Flip it)

**Toggle i-th bit (0‚Üí1, 1‚Üí0):**

```cpp
int toggleBit(int num, int i) {
    return num ^ (1 << i);
}
```

**How it works:**
```
num = 10 = 1010, toggle bit 2

1 << 2 = 0100

  1010 (10)
^ 0100 (1<<2)
------
  1110 = 14 (bit was 0, now 1) ‚úì

Toggle again:
  1110 (14)
^ 0100 (1<<2)
------
  1010 = 10 (bit was 1, now 0) ‚úì

XOR flips the bit!
```

**Visual:**
```
First toggle:
Original:  1 0 1 0
Mask:      0 1 0 0
          ---------
Result:    1 1 1 0  (0 became 1)

Second toggle:
Original:  1 1 1 0
Mask:      0 1 0 0
          ---------
Result:    1 0 1 0  (1 became 0)
```

### Update Bit (Set to specific value)

**Set i-th bit to value (0 or 1):**

```cpp
int updateBit(int num, int i, int value) {
    int mask = ~(1 << i);     // Clear bit i
    return (num & mask) | (value << i);  // Set to value
}
```

**How it works:**
```
num = 10 = 1010, set bit 1 to 1

Step 1: Clear bit 1
  mask = ~(1 << 1) = ~0010 = 1101
  num & mask = 1010 & 1101 = 1000

Step 2: Set bit 1 to value
  (1 << 1) = 0010
  1000 | 0010 = 1010 ... wait, already set!

Let me redo with bit 0 to 1:
num = 10 = 1010, set bit 0 to 1
  Clear: 1010 & 1110 = 1010
  Set: 1010 | 0001 = 1011 = 11 ‚úì
```

### Multiple Bit Operations

**Set multiple bits:**
```cpp
// Set bits at positions i, j, k
int setBits(int num, vector<int>& positions) {
    int mask = 0;
    for (int pos : positions) {
        mask |= (1 << pos);
    }
    return num | mask;
}
```

**Clear range of bits:**
```cpp
// Clear bits from i to j (inclusive)
int clearBitsRange(int num, int i, int j) {
    // Create mask with 1s everywhere except [i, j]
    int allOnes = ~0;
    int left = allOnes << (j + 1);     // 1s to left of j
    int right = (1 << i) - 1;          // 1s to right of i
    int mask = left | right;
    return num & mask;
}
```

**Example:**
```
num = 0b11111111 = 255, clear bits 3 to 5

j = 5, i = 3

left = ~0 << 6 = 11000000
right = (1 << 3) - 1 = 00000111
mask = left | right = 11000111

  11111111 (255)
& 11000111 (mask)
-----------
  11000111 = 199 ‚úì

Bits 3,4,5 cleared!
```

---

## Bit Masks

### What is a Bit Mask?

**Bit Mask:** An integer where each bit represents a boolean flag.

**Example:**
```
Permissions (8-bit):
  7 6 5 4 3 2 1 0
  ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ
  ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ READ
  ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ WRITE
  ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ EXECUTE
  ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ADMIN
  ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ...
  ...

mask = 0b00000111 = 7 means READ + WRITE + EXECUTE
```

### Common Mask Patterns

**Define flags:**
```cpp
const int READ    = 1 << 0;  // 0001
const int WRITE   = 1 << 1;  // 0010
const int EXECUTE = 1 << 2;  // 0100
const int ADMIN   = 1 << 3;  // 1000

// Combine permissions
int permissions = READ | WRITE | EXECUTE;  // 0111
```

**Check if flag is set:**
```cpp
bool hasPermission(int perms, int flag) {
    return (perms & flag) != 0;
}

// Usage
if (hasPermission(permissions, WRITE)) {
    // Can write
}
```

**Add permission:**
```cpp
permissions |= ADMIN;  // Add admin flag
// 0111 | 1000 = 1111
```

**Remove permission:**
```cpp
permissions &= ~WRITE;  // Remove write flag
// 1111 & 1101 = 1101
```

**Toggle permission:**
```cpp
permissions ^= EXECUTE;  // Toggle execute
// 1111 ^ 0100 = 1011
```

### Subset Representation

**Use bitmask to represent subset:**

```cpp
// Set S = {0, 1, 2, 3, 4}
// Subset {0, 2, 4} represented as:
// Bits: 4 3 2 1 0
//       1 0 1 0 1 = 21

int subset = (1 << 0) | (1 << 2) | (1 << 4);  // 21

// Check if element i is in subset
bool contains(int subset, int i) {
    return (subset & (1 << i)) != 0;
}

// Add element i to subset
int add(int subset, int i) {
    return subset | (1 << i);
}

// Remove element i from subset
int remove(int subset, int i) {
    return subset & ~(1 << i);
}

// Size of subset (count set bits)
int size(int subset) {
    return __builtin_popcount(subset);
}
```

**Example:**
```
Set S = {a, b, c, d} = {0, 1, 2, 3}

All subsets as bitmasks:
{}         = 0000 = 0
{a}        = 0001 = 1
{b}        = 0010 = 2
{a,b}      = 0011 = 3
{c}        = 0100 = 4
{a,c}      = 0101 = 5
{b,c}      = 0110 = 6
{a,b,c}    = 0111 = 7
{d}        = 1000 = 8
...
{a,b,c,d}  = 1111 = 15

Total: 2^4 = 16 subsets
```

---

## Iterating Through Subsets

### Pattern 1: All Subsets of N Elements

**Generate all 2^n subsets:**

```cpp
void allSubsets(int n) {
    int total = 1 << n;  // 2^n
    
    for (int mask = 0; mask < total; mask++) {
        cout << "Subset: ";
        for (int i = 0; i < n; i++) {
            if (mask & (1 << i)) {
                cout << i << " ";
            }
        }
        cout << "\n";
    }
}
```

**Trace for n=3:**
```
mask=0 (000): {}
mask=1 (001): {0}
mask=2 (010): {1}
mask=3 (011): {0,1}
mask=4 (100): {2}
mask=5 (101): {0,2}
mask=6 (110): {1,2}
mask=7 (111): {0,1,2}
```

**Time:** O(2^n √ó n)

### Pattern 2: All Subsets of Given Subset

**Iterate through all subsets of mask:**

```cpp
void allSubsetsOfMask(int mask) {
    int submask = mask;
    
    do {
        // Process submask
        cout << submask << " ";
        
        submask = (submask - 1) & mask;
    } while (submask != mask);
}
```

**How it works:**
```
mask = 11 = 1011 (represents {0,1,3})

submask = 1011 (11)
  Process 1011

submask = (1011 - 1) & 1011 = 1010 & 1011 = 1010 (10)
  Process 1010

submask = (1010 - 1) & 1011 = 1001 & 1011 = 1001 (9)
  Process 1001

submask = (1001 - 1) & 1011 = 1000 & 1011 = 1000 (8)
  Process 1000

submask = (1000 - 1) & 1011 = 0111 & 1011 = 0011 (3)
  Process 0011

submask = (0011 - 1) & 1011 = 0010 & 1011 = 0010 (2)
  Process 0010

submask = (0010 - 1) & 1011 = 0001 & 1011 = 0001 (1)
  Process 0001

submask = (0001 - 1) & 1011 = 0000 & 1011 = 0000 (0)
  Process 0000

submask = (0000 - 1) & 1011 = 1111 & 1011 = 1011
  Back to mask, stop!

Subsets: {0,1,3}, {1,3}, {0,3}, {3}, {0,1}, {1}, {0}, {}
```

**Time:** O(3^k) where k = popcount(mask)
- For each bit, 3 choices: in parent but not child, in both, in neither

### Pattern 3: Iterate with __builtin Functions

```cpp
// Count trailing zeros (position of rightmost 1)
int pos = __builtin_ctz(mask);  // Count Trailing Zeros

// Count leading zeros
int leading = __builtin_clz(mask);  // Count Leading Zeros

// Find and process each set bit
void processSetBits(int mask) {
    while (mask) {
        int pos = __builtin_ctz(mask);  // Find position
        cout << "Bit at position " << pos << "\n";
        mask &= (mask - 1);  // Remove rightmost 1
    }
}
```

**Example:**
```
mask = 12 = 1100

Iteration 1:
  __builtin_ctz(1100) = 2 (two trailing zeros)
  Process bit 2
  mask = 1100 & 1011 = 1000

Iteration 2:
  __builtin_ctz(1000) = 3
  Process bit 3
  mask = 1000 & 0111 = 0000

Done!
```

---

## XOR Tricks

### XOR Properties

**Key properties:**
1. `a ^ a = 0` - XOR with itself is 0
2. `a ^ 0 = a` - XOR with 0 is identity
3. `a ^ b = b ^ a` - Commutative
4. `(a ^ b) ^ c = a ^ (b ^ c)` - Associative
5. `a ^ b ^ b = a` - Cancel out

**Visual:**
```
5 ^ 5:
  0101
^ 0101
------
  0000 ‚úì

5 ^ 0:
  0101
^ 0000
------
  0101 ‚úì

5 ^ 3 ^ 3:
  0101 ^ 0011 ^ 0011
= 0110 ^ 0011
= 0101 ‚úì (3s cancel out)
```

### Swap Two Numbers

**Without temporary variable:**

```cpp
void swap(int& a, int& b) {
    a = a ^ b;
    b = a ^ b;  // b = (a ^ b) ^ b = a
    a = a ^ b;  // a = (a ^ b) ^ a = b
}
```

**How it works:**
```
a = 5 = 0101
b = 3 = 0011

Step 1: a = a ^ b
  a = 0101 ^ 0011 = 0110

Step 2: b = a ^ b
  b = 0110 ^ 0011 = 0101 = 5 ‚úì
  
Step 3: a = a ^ b
  a = 0110 ^ 0101 = 0011 = 3 ‚úì

Result: a=3, b=5 (swapped!)
```

### Find Missing Number

**Array 0 to n with one missing:**

```cpp
int missingNumber(vector<int>& nums) {
    int n = nums.size();
    int xorAll = 0;
    
    // XOR all numbers 0 to n
    for (int i = 0; i <= n; i++) {
        xorAll ^= i;
    }
    
    // XOR all numbers in array
    for (int num : nums) {
        xorAll ^= num;
    }
    
    return xorAll;  // Missing number
}
```

**How it works:**
```
nums = [0, 1, 3], n = 3, missing = 2

xorAll = 0 ^ 1 ^ 2 ^ 3 (expected)
       ^ 0 ^ 1 ^ 3     (actual)

All present numbers cancel out:
= 0^0 ^ 1^1 ^ 2 ^ 3^3
= 0   ^ 0   ^ 2 ^ 0
= 2 ‚úì

Only missing number remains!
```

**Alternative with sum:**
```cpp
int missingNumber(vector<int>& nums) {
    int n = nums.size();
    int expectedSum = n * (n + 1) / 2;
    int actualSum = 0;
    for (int num : nums) {
        actualSum += num;
    }
    return expectedSum - actualSum;
}
```

### Check if Two Numbers Differ at One Bit

```cpp
bool differAtOneBit(int a, int b) {
    int xorResult = a ^ b;
    return (xorResult & (xorResult - 1)) == 0;  // Power of 2 check
}
```

**How it works:**
```
a = 5 = 0101
b = 7 = 0111

a ^ b = 0010 (only bit 1 differs)

Check if 0010 is power of 2:
  0010 & 0001 = 0000 ‚úì

Yes! They differ at exactly one bit.
```

---

## Single/Double Unique Problems

### Pattern 1: Single Number (All Others Twice)

**Problem:** Every element appears twice except one. Find it.

```cpp
int singleNumber(vector<int>& nums) {
    int result = 0;
    for (int num : nums) {
        result ^= num;
    }
    return result;  // All pairs cancel, single remains
}
```

**How it works:**
```
nums = [4, 1, 2, 1, 2]

result = 0
  ^ 4 = 4
  ^ 1 = 4 ^ 1 = 5
  ^ 2 = 5 ^ 2 = 7
  ^ 1 = 7 ^ 1 = 6
  ^ 2 = 6 ^ 2 = 4 ‚úì

Rearranged:
= 0 ^ 4 ^ 1 ^ 1 ^ 2 ^ 2
= 0 ^ 4 ^ (1^1) ^ (2^2)
= 0 ^ 4 ^ 0 ^ 0
= 4 ‚úì
```

**Time:** O(n), **Space:** O(1)

### Pattern 2: Single Number II (All Others Thrice)

**Problem:** Every element appears 3 times except one.

**Key insight:** Use bit counting!

```cpp
int singleNumber(vector<int>& nums) {
    int result = 0;
    
    // Check each bit position
    for (int i = 0; i < 32; i++) {
        int count = 0;
        
        // Count how many numbers have this bit set
        for (int num : nums) {
            if (num & (1 << i)) {
                count++;
            }
        }
        
        // If count is not multiple of 3, single number has this bit
        if (count % 3 != 0) {
            result |= (1 << i);
        }
    }
    
    return result;
}
```

**How it works:**
```
nums = [2, 2, 3, 2]

Binary:
2 = 010
2 = 010
3 = 011
2 = 010

Count bits at each position:
Bit 0: 1 (from 3) ‚Üí 1 % 3 = 1 ‚úì Set in result
Bit 1: 4 (from 2,2,3,2) ‚Üí 4 % 3 = 1 ‚úì Set in result
Bit 2: 0 ‚Üí 0 % 3 = 0, not set

result = 011 = 3 ‚úì
```

**Time:** O(32n) = O(n), **Space:** O(1)

**Optimized with bit manipulation:**
```cpp
int singleNumber(vector<int>& nums) {
    int ones = 0, twos = 0;
    
    for (int num : nums) {
        twos |= ones & num;  // Add to twos if already in ones
        ones ^= num;         // Toggle in ones
        
        int threes = ones & twos;  // Bits appearing 3 times
        ones &= ~threes;           // Remove from ones
        twos &= ~threes;           // Remove from twos
    }
    
    return ones;
}
```

**State machine:**
```
Bit appears 0 times: ones=0, twos=0
Bit appears 1 time:  ones=1, twos=0
Bit appears 2 times: ones=0, twos=1
Bit appears 3 times: ones=0, twos=0 (reset)
```

### Pattern 3: Two Single Numbers (All Others Twice)

**Problem:** Two elements appear once, others twice. Find both.

```cpp
vector<int> singleNumber(vector<int>& nums) {
    // XOR all numbers
    int xorAll = 0;
    for (int num : nums) {
        xorAll ^= num;
    }
    // xorAll = a ^ b (the two unique numbers)
    
    // Find any set bit in xorAll (bit where a and b differ)
    int diffBit = xorAll & (-xorAll);  // Rightmost set bit
    
    // Partition numbers into two groups based on this bit
    int a = 0, b = 0;
    for (int num : nums) {
        if (num & diffBit) {
            a ^= num;  // Group 1
        } else {
            b ^= num;  // Group 2
        }
    }
    
    return {a, b};
}
```

**How it works:**
```
nums = [1, 2, 1, 3, 2, 5]

Step 1: XOR all
  xorAll = 1 ^ 2 ^ 1 ^ 3 ^ 2 ^ 5
         = (1^1) ^ (2^2) ^ 3 ^ 5
         = 0 ^ 0 ^ 3 ^ 5
         = 3 ^ 5
         = 011 ^ 101
         = 110 = 6

Step 2: Find diff bit
  6 = 0110
  diffBit = 6 & -6 = 0110 & 1010 = 0010 = 2 (bit 1)

Step 3: Partition by bit 1
  Group 1 (bit 1 set):
    2 = 010 ‚úì
    3 = 011 ‚úì
    2 = 010 ‚úì
    XOR: 2 ^ 3 ^ 2 = 3 ‚úì
    
  Group 2 (bit 1 not set):
    1 = 001
    1 = 001
    5 = 101
    XOR: 1 ^ 1 ^ 5 = 5 ‚úì

Result: [3, 5]
```

**Why this works:**
- `a ^ b` has bits set where a and b differ
- Partition by any differing bit puts a and b in different groups
- Each group has all pairs (cancel out) + one unique number

**Time:** O(n), **Space:** O(1)

---

## Bit DP Introduction

### What is Bit DP?

**Concept:** Use bitmask to represent state in dynamic programming.

**When to use:**
- Small state space (n ‚â§ 20)
- Need to track "visited" or "selected" items
- Subsets/permutations with constraints

**State representation:**
```
dp[mask] = best solution for subset represented by mask

mask = 101101 means elements {0, 2, 3, 5} are selected
```

### Pattern 1: Traveling Salesman Problem (TSP)

**Problem:** Visit all cities exactly once, minimize distance.

```cpp
int tsp(vector<vector<int>>& dist) {
    int n = dist.size();
    int VISITED_ALL = (1 << n) - 1;
    
    // dp[mask][i] = min cost to visit cities in mask, ending at i
    vector<vector<int>> dp(1 << n, vector<int>(n, INT_MAX));
    
    // Start from city 0
    dp[1][0] = 0;
    
    // Try all subsets
    for (int mask = 1; mask < (1 << n); mask++) {
        for (int i = 0; i < n; i++) {
            if (!(mask & (1 << i))) continue;  // i not in mask
            if (dp[mask][i] == INT_MAX) continue;
            
            // Try visiting next city j
            for (int j = 0; j < n; j++) {
                if (mask & (1 << j)) continue;  // j already visited
                
                int newMask = mask | (1 << j);
                dp[newMask][j] = min(dp[newMask][j], 
                                     dp[mask][i] + dist[i][j]);
            }
        }
    }
    
    // Find minimum cost ending at any city
    int result = INT_MAX;
    for (int i = 0; i < n; i++) {
        if (dp[VISITED_ALL][i] != INT_MAX) {
            result = min(result, dp[VISITED_ALL][i] + dist[i][0]);
        }
    }
    
    return result;
}
```

**How it works (n=4):**
```
Cities: 0, 1, 2, 3

State: mask = 0101 means visited cities 0 and 2

Transition:
  From mask=0101 at city 2, visit city 1:
    newMask = 0101 | 0010 = 0111
    dp[0111][1] = dp[0101][2] + dist[2][1]

Base case:
  dp[0001][0] = 0 (start at city 0)

Final answer:
  dp[1111][i] + dist[i][0] for all i
  (visited all, return to start)
```

**Time:** O(2^n √ó n¬≤), **Space:** O(2^n √ó n)

### Pattern 2: Assignment Problem

**Problem:** Assign n tasks to n people, minimize cost.

```cpp
int minCost(vector<vector<int>>& cost) {
    int n = cost.size();
    vector<int> dp(1 << n, INT_MAX);
    dp[0] = 0;  // No tasks assigned
    
    for (int mask = 0; mask < (1 << n); mask++) {
        if (dp[mask] == INT_MAX) continue;
        
        int person = __builtin_popcount(mask);  // Next person
        
        // Try assigning each unassigned task to this person
        for (int task = 0; task < n; task++) {
            if (mask & (1 << task)) continue;  // Task already assigned
            
            int newMask = mask | (1 << task);
            dp[newMask] = min(dp[newMask], dp[mask] + cost[person][task]);
        }
    }
    
    return dp[(1 << n) - 1];  // All tasks assigned
}
```

**How it works:**
```
cost = [[1,2,3],
        [3,2,1],
        [2,1,3]]

dp[000] = 0 (no tasks)

Person 0 assigns:
  dp[001] = 0 + cost[0][0] = 1
  dp[010] = 0 + cost[0][1] = 2
  dp[100] = 0 + cost[0][2] = 3

From dp[001] (task 0 assigned), person 1 assigns:
  dp[011] = 1 + cost[1][1] = 3
  dp[101] = 1 + cost[1][2] = 2

... continue until dp[111] (all assigned)
```

**Time:** O(2^n √ó n), **Space:** O(2^n)

### Pattern 3: Count Subsets with Property

**Problem:** Count subsets where sum is divisible by k.

```cpp
int countSubsets(vector<int>& nums, int k) {
    int n = nums.size();
    vector<int> dp(1 << n, 0);
    dp[0] = 1;  // Empty subset
    
    int count = 0;
    for (int mask = 0; mask < (1 << n); mask++) {
        // Calculate sum of subset
        int sum = 0;
        for (int i = 0; i < n; i++) {
            if (mask & (1 << i)) {
                sum += nums[i];
            }
        }
        
        if (sum % k == 0) {
            count++;
        }
    }
    
    return count;
}
```

**Optimized with DP:**
```cpp
int countSubsets(vector<int>& nums, int k) {
    int n = nums.size();
    // dp[mask][mod] = count of subsets with mask having sum ‚â° mod (mod k)
    vector<vector<int>> dp(1 << n, vector<int>(k, 0));
    dp[0][0] = 1;
    
    for (int mask = 0; mask < (1 << n); mask++) {
        for (int i = 0; i < n; i++) {
            if (mask & (1 << i)) {
                int prevMask = mask ^ (1 << i);
                for (int mod = 0; mod < k; mod++) {
                    int prevMod = (mod - nums[i] % k + k) % k;
                    dp[mask][mod] += dp[prevMask][prevMod];
                }
            }
        }
    }
    
    int count = 0;
    for (int mask = 0; mask < (1 << n); mask++) {
        count += dp[mask][0];
    }
    return count;
}
```

**Time:** O(2^n √ó n √ó k), **Space:** O(2^n √ó k)

### Common Bit DP Patterns

**1. Iterate through all masks:**
```cpp
for (int mask = 0; mask < (1 << n); mask++) {
    // Process mask
}
```

**2. Check if element i in mask:**
```cpp
if (mask & (1 << i)) {
    // Element i is in subset
}
```

**3. Add element i to mask:**
```cpp
int newMask = mask | (1 << i);
```

**4. Remove element i from mask:**
```cpp
int newMask = mask & ~(1 << i);
```

**5. Count elements in mask:**
```cpp
int count = __builtin_popcount(mask);
```

**6. Iterate through all submasks:**
```cpp
for (int submask = mask; submask > 0; submask = (submask - 1) & mask) {
    // Process submask
}
```

---

## Advanced Patterns

### Pattern 1: Gray Code

**Generate Gray code sequence (adjacent codes differ by 1 bit).**

```cpp
vector<int> grayCode(int n) {
    vector<int> result;
    int total = 1 << n;
    
    for (int i = 0; i < total; i++) {
        result.push_back(i ^ (i >> 1));
    }
    
    return result;
}
```

**How it works:**
```
n = 3

i = 0: 000 ^ 000 = 000
i = 1: 001 ^ 000 = 001
i = 2: 010 ^ 001 = 011
i = 3: 011 ^ 001 = 010
i = 4: 100 ^ 010 = 110
i = 5: 101 ^ 010 = 111
i = 6: 110 ^ 011 = 101
i = 7: 111 ^ 011 = 100

Sequence: 000, 001, 011, 010, 110, 111, 101, 100
Adjacent codes differ by exactly 1 bit!
```

### Pattern 2: Reverse Bits

```cpp
uint32_t reverseBits(uint32_t n) {
    uint32_t result = 0;
    for (int i = 0; i < 32; i++) {
        result <<= 1;           // Make room
        result |= (n & 1);      // Add rightmost bit
        n >>= 1;                // Remove rightmost bit
    }
    return result;
}
```

**Example:**
```
n = 5 = 00000000000000000000000000000101

Iteration 1:
  result = 0 << 1 = 0
  result |= (5 & 1) = 0 | 1 = 1
  n = 5 >> 1 = 2

Iteration 2:
  result = 1 << 1 = 2 = 10
  result |= (2 & 1) = 2 | 0 = 2
  n = 2 >> 1 = 1

Iteration 3:
  result = 2 << 1 = 4 = 100
  result |= (1 & 1) = 4 | 1 = 5 = 101
  n = 1 >> 1 = 0

... (29 more iterations of shifting left)

Final: 10100000000000000000000000000000
```

### Pattern 3: Hamming Distance

**Count positions where bits differ.**

```cpp
int hammingDistance(int x, int y) {
    return __builtin_popcount(x ^ y);
}
```

**Example:**
```
x = 1 = 0001
y = 4 = 0100

x ^ y = 0001 ^ 0100 = 0101

popcount(0101) = 2

Bits differ at positions 0 and 2
```

### Pattern 4: Maximum XOR of Two Numbers

**Find maximum XOR of any two numbers in array.**

```cpp
int findMaximumXOR(vector<int>& nums) {
    int maxXor = 0;
    int mask = 0;
    
    // Try each bit from left to right
    for (int i = 31; i >= 0; i--) {
        mask |= (1 << i);  // Include this bit in mask
        
        set<int> prefixes;
        for (int num : nums) {
            prefixes.insert(num & mask);  // Get prefix up to bit i
        }
        
        int candidate = maxXor | (1 << i);  // Try to set bit i
        
        // Check if candidate is achievable
        for (int prefix : prefixes) {
            if (prefixes.count(candidate ^ prefix)) {
                maxXor = candidate;
                break;
            }
        }
    }
    
    return maxXor;
}
```

**How it works:**
```
nums = [3, 10, 5, 25, 2, 8]

Binary:
3  = 00011
10 = 01010
5  = 00101
25 = 11001
2  = 00010
8  = 01000

Greedy: Try to set highest bit first

Bit 4 (16s place):
  Prefixes: {00000, 10000}
  Can we get 10000? 
    00000 ^ 10000 = 10000 (need 10000) ‚úì
  maxXor = 10000

Bit 3 (8s place):
  Try maxXor | (1<<3) = 11000
  Prefixes: {00000, 01000, 11000}
  Can we get 11000?
    00000 ^ 11000 = 11000 (need 11000) ‚úì
  maxXor = 11000

... continue for all bits ...

Maximum XOR: 25 ^ 2 = 11001 ^ 00010 = 11011 = 27
```

**Time:** O(32n) = O(n), **Space:** O(n)

---

## Common Problems

### Problem 1: Power Set

**Generate all subsets:**

```cpp
vector<vector<int>> subsets(vector<int>& nums) {
    int n = nums.size();
    vector<vector<int>> result;
    
    for (int mask = 0; mask < (1 << n); mask++) {
        vector<int> subset;
        for (int i = 0; i < n; i++) {
            if (mask & (1 << i)) {
                subset.push_back(nums[i]);
            }
        }
        result.push_back(subset);
    }
    
    return result;
}
```

### Problem 2: Counting Bits

**Count set bits for all numbers 0 to n:**

```cpp
vector<int> countBits(int n) {
    vector<int> result(n + 1);
    for (int i = 0; i <= n; i++) {
        result[i] = result[i >> 1] + (i & 1);
    }
    return result;
}
```

**How it works:**
```
i = 5 = 101

i >> 1 = 2 = 10
result[2] = 1 (one set bit in 10)

i & 1 = 1 (rightmost bit of 101)

result[5] = result[2] + 1 = 1 + 1 = 2 ‚úì

Pattern: result[i] = result[i/2] + (i%2)
```

### Problem 3: Binary Watch

**Show all possible times with k LEDs on:**

```cpp
vector<string> readBinaryWatch(int turnedOn) {
    vector<string> result;
    
    for (int h = 0; h < 12; h++) {
        for (int m = 0; m < 60; m++) {
            if (__builtin_popcount(h) + __builtin_popcount(m) == turnedOn) {
                result.push_back(to_string(h) + ":" + 
                                (m < 10 ? "0" : "") + to_string(m));
            }
        }
    }
    
    return result;
}
```

### Problem 4: Sum of Two Integers (Without +/-)

```cpp
int getSum(int a, int b) {
    while (b != 0) {
        int carry = (a & b) << 1;  // Calculate carry
        a = a ^ b;                  // Sum without carry
        b = carry;                  // Update carry
    }
    return a;
}
```

**How it works:**
```
a = 5 = 0101
b = 3 = 0011

Iteration 1:
  carry = (0101 & 0011) << 1 = 0001 << 1 = 0010
  a = 0101 ^ 0011 = 0110
  b = 0010

Iteration 2:
  carry = (0110 & 0010) << 1 = 0010 << 1 = 0100
  a = 0110 ^ 0010 = 0100
  b = 0100

Iteration 3:
  carry = (0100 & 0100) << 1 = 0100 << 1 = 1000
  a = 0100 ^ 0100 = 0000
  b = 1000

Iteration 4:
  carry = (0000 & 1000) << 1 = 0000
  a = 0000 ^ 1000 = 1000
  b = 0000

Result: 1000 = 8 = 5 + 3 ‚úì
```

---

## Summary Tables

### Bit Operations

| Operation | Code | Time | Use Case |
|-----------|------|------|----------|
| Set bit i | `n \| (1 << i)` | O(1) | Turn on flag |
| Clear bit i | `n & ~(1 << i)` | O(1) | Turn off flag |
| Toggle bit i | `n ^ (1 << i)` | O(1) | Flip flag |
| Check bit i | `n & (1 << i)` | O(1) | Test flag |
| Count bits | `__builtin_popcount(n)` | O(1) | Subset size |
| Rightmost 1 | `n & -n` | O(1) | Isolate bit |
| Clear rightmost 1 | `n & (n-1)` | O(1) | Remove bit |

### XOR Properties

| Property | Formula | Example |
|----------|---------|---------|
| Self-cancel | `a ^ a = 0` | `5 ^ 5 = 0` |
| Identity | `a ^ 0 = a` | `5 ^ 0 = 5` |
| Commutative | `a ^ b = b ^ a` | `5 ^ 3 = 3 ^ 5` |
| Associative | `(a^b)^c = a^(b^c)` | Order doesn't matter |
| Inverse | `a ^ b ^ b = a` | Cancel pairs |

### Complexity

| Problem | Naive | Optimized | Technique |
|---------|-------|-----------|-----------|
| Power of 2 | O(log n) | O(1) | `n & (n-1)` |
| Count bits | O(log n) | O(1) | `__builtin_popcount` |
| Single number | O(n¬≤) | O(n) | XOR trick |
| All subsets | O(2^n √ó n) | O(2^n √ó n) | Bit iteration |
| Subset of subset | O(4^n) | O(3^k) | `(s-1) & mask` |

---

## Practice Problems

### Basic Bit Operations
- [ ] Number of 1 Bits
- [ ] Power of Two
- [ ] Power of Four
- [ ] Reverse Bits
- [ ] Counting Bits

### XOR Tricks
- [ ] Single Number I, II, III
- [ ] Missing Number
- [ ] Find the Difference
- [ ] Sum of Two Integers
- [ ] Bitwise AND of Numbers Range

### Bit Manipulation
- [ ] Gray Code
- [ ] Hamming Distance
- [ ] Total Hamming Distance
- [ ] Maximum XOR of Two Numbers
- [ ] Binary Watch

### Bit DP
- [ ] Traveling Salesman Problem
- [ ] Shortest Path Visiting All Nodes
- [ ] Partition to K Equal Sum Subsets
- [ ] Find Shortest Superstring
- [ ] Maximize Score After N Operations

---

## Key Takeaways

1. **XOR cancels duplicates** - `a ^ a = 0`, perfect for finding unique elements
2. **`n & (n-1)` removes rightmost 1** - Key for power of 2 check, bit counting
3. **`n & -n` isolates rightmost 1** - Useful for tree structures (Fenwick tree)
4. **Bitmask for subsets** - Each bit represents element inclusion
5. **`(submask - 1) & mask`** iterates all submasks in O(3^n) total
6. **Bit DP for small n** - n ‚â§ 20, use mask as state
7. **Built-in functions are fast** - `__builtin_popcount`, `__builtin_ctz`
8. **Left shift = multiply by 2** - `x << n = x √ó 2^n`
9. **Right shift = divide by 2** - `x >> n = x / 2^n`
10. **Draw bits visually** - Helps understand operations!

Master these bit manipulation patterns and you'll solve complex problems with elegant, efficient solutions! üöÄ
