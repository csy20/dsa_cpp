# Graph I - Fundamentals, Traversal & Topological Sort

## Table of Contents
1. [Graph Fundamentals](#graph-fundamentals)
2. [Graph Representations](#graph-representations)
3. [Adjacency List vs Matrix](#adjacency-list-vs-matrix)
4. [Breadth-First Search (BFS)](#breadth-first-search-bfs)
5. [Depth-First Search (DFS)](#depth-first-search-dfs)
6. [Connected Components](#connected-components)
7. [Topological Sort](#topological-sort)
8. [Kahn's Algorithm (BFS)](#kahns-algorithm-bfs)
9. [DFS-based Topological Sort](#dfs-based-topological-sort)
10. [DAG Properties](#dag-properties)
11. [Common Problems](#common-problems)

---

## Graph Fundamentals

### What is a Graph?

**Graph G = (V, E):** Set of vertices (nodes) V and edges E connecting them.

**Visual:**
```
Undirected Graph:        Directed Graph (Digraph):
    1 --- 2                  1 ‚Üí 2
    |     |                  ‚Üì   ‚Üì
    3 --- 4                  3 ‚Üí 4
```

### Graph Types

**1. Undirected Graph:** Edges have no direction
```
    A --- B
    |     |
    C --- D

Edge (A,B) means A‚ÜîB (bidirectional)
```

**2. Directed Graph (Digraph):** Edges have direction
```
    A ‚Üí B
    ‚Üì   ‚Üì
    C ‚Üí D

Edge A‚ÜíB means can go from A to B (not B to A)
```

**3. Weighted Graph:** Edges have weights/costs
```
    A -5- B
    |     |
    2     3
    |     |
    C -1- D

Weight on edge (A,B) = 5
```

**4. Directed Acyclic Graph (DAG):** Directed graph with no cycles
```
    1 ‚Üí 2 ‚Üí 4
    ‚Üì       ‚Üë
    3 ------‚îò

No way to return to starting vertex
```

### Graph Terminology

| Term | Definition | Example |
|------|------------|---------|
| **Vertex/Node** | Point in graph | A, B, C |
| **Edge** | Connection between vertices | (A,B) |
| **Adjacent** | Connected by edge | A adjacent to B if edge exists |
| **Degree** | Number of edges at vertex | deg(A) = 2 if A has 2 edges |
| **In-degree** | Incoming edges (directed) | in-deg(B) = 1 if one edge to B |
| **Out-degree** | Outgoing edges (directed) | out-deg(A) = 2 if two edges from A |
| **Path** | Sequence of vertices via edges | A‚ÜíB‚ÜíC |
| **Cycle** | Path that returns to start | A‚ÜíB‚ÜíC‚ÜíA |
| **Connected** | Path exists between all pairs | All vertices reachable |
| **Component** | Maximal connected subgraph | {A,B,C} if disconnected from D |

**Example:**
```
Graph:
    1 --- 2
    |     |
    3     4 --- 5

Degree of 1: 2 (edges to 2, 3)
Degree of 2: 2 (edges to 1, 4)
Path from 1 to 5: 1‚Üí2‚Üí4‚Üí5
Components: 1 component (all connected)
```

---

## Graph Representations

### Adjacency List

**Store list of neighbors for each vertex.**

**Structure:**
```cpp
// Unweighted
vector<vector<int>> adj;  // adj[u] = list of neighbors of u

// Weighted
vector<vector<pair<int,int>>> adj;  // adj[u] = {(v, weight)}
```

**Example:**
```
Graph:
    0 --- 1
    |     |
    2 --- 3

Adjacency List:
  0: [1, 2]
  1: [0, 3]
  2: [0, 3]
  3: [1, 2]

Code:
vector<vector<int>> adj(4);
adj[0] = {1, 2};
adj[1] = {0, 3};
adj[2] = {0, 3};
adj[3] = {1, 2};
```

**Building from edges:**
```cpp
// Undirected graph
void buildGraph(vector<vector<int>>& edges, int n) {
    vector<vector<int>> adj(n);
    
    for (auto& edge : edges) {
        int u = edge[0];
        int v = edge[1];
        
        adj[u].push_back(v);
        adj[v].push_back(u);  // Both directions
    }
}

// Directed graph
void buildDirectedGraph(vector<vector<int>>& edges, int n) {
    vector<vector<int>> adj(n);
    
    for (auto& edge : edges) {
        int u = edge[0];
        int v = edge[1];
        
        adj[u].push_back(v);  // Only u‚Üív
    }
}

// Weighted graph
void buildWeightedGraph(vector<vector<int>>& edges, int n) {
    vector<vector<pair<int,int>>> adj(n);
    
    for (auto& edge : edges) {
        int u = edge[0];
        int v = edge[1];
        int w = edge[2];
        
        adj[u].push_back({v, w});
        adj[v].push_back({u, w});  // Undirected
    }
}
```

### Adjacency Matrix

**Store 2D array where matrix[i][j] = 1 if edge exists.**

**Structure:**
```cpp
// Unweighted
vector<vector<int>> matrix(n, vector<int>(n, 0));

// Weighted
vector<vector<int>> matrix(n, vector<int>(n, INF));
```

**Example:**
```
Graph:
    0 --- 1
    |     |
    2 --- 3

Adjacency Matrix:
    0  1  2  3
0 [ 0  1  1  0 ]
1 [ 1  0  0  1 ]
2 [ 1  0  0  1 ]
3 [ 0  1  1  0 ]

matrix[0][1] = 1 (edge 0-1 exists)
matrix[0][3] = 0 (no edge)
```

**Building from edges:**
```cpp
void buildMatrix(vector<vector<int>>& edges, int n) {
    vector<vector<int>> matrix(n, vector<int>(n, 0));
    
    for (auto& edge : edges) {
        int u = edge[0];
        int v = edge[1];
        
        matrix[u][v] = 1;
        matrix[v][u] = 1;  // Undirected
    }
}

// Weighted
void buildWeightedMatrix(vector<vector<int>>& edges, int n) {
    vector<vector<int>> matrix(n, vector<int>(n, INF));
    
    // Distance to self = 0
    for (int i = 0; i < n; i++) {
        matrix[i][i] = 0;
    }
    
    for (auto& edge : edges) {
        int u = edge[0];
        int v = edge[1];
        int w = edge[2];
        
        matrix[u][v] = w;
        matrix[v][u] = w;
    }
}
```

---

## Adjacency List vs Matrix

### Comparison Table

| Operation | Adj List | Adj Matrix | Winner |
|-----------|----------|------------|--------|
| **Space** | O(V + E) | O(V¬≤) | List (sparse graphs) |
| **Check edge (u,v)** | O(deg(u)) | O(1) | Matrix |
| **Find all neighbors** | O(deg(u)) | O(V) | List |
| **Add vertex** | O(1) | O(V¬≤) | List |
| **Add edge** | O(1) | O(1) | Tie |
| **Remove vertex** | O(E) | O(V¬≤) | List |
| **Remove edge** | O(deg(u)) | O(1) | Matrix |

### When to Use Each

**Use Adjacency List when:**
‚úÖ Graph is sparse (E << V¬≤)  
‚úÖ Need to iterate neighbors frequently  
‚úÖ Dynamic graph (adding/removing vertices)  
‚úÖ Memory constrained  
‚úÖ **Most competitive programming problems!**

**Use Adjacency Matrix when:**
‚úÖ Graph is dense (E ‚âà V¬≤)  
‚úÖ Need fast edge lookup  
‚úÖ Implementing graph algorithms (Floyd-Warshall)  
‚úÖ Small graphs (n ‚â§ 1000)

**Example comparison:**
```
Graph: n = 1000 vertices, e = 2000 edges (sparse)

Adjacency List:
  Space: 1000 + 2√ó2000 = 5000 integers ‚âà 20 KB

Adjacency Matrix:
  Space: 1000√ó1000 = 1,000,000 integers ‚âà 4 MB

List is 200√ó smaller! ‚úì
```

### Implementation Comparison

**Check if edge exists:**
```cpp
// Adjacency List: O(deg(u))
bool hasEdgeList(vector<vector<int>>& adj, int u, int v) {
    for (int neighbor : adj[u]) {
        if (neighbor == v) return true;
    }
    return false;
}

// Adjacency Matrix: O(1)
bool hasEdgeMatrix(vector<vector<int>>& matrix, int u, int v) {
    return matrix[u][v] == 1;
}
```

**Get all neighbors:**
```cpp
// Adjacency List: O(deg(u))
vector<int> getNeighborsList(vector<vector<int>>& adj, int u) {
    return adj[u];
}

// Adjacency Matrix: O(V)
vector<int> getNeighborsMatrix(vector<vector<int>>& matrix, int u) {
    vector<int> neighbors;
    for (int v = 0; v < matrix.size(); v++) {
        if (matrix[u][v] == 1) {
            neighbors.push_back(v);
        }
    }
    return neighbors;
}
```

---

## Breadth-First Search (BFS)

### BFS Algorithm

**Explore graph level by level (like tree level-order).**

**Key idea:** Use queue, visit all neighbors before going deeper.

```cpp
void bfs(vector<vector<int>>& adj, int start) {
    int n = adj.size();
    vector<bool> visited(n, false);
    queue<int> q;
    
    visited[start] = true;
    q.push(start);
    
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        
        cout << u << " ";  // Process vertex
        
        for (int v : adj[u]) {
            if (!visited[v]) {
                visited[v] = true;
                q.push(v);
            }
        }
    }
}
```

**How it works:**
```
Graph:
    0 --- 1 --- 2
    |           |
    3 --- 4 --- 5

BFS from 0:

Initial: visited[0]=true, queue=[0]

Step 1: Dequeue 0, process 0
  Neighbors: 1, 3
  Mark visited, enqueue
  Queue: [1, 3]
  Visited: [0, 1, 3]

Step 2: Dequeue 1, process 1
  Neighbors: 0 (visited), 2
  Enqueue 2
  Queue: [3, 2]
  Visited: [0, 1, 2, 3]

Step 3: Dequeue 3, process 3
  Neighbors: 0 (visited), 4
  Enqueue 4
  Queue: [2, 4]
  Visited: [0, 1, 2, 3, 4]

Step 4: Dequeue 2, process 2
  Neighbors: 1 (visited), 5
  Enqueue 5
  Queue: [4, 5]
  Visited: [0, 1, 2, 3, 4, 5]

Step 5: Dequeue 4, process 4
  Neighbors: 3 (visited), 5 (visited)
  Queue: [5]

Step 6: Dequeue 5, process 5
  Neighbors: 2 (visited), 4 (visited)
  Queue: []

Order: 0 1 3 2 4 5
```

**Visual levels:**
```
Level 0: [0]
Level 1: [1, 3]
Level 2: [2, 4]
Level 3: [5]
```

### BFS with Distance

```cpp
vector<int> bfsDistance(vector<vector<int>>& adj, int start) {
    int n = adj.size();
    vector<int> dist(n, -1);
    queue<int> q;
    
    dist[start] = 0;
    q.push(start);
    
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        
        for (int v : adj[u]) {
            if (dist[v] == -1) {  // Not visited
                dist[v] = dist[u] + 1;
                q.push(v);
            }
        }
    }
    
    return dist;  // dist[i] = shortest path from start to i
}
```

**Example:**
```
Graph:
    0 --- 1 --- 2
    |           |
    3 --- 4 --- 5

BFS distances from 0:
  dist[0] = 0
  dist[1] = 1 (0‚Üí1)
  dist[3] = 1 (0‚Üí3)
  dist[2] = 2 (0‚Üí1‚Üí2)
  dist[4] = 2 (0‚Üí3‚Üí4)
  dist[5] = 3 (0‚Üí1‚Üí2‚Üí5 or 0‚Üí3‚Üí4‚Üí5)
```

### BFS with Path Reconstruction

```cpp
vector<int> bfsPath(vector<vector<int>>& adj, int start, int end) {
    int n = adj.size();
    vector<int> parent(n, -1);
    vector<bool> visited(n, false);
    queue<int> q;
    
    visited[start] = true;
    q.push(start);
    
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        
        if (u == end) break;  // Found target
        
        for (int v : adj[u]) {
            if (!visited[v]) {
                visited[v] = true;
                parent[v] = u;
                q.push(v);
            }
        }
    }
    
    // Reconstruct path
    if (!visited[end]) return {};  // No path
    
    vector<int> path;
    for (int v = end; v != -1; v = parent[v]) {
        path.push_back(v);
    }
    reverse(path.begin(), path.end());
    
    return path;
}
```

**Time:** O(V + E)  
**Space:** O(V)

---

## Depth-First Search (DFS)

### DFS Algorithm

**Explore as deep as possible before backtracking.**

**Key idea:** Use stack (or recursion), go deep before exploring siblings.

**Recursive:**
```cpp
void dfsRecursive(vector<vector<int>>& adj, int u, vector<bool>& visited) {
    visited[u] = true;
    cout << u << " ";
    
    for (int v : adj[u]) {
        if (!visited[v]) {
            dfsRecursive(adj, v, visited);
        }
    }
}

void dfs(vector<vector<int>>& adj, int start) {
    vector<bool> visited(adj.size(), false);
    dfsRecursive(adj, start, visited);
}
```

**Iterative (with stack):**
```cpp
void dfsIterative(vector<vector<int>>& adj, int start) {
    int n = adj.size();
    vector<bool> visited(n, false);
    stack<int> st;
    
    st.push(start);
    
    while (!st.empty()) {
        int u = st.top();
        st.pop();
        
        if (visited[u]) continue;
        
        visited[u] = true;
        cout << u << " ";
        
        // Push neighbors in reverse order (for consistent ordering)
        for (int i = adj[u].size() - 1; i >= 0; i--) {
            int v = adj[u][i];
            if (!visited[v]) {
                st.push(v);
            }
        }
    }
}
```

**How it works:**
```
Graph:
    0 --- 1 --- 2
    |           |
    3 --- 4 --- 5

DFS from 0 (recursive):

Call dfs(0):
  Mark 0 visited, print 0
  Neighbors: [1, 3]
  
  Call dfs(1):
    Mark 1 visited, print 1
    Neighbors: [0(visited), 2]
    
    Call dfs(2):
      Mark 2 visited, print 2
      Neighbors: [1(visited), 5]
      
      Call dfs(5):
        Mark 5 visited, print 5
        Neighbors: [2(visited), 4]
        
        Call dfs(4):
          Mark 4 visited, print 4
          Neighbors: [3, 5(visited)]
          
          Call dfs(3):
            Mark 3 visited, print 3
            Neighbors: [0(visited), 4(visited)]
            Return
          Return
        Return
      Return
    Return
  Return

Order: 0 1 2 5 4 3
```

**Visual (recursion tree):**
```
        0
       / \
      1   3
      |   |
      2   4
      |
      5

Preorder-like traversal: 0 1 2 5 4 3
```

### DFS with Timestamps

**Discovery and finish times (useful for cycle detection, topological sort):**

```cpp
int timer = 0;

void dfsTimestamps(vector<vector<int>>& adj, int u, 
                   vector<bool>& visited,
                   vector<int>& discover,
                   vector<int>& finish) {
    visited[u] = true;
    discover[u] = timer++;
    
    for (int v : adj[u]) {
        if (!visited[v]) {
            dfsTimestamps(adj, v, visited, discover, finish);
        }
    }
    
    finish[u] = timer++;
}
```

**Example:**
```
Graph: 0 ‚Üí 1 ‚Üí 2

DFS from 0:
  discover[0] = 0
    discover[1] = 1
      discover[2] = 2
      finish[2] = 3
    finish[1] = 4
  finish[0] = 5

Interval notation:
  0: [0, 5]
  1: [1, 4]  (nested in 0)
  2: [2, 3]  (nested in 1)
```

**Time:** O(V + E)  
**Space:** O(V)

---

## Connected Components

### Find All Components (Undirected)

```cpp
void dfs(vector<vector<int>>& adj, int u, vector<bool>& visited) {
    visited[u] = true;
    
    for (int v : adj[u]) {
        if (!visited[v]) {
            dfs(adj, v, visited);
        }
    }
}

int countComponents(vector<vector<int>>& adj) {
    int n = adj.size();
    vector<bool> visited(n, false);
    int components = 0;
    
    for (int i = 0; i < n; i++) {
        if (!visited[i]) {
            dfs(adj, i, visited);
            components++;
        }
    }
    
    return components;
}
```

**How it works:**
```
Graph (3 components):
    0 --- 1       4 --- 5       7
    |                           |
    2 --- 3                     8

visited = [F, F, F, F, F, F, F, F, F]

i=0: Not visited
  DFS from 0: visits 0, 1, 2, 3
  components = 1
  visited = [T, T, T, T, F, F, F, F, F]

i=1,2,3: Already visited, skip

i=4: Not visited
  DFS from 4: visits 4, 5
  components = 2
  visited = [T, T, T, T, T, T, F, F, F]

i=5,6: Visited/doesn't exist, skip

i=7: Not visited
  DFS from 7: visits 7, 8
  components = 3
  visited = [T, T, T, T, T, T, F, T, T]

Answer: 3 components
```

### Components with IDs

```cpp
void dfs(vector<vector<int>>& adj, int u, 
         vector<int>& componentId, int id) {
    componentId[u] = id;
    
    for (int v : adj[u]) {
        if (componentId[v] == -1) {
            dfs(adj, v, componentId, id);
        }
    }
}

vector<int> findComponentIds(vector<vector<int>>& adj) {
    int n = adj.size();
    vector<int> componentId(n, -1);
    int id = 0;
    
    for (int i = 0; i < n; i++) {
        if (componentId[i] == -1) {
            dfs(adj, i, componentId, id);
            id++;
        }
    }
    
    return componentId;
}
```

**Result:**
```
Graph:
    0 --- 1       4 --- 5

componentId:
  [0, 0, 1, 1]
   ^  ^  ^  ^
   |  |  |  |
   0  1  4  5

Vertices 0,1 in component 0
Vertices 4,5 in component 1
```

### Strongly Connected Components (Directed)

**SCC:** Maximal set where every vertex reaches every other.

**Kosaraju's Algorithm:**
```cpp
void dfs1(vector<vector<int>>& adj, int u, 
          vector<bool>& visited, stack<int>& finishStack) {
    visited[u] = true;
    
    for (int v : adj[u]) {
        if (!visited[v]) {
            dfs1(adj, v, visited, finishStack);
        }
    }
    
    finishStack.push(u);  // Push after visiting all descendants
}

void dfs2(vector<vector<int>>& adjRev, int u, 
          vector<bool>& visited, vector<int>& component) {
    visited[u] = true;
    component.push_back(u);
    
    for (int v : adjRev[u]) {
        if (!visited[v]) {
            dfs2(adjRev, v, visited, component);
        }
    }
}

vector<vector<int>> findSCCs(vector<vector<int>>& adj) {
    int n = adj.size();
    
    // Step 1: DFS on original graph, record finish times
    vector<bool> visited(n, false);
    stack<int> finishStack;
    
    for (int i = 0; i < n; i++) {
        if (!visited[i]) {
            dfs1(adj, i, visited, finishStack);
        }
    }
    
    // Step 2: Create reversed graph
    vector<vector<int>> adjRev(n);
    for (int u = 0; u < n; u++) {
        for (int v : adj[u]) {
            adjRev[v].push_back(u);  // Reverse edge
        }
    }
    
    // Step 3: DFS on reversed graph in order of finish times
    fill(visited.begin(), visited.end(), false);
    vector<vector<int>> sccs;
    
    while (!finishStack.empty()) {
        int u = finishStack.top();
        finishStack.pop();
        
        if (!visited[u]) {
            vector<int> component;
            dfs2(adjRev, u, visited, component);
            sccs.push_back(component);
        }
    }
    
    return sccs;
}
```

**Time:** O(V + E)

---

## Topological Sort

### What is Topological Sort?

**Topological ordering:** Linear ordering of vertices where for every edge u‚Üív, u comes before v.

**Only exists for DAGs (Directed Acyclic Graphs)!**

**Example:**
```
DAG:
    1 ‚Üí 2 ‚Üí 4
    ‚Üì       ‚Üë
    3 ------‚îò

Valid topological orderings:
  1 ‚Üí 3 ‚Üí 2 ‚Üí 4
  1 ‚Üí 2 ‚Üí 3 ‚Üí 4

Invalid:
  2 ‚Üí 1 ‚Üí 3 ‚Üí 4  (edge 1‚Üí2 violated)
```

**Real-world uses:**
- Course prerequisites
- Task scheduling
- Build systems (compile dependencies)
- Package managers

---

## Kahn's Algorithm (BFS)

### Algorithm

**Idea:** Repeatedly remove vertices with in-degree 0 (no prerequisites).

```cpp
vector<int> topologicalSortKahn(vector<vector<int>>& adj, int n) {
    // Calculate in-degrees
    vector<int> inDegree(n, 0);
    for (int u = 0; u < n; u++) {
        for (int v : adj[u]) {
            inDegree[v]++;
        }
    }
    
    // Queue of vertices with in-degree 0
    queue<int> q;
    for (int i = 0; i < n; i++) {
        if (inDegree[i] == 0) {
            q.push(i);
        }
    }
    
    vector<int> result;
    
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        result.push_back(u);
        
        // Remove u from graph (decrease in-degrees)
        for (int v : adj[u]) {
            inDegree[v]--;
            if (inDegree[v] == 0) {
                q.push(v);
            }
        }
    }
    
    // Check if DAG (all vertices processed)
    if (result.size() != n) {
        return {};  // Cycle exists
    }
    
    return result;
}
```

**How it works:**
```
Graph:
    0 ‚Üí 1 ‚Üí 3
    ‚Üì   ‚Üì
    2 --‚Üí 4

Step 1: Calculate in-degrees
  inDegree: [0, 1, 1, 1, 2]
            0‚Üí[1,2], 1‚Üí[3,4], 2‚Üí[4]

Step 2: Find vertices with in-degree 0
  Queue: [0]

Step 3: Process 0
  Add 0 to result: [0]
  Decrease in-degrees of 1, 2
  inDegree: [0, 0, 0, 1, 2]
  Queue: [1, 2]

Step 4: Process 1
  Add 1 to result: [0, 1]
  Decrease in-degrees of 3, 4
  inDegree: [0, 0, 0, 0, 1]
  Queue: [2, 3]

Step 5: Process 2
  Add 2 to result: [0, 1, 2]
  Decrease in-degree of 4
  inDegree: [0, 0, 0, 0, 0]
  Queue: [3, 4]

Step 6: Process 3
  Add 3 to result: [0, 1, 2, 3]
  No outgoing edges
  Queue: [4]

Step 7: Process 4
  Add 4 to result: [0, 1, 2, 3, 4]
  Queue: []

Result: [0, 1, 2, 3, 4] ‚úì
```

**Cycle detection:**
```
Graph with cycle:
    0 ‚Üí 1
    ‚Üë   ‚Üì
    3 ‚Üê 2

In-degrees: [1, 1, 1, 1]
No vertex with in-degree 0!
Queue empty, result.size() < n
Return {} (cycle detected)
```

**Time:** O(V + E)  
**Space:** O(V)

---

## DFS-based Topological Sort

### Algorithm

**Idea:** DFS, add vertex to result AFTER visiting all descendants (reverse postorder).

```cpp
void dfs(vector<vector<int>>& adj, int u, 
         vector<bool>& visited, stack<int>& st) {
    visited[u] = true;
    
    for (int v : adj[u]) {
        if (!visited[v]) {
            dfs(adj, v, visited, st);
        }
    }
    
    st.push(u);  // Add AFTER visiting descendants
}

vector<int> topologicalSortDFS(vector<vector<int>>& adj, int n) {
    vector<bool> visited(n, false);
    stack<int> st;
    
    // DFS from all unvisited vertices
    for (int i = 0; i < n; i++) {
        if (!visited[i]) {
            dfs(adj, i, visited, st);
        }
    }
    
    // Extract from stack (reverse order)
    vector<int> result;
    while (!st.empty()) {
        result.push_back(st.top());
        st.pop();
    }
    
    return result;
}
```

**How it works:**
```
Graph:
    0 ‚Üí 1 ‚Üí 3
    ‚Üì   ‚Üì
    2 --‚Üí 4

DFS from 0:
  Visit 0
    Visit 1
      Visit 3
        No unvisited neighbors
        Push 3: stack = [3]
      Visit 4
        No unvisited neighbors
        Push 4: stack = [3, 4]
      Push 1: stack = [3, 4, 1]
    Visit 2
      4 already visited
      Push 2: stack = [3, 4, 1, 2]
    Push 0: stack = [3, 4, 1, 2, 0]

Pop from stack: [0, 2, 1, 4, 3]

Result: [0, 2, 1, 4, 3] ‚úì
```

**Why this works:**
```
DFS postorder visits vertex AFTER all descendants
Reverse postorder ensures dependencies visited first

If u ‚Üí v (u depends on v):
  DFS visits v before finishing u
  v pushed to stack before u
  When reversed, u comes before v ‚úì
```

### DFS with Cycle Detection

```cpp
enum State { UNVISITED, VISITING, VISITED };

bool hasCycleDFS(vector<vector<int>>& adj, int u, vector<State>& state) {
    state[u] = VISITING;
    
    for (int v : adj[u]) {
        if (state[v] == VISITING) {
            return true;  // Back edge = cycle
        }
        if (state[v] == UNVISITED) {
            if (hasCycleDFS(adj, v, state)) {
                return true;
            }
        }
    }
    
    state[u] = VISITED;
    return false;
}

bool hasCycle(vector<vector<int>>& adj, int n) {
    vector<State> state(n, UNVISITED);
    
    for (int i = 0; i < n; i++) {
        if (state[i] == UNVISITED) {
            if (hasCycleDFS(adj, i, state)) {
                return true;
            }
        }
    }
    
    return false;
}
```

**How cycle detection works:**
```
Three states:
  UNVISITED: Not yet explored
  VISITING: Currently in DFS stack
  VISITED: Fully processed

If we reach a VISITING node, we found a back edge ‚Üí cycle!

Example (cycle):
    0 ‚Üí 1
    ‚Üë   ‚Üì
    3 ‚Üê 2

DFS from 0:
  state[0] = VISITING
  DFS(1):
    state[1] = VISITING
    DFS(2):
      state[2] = VISITING
      DFS(3):
        state[3] = VISITING
        Check neighbor 0: state[0] = VISITING ‚úó
        Cycle detected!
```

**Time:** O(V + E)

---

## DAG Properties

### Properties of DAGs

**1. No cycles** (by definition)

**2. At least one vertex with in-degree 0** (source)
- Otherwise, cycle exists

**3. At least one vertex with out-degree 0** (sink)

**4. Has topological ordering**
- May have multiple valid orderings

**5. Can represent partial orders**
- Transitive: a‚Üíb, b‚Üíc implies a can reach c
- Antisymmetric: If a‚Üíb, then not b‚Üía

### Longest Path in DAG

**In general graphs: NP-hard**  
**In DAG: O(V + E) with topological sort!**

```cpp
int longestPath(vector<vector<pair<int,int>>>& adj, int n) {
    // Topological sort
    vector<int> topo = topologicalSortKahn(adj, n);
    
    // DP: dist[v] = longest path to v
    vector<int> dist(n, INT_MIN);
    dist[topo[0]] = 0;  // Start from source
    
    for (int u : topo) {
        if (dist[u] == INT_MIN) continue;
        
        for (auto [v, w] : adj[u]) {
            dist[v] = max(dist[v], dist[u] + w);
        }
    }
    
    return *max_element(dist.begin(), dist.end());
}
```

**Why topological order helps:**
```
Process vertices in topological order ensures:
  When processing v, all paths TO v already computed!

Example:
    0 -5‚Üí 1 -3‚Üí 3
    ‚Üì         ‚Üë
    2 ---7---‚Üí

Topo: [0, 2, 1, 3]

Process 0: dist[0] = 0
Process 2: dist[2] = 0 (if start), else from 0
Process 1: dist[1] = max(from 0) = 5
Process 3: dist[3] = max(from 1, from 2) = max(8, 7) = 8

Longest path: 0‚Üí1‚Üí3 = 8
```

### Count Paths in DAG

```cpp
int countPaths(vector<vector<int>>& adj, int n, int start, int end) {
    vector<int> topo = topologicalSortDFS(adj, n);
    
    vector<int> paths(n, 0);
    paths[start] = 1;
    
    for (int u : topo) {
        for (int v : adj[u]) {
            paths[v] += paths[u];
        }
    }
    
    return paths[end];
}
```

### All Topological Orderings (Backtracking)

```cpp
void allTopoSortUtil(vector<vector<int>>& adj, int n,
                     vector<int>& inDegree, vector<bool>& visited,
                     vector<int>& result, vector<vector<int>>& allSorts) {
    // Try all vertices with in-degree 0
    bool flag = false;
    
    for (int i = 0; i < n; i++) {
        if (inDegree[i] == 0 && !visited[i]) {
            // Choose i
            visited[i] = true;
            result.push_back(i);
            
            // Reduce in-degrees
            for (int v : adj[i]) {
                inDegree[v]--;
            }
            
            // Recurse
            allTopoSortUtil(adj, n, inDegree, visited, result, allSorts);
            
            // Backtrack
            for (int v : adj[i]) {
                inDegree[v]++;
            }
            result.pop_back();
            visited[i] = false;
            
            flag = true;
        }
    }
    
    // No more vertices with in-degree 0
    if (!flag) {
        allSorts.push_back(result);
    }
}
```

---

## Common Problems

### Problem 1: Course Schedule

**Can finish all courses given prerequisites?**

```cpp
bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
    // Build graph
    vector<vector<int>> adj(numCourses);
    vector<int> inDegree(numCourses, 0);
    
    for (auto& prereq : prerequisites) {
        int course = prereq[0];
        int pre = prereq[1];
        adj[pre].push_back(course);  // pre ‚Üí course
        inDegree[course]++;
    }
    
    // Kahn's algorithm
    queue<int> q;
    for (int i = 0; i < numCourses; i++) {
        if (inDegree[i] == 0) {
            q.push(i);
        }
    }
    
    int count = 0;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        count++;
        
        for (int v : adj[u]) {
            inDegree[v]--;
            if (inDegree[v] == 0) {
                q.push(v);
            }
        }
    }
    
    return count == numCourses;  // All courses processed?
}
```

### Problem 2: Course Schedule II

**Return valid course order (topological sort).**

```cpp
vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
    vector<vector<int>> adj(numCourses);
    vector<int> inDegree(numCourses, 0);
    
    for (auto& prereq : prerequisites) {
        adj[prereq[1]].push_back(prereq[0]);
        inDegree[prereq[0]]++;
    }
    
    queue<int> q;
    for (int i = 0; i < numCourses; i++) {
        if (inDegree[i] == 0) q.push(i);
    }
    
    vector<int> result;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        result.push_back(u);
        
        for (int v : adj[u]) {
            if (--inDegree[v] == 0) {
                q.push(v);
            }
        }
    }
    
    return result.size() == numCourses ? result : vector<int>{};
}
```

### Problem 3: Number of Islands

```cpp
void dfs(vector<vector<char>>& grid, int i, int j) {
    if (i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() ||
        grid[i][j] == '0') {
        return;
    }
    
    grid[i][j] = '0';  // Mark as visited
    
    dfs(grid, i + 1, j);
    dfs(grid, i - 1, j);
    dfs(grid, i, j + 1);
    dfs(grid, i, j - 1);
}

int numIslands(vector<vector<char>>& grid) {
    int count = 0;
    
    for (int i = 0; i < grid.size(); i++) {
        for (int j = 0; j < grid[0].size(); j++) {
            if (grid[i][j] == '1') {
                dfs(grid, i, j);
                count++;
            }
        }
    }
    
    return count;
}
```

### Problem 4: Clone Graph

```cpp
Node* cloneGraph(Node* node) {
    if (!node) return nullptr;
    
    unordered_map<Node*, Node*> clones;
    queue<Node*> q;
    
    clones[node] = new Node(node->val);
    q.push(node);
    
    while (!q.empty()) {
        Node* curr = q.front();
        q.pop();
        
        for (Node* neighbor : curr->neighbors) {
            if (clones.find(neighbor) == clones.end()) {
                clones[neighbor] = new Node(neighbor->val);
                q.push(neighbor);
            }
            clones[curr]->neighbors.push_back(clones[neighbor]);
        }
    }
    
    return clones[node];
}
```

---

## Summary Tables

### BFS vs DFS

| Aspect | BFS | DFS |
|--------|-----|-----|
| **Data structure** | Queue | Stack/Recursion |
| **Order** | Level by level | Deep first |
| **Shortest path** | ‚úì Yes (unweighted) | ‚ùå No |
| **Space** | O(width) | O(depth) |
| **Complete** | ‚úì Yes | ‚úì Yes |
| **Use case** | Shortest path, levels | Topological sort, cycles |

### Topological Sort Methods

| Method | Data Structure | Cycle Detection | Complexity |
|--------|----------------|-----------------|------------|
| Kahn (BFS) | Queue | Check if count < n | O(V + E) |
| DFS | Stack/Recursion | 3-color state | O(V + E) |

### Graph Representations

| Representation | Space | Check Edge | Get Neighbors | Best For |
|----------------|-------|------------|---------------|----------|
| Adj List | O(V+E) | O(deg) | O(deg) | Sparse graphs |
| Adj Matrix | O(V¬≤) | O(1) | O(V) | Dense graphs |

---

## Practice Problems

### Traversal
- [ ] Number of Islands
- [ ] Clone Graph
- [ ] Pacific Atlantic Water Flow
- [ ] Surrounded Regions
- [ ] Word Search

### Components
- [ ] Number of Connected Components
- [ ] Graph Valid Tree
- [ ] Accounts Merge
- [ ] Redundant Connection

### Topological Sort
- [ ] Course Schedule I & II
- [ ] Alien Dictionary
- [ ] Sequence Reconstruction
- [ ] Minimum Height Trees
- [ ] Sort Items by Groups Respecting Dependencies

### Cycle Detection
- [ ] Detect Cycle in Directed Graph
- [ ] Detect Cycle in Undirected Graph
- [ ] Find Eventual Safe States

---

## Key Takeaways

1. **Adjacency list for most problems** - Sparse graphs, O(V+E) space
2. **BFS for shortest path (unweighted)** - Level-by-level exploration
3. **DFS for topological sort and cycles** - Recursion or stack
4. **Connected components: DFS from all unvisited** - Count = # of DFS calls
5. **Kahn's algorithm for topological sort** - BFS with in-degrees
6. **DFS topological sort: reverse postorder** - Push after visiting children
7. **Cycle in directed: 3-color DFS** - VISITING state detects back edge
8. **DAG enables DP on graphs** - Topological order ensures dependencies
9. **In-degree 0 = no prerequisites** - Perfect for Kahn's algorithm
10. **Mark visited early in BFS** - Avoid duplicates in queue

Master these fundamentals and you'll handle any graph traversal or topological sort problem! üó∫Ô∏è

