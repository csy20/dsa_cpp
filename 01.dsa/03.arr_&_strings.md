# Arrays & Strings - Patterns and Techniques

## Table of Contents
1. [Array Patterns](#array-patterns)
   - [Frequency Tables](#frequency-tables)
   - [Two Scans](#two-scans)
   - [Partitioning](#partitioning)
2. [String Basics](#string-basics)
   - [Building Strings](#building-strings)
   - [Slicing](#slicing)
   - [Character Counts](#character-counts)
   - [Run-Length Encoding](#run-length-encoding)
3. [In-Place vs Extra Space](#in-place-vs-extra-space)
4. [Stability & Invariants](#stability--invariants)

---

## Array Patterns

### Frequency Tables

**Concept:** Count how many times each element appears.

**Why useful:** Solve problems about duplicates, missing elements, anagrams, etc.

#### Method 1: Array-based (for small range)

**When to use:** Elements in range [0, k] where k is small (e.g., k ≤ 10^6)

```cpp
// Count frequency of numbers in range [0, 100]
vector<int> arr = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3};
int freq[101] = {0};  // Initialize all to 0

// Build frequency table
for (int x : arr) {
    freq[x]++;
}

// Use frequency table
for (int i = 0; i <= 100; i++) {
    if (freq[i] > 0) {
        cout << i << " appears " << freq[i] << " times\n";
    }
}
```

**Time:** O(n + k), **Space:** O(k)

#### Method 2: Map-based (for any range)

**When to use:** Elements can be any value (negative, large, etc.)

```cpp
vector<int> arr = {1000000, -5, 1000000, 42, -5};
map<int, int> freq;

// Build frequency table
for (int x : arr) {
    freq[x]++;
}

// Iterate through unique elements (sorted)
for (auto [value, count] : freq) {
    cout << value << " appears " << count << " times\n";
}

// Check if element exists
if (freq.count(42)) {
    cout << "42 appears " << freq[42] << " times\n";
}
```

**Time:** O(n log n), **Space:** O(n)

#### Method 3: Unordered Map (faster)

```cpp
unordered_map<int, int> freq;

for (int x : arr) {
    freq[x]++;
}

// O(1) average lookup
cout << freq[42] << "\n";
```

**Time:** O(n) average, **Space:** O(n)

#### Common Applications

**1. Find element appearing once (all others appear twice)**

```cpp
// Using frequency table
int findSingle(vector<int>& arr) {
    unordered_map<int, int> freq;
    for (int x : arr) freq[x]++;
    
    for (auto [val, cnt] : freq) {
        if (cnt == 1) return val;
    }
    return -1;
}

// Better: Using XOR (O(1) space!)
int findSingleXOR(vector<int>& arr) {
    int result = 0;
    for (int x : arr) {
        result ^= x;  // XOR cancels duplicates
    }
    return result;
}
```

**2. Check if two strings are anagrams**

```cpp
bool isAnagram(string s, string t) {
    if (s.length() != t.length()) return false;
    
    int freq[26] = {0};
    
    // Count characters in first string
    for (char c : s) {
        freq[c - 'a']++;
    }
    
    // Subtract characters from second string
    for (char c : t) {
        freq[c - 'a']--;
    }
    
    // Check if all counts are zero
    for (int i = 0; i < 26; i++) {
        if (freq[i] != 0) return false;
    }
    
    return true;
}
```

**3. Find first non-repeating character**

```cpp
char firstUnique(string s) {
    int freq[256] = {0};
    
    // Count frequencies
    for (char c : s) {
        freq[c]++;
    }
    
    // Find first with count 1
    for (char c : s) {
        if (freq[c] == 1) return c;
    }
    
    return '\0';  // Not found
}
```

**4. Top K frequent elements**

```cpp
vector<int> topKFrequent(vector<int>& arr, int k) {
    // Build frequency map
    unordered_map<int, int> freq;
    for (int x : arr) freq[x]++;
    
    // Use priority queue (max heap by frequency)
    priority_queue<pair<int, int>> pq;
    for (auto [val, cnt] : freq) {
        pq.push({cnt, val});
    }
    
    // Extract top k
    vector<int> result;
    for (int i = 0; i < k; i++) {
        result.push_back(pq.top().second);
        pq.pop();
    }
    
    return result;
}
```

**Time:** O(n + m log m) where m = unique elements

---

### Two Scans

**Concept:** Make two passes through the array to solve problem.

**Why useful:** First pass gathers information, second pass uses it.

#### Pattern 1: Prefix + Suffix Scan

**Problem:** For each element, find product of all other elements (without division)

```cpp
vector<int> productExceptSelf(vector<int>& arr) {
    int n = arr.size();
    vector<int> result(n, 1);
    
    // First scan: left to right (prefix products)
    int prefix = 1;
    for (int i = 0; i < n; i++) {
        result[i] = prefix;
        prefix *= arr[i];
    }
    
    // Second scan: right to left (suffix products)
    int suffix = 1;
    for (int i = n - 1; i >= 0; i--) {
        result[i] *= suffix;
        suffix *= arr[i];
    }
    
    return result;
}
```

**Example:**
```
arr    = [2, 3, 4, 5]

After first scan (prefix):
result = [1, 2, 6, 24]
         [1, 2, 2*3, 2*3*4]

After second scan (suffix):
result = [60, 40, 30, 24]
         [3*4*5, 2*4*5, 2*3*5, 2*3*4]
```

**Time:** O(n), **Space:** O(1) (excluding output)

#### Pattern 2: Count Then Process

**Problem:** Remove duplicates from sorted array (in-place)

```cpp
int removeDuplicates(vector<int>& arr) {
    if (arr.empty()) return 0;
    
    int writeIdx = 1;  // Position to write next unique element
    
    // Scan through array
    for (int i = 1; i < arr.size(); i++) {
        if (arr[i] != arr[i-1]) {  // Found new unique element
            arr[writeIdx++] = arr[i];
        }
    }
    
    return writeIdx;  // New length
}
```

**Example:**
```
arr = [1, 1, 2, 2, 2, 3, 4, 4]

i=1: arr[1]=1, same as arr[0], skip
i=2: arr[2]=2, different! arr[1]=2, writeIdx=2
i=3: arr[3]=2, same as arr[2], skip
i=4: arr[4]=2, same as arr[3], skip
i=5: arr[5]=3, different! arr[2]=3, writeIdx=3
i=6: arr[6]=4, different! arr[3]=4, writeIdx=4
i=7: arr[7]=4, same as arr[6], skip

Result: [1, 2, 3, 4, ...], length=4
```

**Time:** O(n), **Space:** O(1)

#### Pattern 3: Max So Far / Min So Far

**Problem:** Best time to buy and sell stock (max profit)

```cpp
int maxProfit(vector<int>& prices) {
    int minPrice = INT_MAX;
    int maxProfit = 0;
    
    // Single scan
    for (int price : prices) {
        minPrice = min(minPrice, price);           // Track minimum so far
        maxProfit = max(maxProfit, price - minPrice);  // Max profit if sell today
    }
    
    return maxProfit;
}
```

**Example:**
```
prices = [7, 1, 5, 3, 6, 4]

price=7: minPrice=7, profit=0
price=1: minPrice=1, profit=0
price=5: minPrice=1, profit=4 (buy at 1, sell at 5)
price=3: minPrice=1, profit=4
price=6: minPrice=1, profit=5 (buy at 1, sell at 6)
price=4: minPrice=1, profit=5

Max profit = 5
```

**Time:** O(n), **Space:** O(1)

#### Pattern 4: Forward-Backward with Different Info

**Problem:** Trapping rain water

```cpp
int trap(vector<int>& height) {
    int n = height.size();
    if (n == 0) return 0;
    
    // First scan: max height to the left of each position
    vector<int> leftMax(n);
    leftMax[0] = height[0];
    for (int i = 1; i < n; i++) {
        leftMax[i] = max(leftMax[i-1], height[i]);
    }
    
    // Second scan: max height to the right, calculate water
    int rightMax = 0;
    int water = 0;
    for (int i = n - 1; i >= 0; i--) {
        rightMax = max(rightMax, height[i]);
        // Water at position i = min(leftMax, rightMax) - height[i]
        water += min(leftMax[i], rightMax) - height[i];
    }
    
    return water;
}
```

**Time:** O(n), **Space:** O(n)

---

### Partitioning

**Concept:** Rearrange array so elements satisfying a condition come before/after others.

**Key idea:** Use pointers to divide array into regions.

#### Pattern 1: Dutch National Flag (3-way partition)

**Problem:** Sort array of 0s, 1s, and 2s

```cpp
void sortColors(vector<int>& arr) {
    int low = 0;      // Boundary for 0s
    int mid = 0;      // Current element
    int high = arr.size() - 1;  // Boundary for 2s
    
    // Invariant:
    // [0, low) = 0s
    // [low, mid) = 1s
    // [mid, high] = unknown
    // (high, end) = 2s
    
    while (mid <= high) {
        if (arr[mid] == 0) {
            swap(arr[low], arr[mid]);
            low++;
            mid++;
        } else if (arr[mid] == 1) {
            mid++;
        } else {  // arr[mid] == 2
            swap(arr[mid], arr[high]);
            high--;
            // Don't increment mid (need to check swapped element)
        }
    }
}
```

**Example:**
```
arr = [2, 0, 2, 1, 1, 0]
       L M           H

mid=0: arr[0]=2, swap with high
[0, 0, 2, 1, 1, 2]
 L M        H

mid=0: arr[0]=0, swap with low, move both
[0, 0, 2, 1, 1, 2]
    L  M     H

mid=1: arr[1]=0, swap with low, move both
[0, 0, 2, 1, 1, 2]
       L  M  H

mid=2: arr[2]=2, swap with high
[0, 0, 1, 1, 2, 2]
       L  M H

mid=2: arr[2]=1, move mid
[0, 0, 1, 1, 2, 2]
       L    MH

mid=3: arr[3]=1, move mid
[0, 0, 1, 1, 2, 2]
       L     M
              H

mid > high, done!
```

**Time:** O(n), **Space:** O(1)

#### Pattern 2: QuickSort Partition

**Problem:** Partition around pivot

```cpp
int partition(vector<int>& arr, int low, int high) {
    int pivot = arr[high];  // Choose last element as pivot
    int i = low - 1;        // Index of smaller element
    
    // Invariant:
    // [low, i] = elements ≤ pivot
    // (i, j) = elements > pivot
    // [j, high-1] = not yet processed
    // high = pivot
    
    for (int j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    
    swap(arr[i + 1], arr[high]);  // Put pivot in correct position
    return i + 1;
}
```

**Example:**
```
arr = [3, 1, 4, 1, 5, 9, 2, 6], pivot = 6

Initial: i = -1
j=0: arr[0]=3 ≤ 6, i=0, swap(arr[0], arr[0]) → [3, 1, 4, 1, 5, 9, 2, 6]
j=1: arr[1]=1 ≤ 6, i=1, swap(arr[1], arr[1]) → [3, 1, 4, 1, 5, 9, 2, 6]
j=2: arr[2]=4 ≤ 6, i=2, swap(arr[2], arr[2]) → [3, 1, 4, 1, 5, 9, 2, 6]
j=3: arr[3]=1 ≤ 6, i=3, swap(arr[3], arr[3]) → [3, 1, 4, 1, 5, 9, 2, 6]
j=4: arr[4]=5 ≤ 6, i=4, swap(arr[4], arr[4]) → [3, 1, 4, 1, 5, 9, 2, 6]
j=5: arr[5]=9 > 6, skip
j=6: arr[6]=2 ≤ 6, i=5, swap(arr[5], arr[6]) → [3, 1, 4, 1, 5, 2, 9, 6]

Finally: swap(arr[6], arr[7]) → [3, 1, 4, 1, 5, 2, 6, 9]

All elements ≤ 6 are before index 6, all > 6 are after.
```

**Time:** O(n), **Space:** O(1)

#### Pattern 3: Move Zeros to End

```cpp
void moveZeros(vector<int>& arr) {
    int writeIdx = 0;  // Next position for non-zero
    
    // First pass: move all non-zeros to front
    for (int i = 0; i < arr.size(); i++) {
        if (arr[i] != 0) {
            arr[writeIdx++] = arr[i];
        }
    }
    
    // Second pass: fill rest with zeros
    while (writeIdx < arr.size()) {
        arr[writeIdx++] = 0;
    }
}

// One-pass version (maintains relative order)
void moveZerosOnePass(vector<int>& arr) {
    int writeIdx = 0;
    
    for (int i = 0; i < arr.size(); i++) {
        if (arr[i] != 0) {
            swap(arr[writeIdx++], arr[i]);
        }
    }
}
```

**Time:** O(n), **Space:** O(1)

#### Pattern 4: Segregate Even and Odd

```cpp
void segregateEvenOdd(vector<int>& arr) {
    int left = 0;
    int right = arr.size() - 1;
    
    while (left < right) {
        // Move left pointer to find odd number
        while (left < right && arr[left] % 2 == 0) {
            left++;
        }
        
        // Move right pointer to find even number
        while (left < right && arr[right] % 2 == 1) {
            right--;
        }
        
        // Swap odd (at left) with even (at right)
        if (left < right) {
            swap(arr[left], arr[right]);
            left++;
            right--;
        }
    }
}
```

**Time:** O(n), **Space:** O(1)

---

## String Basics

### Building Strings

#### Problem: Concatenation in Loop

**BAD (slow):**
```cpp
string s = "";
for (int i = 0; i < n; i++) {
    s += "a";  // Creates new string each time!
}
// Time: O(n²) because string copy happens each iteration
```

**GOOD (fast):**
```cpp
// Method 1: Reserve space
string s;
s.reserve(n);  // Pre-allocate
for (int i = 0; i < n; i++) {
    s += "a";
}
// Time: O(n)

// Method 2: Use vector then convert
vector<char> chars;
for (int i = 0; i < n; i++) {
    chars.push_back('a');
}
string s(chars.begin(), chars.end());
// Time: O(n)

// Method 3: String constructor
string s(n, 'a');  // n copies of 'a'
// Time: O(n)
```

#### Building from Multiple Parts

```cpp
// Concatenating many strings
vector<string> words = {"hello", "world", "from", "cpp"};

// Method 1: Direct concatenation (OK for small n)
string result = "";
for (const string& word : words) {
    result += word + " ";
}

// Method 2: Calculate total size first (better)
int totalLen = 0;
for (const string& word : words) {
    totalLen += word.length() + 1;  // +1 for space
}

string result;
result.reserve(totalLen);
for (const string& word : words) {
    result += word + " ";
}

// Method 3: Using stringstream (clean but slower)
#include <sstream>
stringstream ss;
for (const string& word : words) {
    ss << word << " ";
}
string result = ss.str();
```

#### Character Array to String

```cpp
char arr[] = {'h', 'e', 'l', 'l', 'o'};

// Method 1: Constructor
string s1(arr, arr + 5);

// Method 2: Range constructor
string s2(begin(arr), end(arr));

// From C-string
const char* cstr = "hello";
string s3(cstr);
string s4 = cstr;
```

---

### Slicing

**Note:** C++ doesn't have Python-style slicing, but we can achieve similar results.

```cpp
string s = "hello world";

// Get substring
string sub1 = s.substr(0, 5);      // "hello" (from index 0, length 5)
string sub2 = s.substr(6);         // "world" (from index 6 to end)
string sub3 = s.substr(6, 3);      // "wor" (from index 6, length 3)

// Get character
char c = s[0];          // 'h'
char c2 = s.at(0);      // 'h' (bounds checked)

// Range-based iteration
for (char c : s) {
    cout << c << " ";
}

// Iterator-based slicing
string slice(s.begin() + 6, s.begin() + 11);  // "world"

// Reverse a substring
reverse(s.begin() + 6, s.end());  // "hello dlrow"
```

#### Common String Operations

```cpp
string s = "hello";

// Length
int len = s.length();  // or s.size()

// Append
s += " world";
s.append(" !");
s.push_back('?');

// Insert
s.insert(5, " there");  // Insert at position 5

// Erase
s.erase(5, 6);  // Erase 6 characters starting from position 5

// Replace
s.replace(0, 5, "hi");  // Replace first 5 chars with "hi"

// Find
size_t pos = s.find("world");
if (pos != string::npos) {
    cout << "Found at " << pos << "\n";
}

// Find last occurrence
size_t last = s.rfind("o");

// Check prefix/suffix (C++20)
if (s.starts_with("hello")) { }
if (s.ends_with("world")) { }

// Pre-C++20 prefix/suffix check
if (s.substr(0, 5) == "hello") { }
if (s.length() >= 5 && s.substr(s.length() - 5) == "world") { }

// Compare
int cmp = s.compare("hello");  // 0 if equal, <0 if less, >0 if greater
```

---

### Character Counts

#### Frequency Array (for ASCII)

```cpp
string s = "hello world";
int freq[256] = {0};  // Support all ASCII characters

for (char c : s) {
    freq[c]++;
}

cout << "Character frequencies:\n";
for (int i = 0; i < 256; i++) {
    if (freq[i] > 0) {
        cout << (char)i << ": " << freq[i] << "\n";
    }
}
```

#### Frequency for Lowercase Letters Only

```cpp
string s = "hello";
int freq[26] = {0};

for (char c : s) {
    freq[c - 'a']++;
}

// Print frequencies
for (int i = 0; i < 26; i++) {
    if (freq[i] > 0) {
        cout << (char)('a' + i) << ": " << freq[i] << "\n";
    }
}
```

#### Applications

**1. Check if string contains all unique characters**

```cpp
bool hasAllUnique(string s) {
    bool seen[256] = {false};
    
    for (char c : s) {
        if (seen[c]) return false;
        seen[c] = true;
    }
    
    return true;
}

// Using set (easier but more memory)
bool hasAllUniqueSet(string s) {
    unordered_set<char> seen;
    for (char c : s) {
        if (seen.count(c)) return false;
        seen.insert(c);
    }
    return true;
}

// Using bitset (for lowercase letters only, O(1) space)
bool hasAllUniqueBitset(string s) {
    int checker = 0;
    for (char c : s) {
        int bit = c - 'a';
        if (checker & (1 << bit)) return false;
        checker |= (1 << bit);
    }
    return true;
}
```

**2. Check if one string is permutation of another**

```cpp
bool isPermutation(string s1, string s2) {
    if (s1.length() != s2.length()) return false;
    
    int freq[256] = {0};
    
    for (char c : s1) freq[c]++;
    for (char c : s2) freq[c]--;
    
    for (int i = 0; i < 256; i++) {
        if (freq[i] != 0) return false;
    }
    
    return true;
}

// Alternative: sort both strings
bool isPermutationSort(string s1, string s2) {
    if (s1.length() != s2.length()) return false;
    sort(s1.begin(), s1.end());
    sort(s2.begin(), s2.end());
    return s1 == s2;
}
```

**3. Find most frequent character**

```cpp
char mostFrequent(string s) {
    int freq[256] = {0};
    
    for (char c : s) {
        freq[c]++;
    }
    
    char maxChar = s[0];
    int maxCount = 0;
    
    for (int i = 0; i < 256; i++) {
        if (freq[i] > maxCount) {
            maxCount = freq[i];
            maxChar = (char)i;
        }
    }
    
    return maxChar;
}
```

---

### Run-Length Encoding

**Concept:** Compress string by counting consecutive repeated characters.

**Example:** "aaabbbccaa" → "a3b3c2a2"

#### Basic Implementation

```cpp
string runLengthEncode(string s) {
    if (s.empty()) return "";
    
    string encoded;
    
    int i = 0;
    while (i < s.length()) {
        char currentChar = s[i];
        int count = 0;
        
        // Count consecutive occurrences
        while (i < s.length() && s[i] == currentChar) {
            count++;
            i++;
        }
        
        // Append character and count
        encoded += currentChar;
        encoded += to_string(count);
    }
    
    return encoded;
}
```

**Example:**
```
Input:  "aaabbbccaa"
Output: "a3b3c2a2"

i=0: currentChar='a', count 'a's → count=3, i=3
     encoded = "a3"
i=3: currentChar='b', count 'b's → count=3, i=6
     encoded = "a3b3"
i=6: currentChar='c', count 'c's → count=2, i=8
     encoded = "a3b3c2"
i=8: currentChar='a', count 'a's → count=2, i=10
     encoded = "a3b3c2a2"
```

#### Decoding

```cpp
string runLengthDecode(string encoded) {
    string decoded;
    
    int i = 0;
    while (i < encoded.length()) {
        char ch = encoded[i++];
        
        // Parse number
        int count = 0;
        while (i < encoded.length() && isdigit(encoded[i])) {
            count = count * 10 + (encoded[i] - '0');
            i++;
        }
        
        // Append character 'count' times
        decoded.append(count, ch);
    }
    
    return decoded;
}
```

#### Smart Compression (only if beneficial)

```cpp
string smartCompress(string s) {
    if (s.empty()) return "";
    
    string compressed;
    int count = 1;
    
    for (int i = 1; i <= s.length(); i++) {
        if (i < s.length() && s[i] == s[i-1]) {
            count++;
        } else {
            compressed += s[i-1];
            if (count > 1) {  // Only add count if > 1
                compressed += to_string(count);
            }
            count = 1;
        }
    }
    
    // Return original if compression doesn't help
    return compressed.length() < s.length() ? compressed : s;
}
```

#### Applications

**1. String compression problem**
```cpp
// Compress: "aabcccccaaa" → "a2b1c5a3"
// But only if compressed is shorter, else return original
string compress(string s) {
    string compressed = runLengthEncode(s);
    return compressed.length() < s.length() ? compressed : s;
}
```

**2. Count and say sequence**
```cpp
// 1 → "1"
// 2 → "11" (one 1)
// 3 → "21" (two 1s)
// 4 → "1211" (one 2, one 1)
// 5 → "111221" (one 1, one 2, two 1s)

string countAndSay(int n) {
    if (n == 1) return "1";
    
    string current = "1";
    
    for (int i = 2; i <= n; i++) {
        string next;
        int count = 1;
        
        for (int j = 1; j <= current.length(); j++) {
            if (j < current.length() && current[j] == current[j-1]) {
                count++;
            } else {
                next += to_string(count);
                next += current[j-1];
                count = 1;
            }
        }
        
        current = next;
    }
    
    return current;
}
```

---

## In-Place vs Extra Space

### In-Place Algorithms

**Definition:** Modify input directly, use O(1) extra space.

**Advantages:**
- Memory efficient
- Often faster (no allocation overhead)

**Disadvantages:**
- Destroys original data
- Can be more complex to implement

#### Example 1: Reverse Array

```cpp
// In-place reversal
void reverseInPlace(vector<int>& arr) {
    int left = 0;
    int right = arr.size() - 1;
    
    while (left < right) {
        swap(arr[left], arr[right]);
        left++;
        right--;
    }
}
// Space: O(1)

// With extra space
vector<int> reverseWithSpace(const vector<int>& arr) {
    vector<int> result(arr.rbegin(), arr.rend());
    return result;
}
// Space: O(n)
```

#### Example 2: Remove Element

```cpp
// Remove all instances of val in-place
int removeElement(vector<int>& arr, int val) {
    int writeIdx = 0;
    
    for (int i = 0; i < arr.size(); i++) {
        if (arr[i] != val) {
            arr[writeIdx++] = arr[i];
        }
    }
    
    return writeIdx;  // New length
}
// Space: O(1)
```

#### Example 3: Rotate Array

```cpp
// Rotate right by k positions
void rotateInPlace(vector<int>& arr, int k) {
    int n = arr.size();
    k = k % n;  // Handle k > n
    
    // Reverse entire array
    reverse(arr.begin(), arr.end());
    
    // Reverse first k elements
    reverse(arr.begin(), arr.begin() + k);
    
    // Reverse remaining elements
    reverse(arr.begin() + k, arr.end());
}

// Example: [1,2,3,4,5], k=2
// Step 1: [5,4,3,2,1]
// Step 2: [4,5,3,2,1]
// Step 3: [4,5,1,2,3]
```

### When to Use Extra Space

Sometimes extra space makes algorithm simpler or more efficient.

#### Example 1: Two Sum (Hash Map)

```cpp
// With extra space: O(n) time
vector<int> twoSum(vector<int>& arr, int target) {
    unordered_map<int, int> seen;
    
    for (int i = 0; i < arr.size(); i++) {
        int complement = target - arr[i];
        if (seen.count(complement)) {
            return {seen[complement], i};
        }
        seen[arr[i]] = i;
    }
    
    return {};
}
// Time: O(n), Space: O(n)

// In-place (sorted array): O(n) time
vector<int> twoSumSorted(vector<int>& arr, int target) {
    int left = 0, right = arr.size() - 1;
    
    while (left < right) {
        int sum = arr[left] + arr[right];
        if (sum == target) return {left, right};
        else if (sum < target) left++;
        else right--;
    }
    
    return {};
}
// Time: O(n), Space: O(1) - but requires sorted array
```

#### Example 2: Merge Sorted Arrays

```cpp
// With extra space (easier)
vector<int> mergeWithSpace(vector<int>& arr1, vector<int>& arr2) {
    vector<int> result;
    int i = 0, j = 0;
    
    while (i < arr1.size() && j < arr2.size()) {
        if (arr1[i] <= arr2[j]) {
            result.push_back(arr1[i++]);
        } else {
            result.push_back(arr2[j++]);
        }
    }
    
    while (i < arr1.size()) result.push_back(arr1[i++]);
    while (j < arr2.size()) result.push_back(arr2[j++]);
    
    return result;
}
// Space: O(m + n)

// In-place (if arr1 has extra space)
void mergeInPlace(vector<int>& arr1, int m, vector<int>& arr2, int n) {
    int i = m - 1;      // Last element of arr1
    int j = n - 1;      // Last element of arr2
    int k = m + n - 1;  // Last position in arr1
    
    // Fill from back to front
    while (i >= 0 && j >= 0) {
        if (arr1[i] > arr2[j]) {
            arr1[k--] = arr1[i--];
        } else {
            arr1[k--] = arr2[j--];
        }
    }
    
    // Copy remaining elements from arr2
    while (j >= 0) {
        arr1[k--] = arr2[j--];
    }
}
// Space: O(1)
```

---

## Stability & Invariants

### Stability

**Definition:** A stable sort preserves the relative order of equal elements.

```cpp
// Original: [(3,a), (1,b), (3,c), (2,d)]
// Stable:   [(1,b), (2,d), (3,a), (3,c)]  ← (3,a) still before (3,c)
// Unstable: [(1,b), (2,d), (3,c), (3,a)]  ← order of 3s changed
```

#### Stable Sorts
- Merge Sort
- Insertion Sort
- Bubble Sort
- `std::stable_sort()`

#### Unstable Sorts
- Quick Sort (standard partition)
- Heap Sort
- `std::sort()` (usually)

```cpp
vector<pair<int, char>> arr = {{3,'a'}, {1,'b'}, {3,'c'}, {2,'d'}};

// Stable sort
stable_sort(arr.begin(), arr.end(), [](auto a, auto b) {
    return a.first < b.first;
});
// Result: [(1,b), (2,d), (3,a), (3,c)]

// Unstable sort (might change order of 3s)
sort(arr.begin(), arr.end(), [](auto a, auto b) {
    return a.first < b.first;
});
// Result: [(1,b), (2,d), (3,a), (3,c)] or [(1,b), (2,d), (3,c), (3,a)]
```

### Loop Invariants

**Definition:** A condition that remains true before and after each iteration.

**Why important:** Helps prove algorithm correctness.

#### Example 1: Binary Search

```cpp
int binarySearch(vector<int>& arr, int target) {
    int left = 0;
    int right = arr.size() - 1;
    
    // Invariant: if target exists, it's in [left, right]
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;  // Maintain invariant
        } else {
            right = mid - 1;  // Maintain invariant
        }
    }
    
    return -1;
}

// Invariant maintained:
// - Initially: target in [0, n-1] (entire array)
// - Each iteration: we eliminate half while keeping target in range
// - When left > right: range is empty, target not found
```

#### Example 2: Partition (QuickSort)

```cpp
int partition(vector<int>& arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    
    // Invariant:
    // [low, i] contains elements ≤ pivot
    // [i+1, j-1] contains elements > pivot
    // [j, high-1] not yet examined
    // arr[high] = pivot
    
    for (int j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            swap(arr[i], arr[j]);
            // Invariant maintained
        }
    }
    
    swap(arr[i + 1], arr[high]);
    return i + 1;
}
```

#### Example 3: Insertion Sort

```cpp
void insertionSort(vector<int>& arr) {
    // Invariant: arr[0...i-1] is sorted
    for (int i = 1; i < arr.size(); i++) {
        int key = arr[i];
        int j = i - 1;
        
        // Shift elements > key to the right
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        
        arr[j + 1] = key;
        // Invariant maintained: arr[0...i] is now sorted
    }
}
```

#### Example 4: Dutch National Flag

```cpp
void dutchFlag(vector<int>& arr) {
    int low = 0, mid = 0, high = arr.size() - 1;
    
    // Invariant:
    // [0, low) = 0s
    // [low, mid) = 1s
    // [mid, high] = unknown
    // (high, n) = 2s
    
    while (mid <= high) {
        if (arr[mid] == 0) {
            swap(arr[low++], arr[mid++]);
        } else if (arr[mid] == 1) {
            mid++;
        } else {
            swap(arr[mid], arr[high--]);
        }
        // Invariant maintained after each iteration
    }
}
```

### Using Invariants for Debugging

```cpp
void processArray(vector<int>& arr) {
    int sum = 0;
    
    for (int i = 0; i < arr.size(); i++) {
        // Invariant: sum = arr[0] + arr[1] + ... + arr[i-1]
        assert(sum == accumulate(arr.begin(), arr.begin() + i, 0));
        
        sum += arr[i];
        
        // Invariant: sum = arr[0] + arr[1] + ... + arr[i]
        assert(sum == accumulate(arr.begin(), arr.begin() + i + 1, 0));
    }
}
```

---

## Advanced Patterns

### Sliding Window

**Concept:** Maintain a window of elements and slide it across array.

```cpp
// Find maximum sum of k consecutive elements
int maxSumSubarray(vector<int>& arr, int k) {
    int n = arr.size();
    if (n < k) return -1;
    
    // Calculate sum of first window
    int windowSum = 0;
    for (int i = 0; i < k; i++) {
        windowSum += arr[i];
    }
    
    int maxSum = windowSum;
    
    // Slide window
    for (int i = k; i < n; i++) {
        windowSum += arr[i] - arr[i - k];  // Add new, remove old
        maxSum = max(maxSum, windowSum);
    }
    
    return maxSum;
}
```

### Two Pointers

**Concept:** Use two pointers moving in same/opposite directions.

```cpp
// Check if string is palindrome
bool isPalindrome(string s) {
    int left = 0;
    int right = s.length() - 1;
    
    while (left < right) {
        if (s[left] != s[right]) {
            return false;
        }
        left++;
        right--;
    }
    
    return true;
}

// Container with most water
int maxArea(vector<int>& height) {
    int left = 0, right = height.size() - 1;
    int maxWater = 0;
    
    while (left < right) {
        int width = right - left;
        int h = min(height[left], height[right]);
        maxWater = max(maxWater, width * h);
        
        // Move pointer with smaller height
        if (height[left] < height[right]) {
            left++;
        } else {
            right--;
        }
    }
    
    return maxWater;
}
```

### Fast & Slow Pointers

**Concept:** Two pointers moving at different speeds.

```cpp
// Detect cycle in array (using values as indices)
bool hasCycle(vector<int>& arr) {
    if (arr.empty()) return false;
    
    int slow = 0, fast = 0;
    
    do {
        slow = arr[slow];
        fast = arr[arr[fast]];
    } while (slow != fast);
    
    return slow == fast;
}

// Find middle of array (conceptually)
int findMiddle(vector<int>& arr) {
    int slow = 0, fast = 0;
    
    while (fast < arr.size() - 1 && fast + 1 < arr.size()) {
        slow++;
        fast += 2;
    }
    
    return slow;
}
```

---

## Practice Problems Summary

### Frequency Tables
1. Two Sum
2. First Non-Repeating Character
3. Check Anagram
4. Top K Frequent Elements
5. Subarrays with Given Sum

### Two Scans
1. Product of Array Except Self
2. Trapping Rain Water
3. Stock Buy/Sell
4. Gas Station

### Partitioning
1. Sort Colors (Dutch National Flag)
2. QuickSort
3. Kth Largest Element
4. Move Zeros

### Strings
1. String Compression
2. Palindrome Check
3. Longest Substring Without Repeating Characters
4. Valid Anagram
5. Group Anagrams

### In-Place
1. Rotate Array
2. Remove Duplicates
3. Reverse String
4. Merge Sorted Arrays

---

## Time Complexity Summary

| Pattern | Time | Space | Example |
|---------|------|-------|---------|
| Frequency Table (array) | O(n + k) | O(k) | Character count |
| Frequency Table (map) | O(n log n) | O(n) | Any element count |
| Two Scans | O(n) | O(1) or O(n) | Product except self |
| Partitioning | O(n) | O(1) | Dutch flag |
| String Build (reserve) | O(n) | O(n) | Concatenation |
| Run-Length Encode | O(n) | O(n) | Compression |
| In-Place Reverse | O(n) | O(1) | Array reversal |
| Sliding Window | O(n) | O(1) | Max sum subarray |
| Two Pointers | O(n) | O(1) | Palindrome check |

---

**Key Takeaways:**
1. Frequency tables solve many counting problems efficiently
2. Two scans can eliminate need for complex data structures
3. Partitioning enables O(1) space solutions
4. String building: always reserve space when possible
5. In-place algorithms trade simplicity for memory efficiency
6. Loop invariants help prove correctness and debug
7. Master these patterns - they appear in 80% of array/string problems!
