# Practice & Systems for Mastery

## Table of Contents
1. [Practice Strategy Overview](#practice-strategy-overview)
2. [Problem Sets by Topic](#problem-sets-by-topic)
3. [Mixed Rounds](#mixed-rounds)
4. [Timed Contests](#timed-contests)
5. [Patterns Checklist](#patterns-checklist)
6. [Test Generation](#test-generation)
7. [Debugging Diary](#debugging-diary)
8. [Contest Preparation](#contest-preparation)
9. [Mental Models](#mental-models)

---

## Practice Strategy Overview

### Three-Phase Learning System

**Phase 1: Topic Mastery (Problem Sets by Topic)**
- Deep dive into one topic
- Solve 15-30 problems of increasing difficulty
- Build muscle memory for patterns

**Phase 2: Pattern Recognition (Mixed Rounds)**
- Random topic selection
- Practice identifying problem types
- Build mental models

**Phase 3: Competition Simulation (Timed Contests)**
- Real contest conditions
- Time pressure management
- Speed + accuracy

### Why This System Works

**Deliberate Practice:**
```
Topic-focused ‚Üí Learn patterns deeply
Mixed practice ‚Üí Build recognition
Timed practice ‚Üí Build speed
```

**Learning Curve:**
```
Week 1-2: Topic sets (depth)
Week 3-4: Mixed rounds (breadth)
Week 5+: Timed contests (speed)

Repeat with harder topics
```

### Difficulty Progression

```
Rating Scale (Codeforces/LeetCode):

800-1000:  Implementation, basic logic
1000-1200: Standard patterns, single technique
1200-1400: Multiple techniques, pattern recognition
1400-1600: Advanced techniques, optimization
1600-1800: Hard problems, creative solutions
1800+:     Competition-level, multiple advanced techniques
```

---

## Problem Sets by Topic

### What Are Topic-Based Problem Sets?

**Focused practice on single algorithmic technique.**

**Example: Binary Search Problem Set**
1. First/Last Position (easy)
2. Search in Rotated Array (medium)
3. Median of Two Sorted Arrays (hard)
4. Kth Smallest Element (hard)
5. Split Array Largest Sum (hard)

### How to Build Topic Sets

**Structure:**
```
1. Foundation (3-5 problems)
   - Direct application of technique
   - Learn template/pattern
   
2. Variations (5-10 problems)
   - Slight modifications
   - Common problem variants
   
3. Advanced (5-10 problems)
   - Hidden technique
   - Multiple techniques
   - Optimization required

4. Challenge (3-5 problems)
   - Competition-level
   - Creative application
```

### Complete Topic Set Example: Two Pointers

**Foundation:**
```
‚ñ° Two Sum II (sorted array)
  Pattern: Left and right pointers converge
  
‚ñ° Remove Duplicates from Sorted Array
  Pattern: Write pointer follows read pointer
  
‚ñ° Container With Most Water
  Pattern: Greedy two pointers
```

**Variations:**
```
‚ñ° 3Sum
  Pattern: Fix one, two pointers for rest
  
‚ñ° Trapping Rain Water
  Pattern: Two pointers with max tracking
  
‚ñ° Valid Palindrome
  Pattern: Converging pointers
  
‚ñ° Longest Substring Without Repeating Characters
  Pattern: Sliding window (two pointers variant)
  
‚ñ° Minimum Window Substring
  Pattern: Expanding/contracting window
```

**Advanced:**
```
‚ñ° Substring with Concatenation of All Words
  Pattern: Window + frequency map
  
‚ñ° Longest Repeating Character Replacement
  Pattern: Window with max frequency tracking
  
‚ñ° Subarrays with K Different Integers
  Pattern: "At most K" trick
  
‚ñ° Minimum Operations to Reduce X to Zero
  Pattern: Window on complement
```

**Challenge:**
```
‚ñ° Count Subarrays With Fixed Bounds
  Pattern: Window with multiple constraints
  
‚ñ° Max Sum of Rectangle No Larger Than K
  Pattern: 2D ‚Üí 1D compression + two pointers
```

### My Curated Problem Sets

**Arrays & Strings (15 problems):**
```
Easy (5):
  ‚ñ° Two Sum
  ‚ñ° Best Time to Buy and Sell Stock
  ‚ñ° Majority Element
  ‚ñ° Contains Duplicate
  ‚ñ° Valid Anagram

Medium (7):
  ‚ñ° 3Sum
  ‚ñ° Product of Array Except Self
  ‚ñ° Longest Substring Without Repeating
  ‚ñ° Group Anagrams
  ‚ñ° Longest Palindromic Substring
  ‚ñ° Container With Most Water
  ‚ñ° Subarray Sum Equals K

Hard (3):
  ‚ñ° Trapping Rain Water
  ‚ñ° Minimum Window Substring
  ‚ñ° First Missing Positive
```

**Binary Search (12 problems):**
```
Easy (3):
  ‚ñ° Binary Search
  ‚ñ° First Bad Version
  ‚ñ° Search Insert Position

Medium (6):
  ‚ñ° Search in Rotated Sorted Array
  ‚ñ° Find Peak Element
  ‚ñ° Search a 2D Matrix
  ‚ñ° Koko Eating Bananas
  ‚ñ° Capacity To Ship Packages Within D Days
  ‚ñ° Minimum Number of Days to Make m Bouquets

Hard (3):
  ‚ñ° Median of Two Sorted Arrays
  ‚ñ° Split Array Largest Sum
  ‚ñ° Count of Smaller Numbers After Self
```

**Dynamic Programming (20 problems):**
```
1D DP (6):
  ‚ñ° Climbing Stairs
  ‚ñ° House Robber
  ‚ñ° Coin Change
  ‚ñ° Longest Increasing Subsequence
  ‚ñ° Word Break
  ‚ñ° Decode Ways

2D/Grid DP (6):
  ‚ñ° Unique Paths
  ‚ñ° Minimum Path Sum
  ‚ñ° Longest Common Subsequence
  ‚ñ° Edit Distance
  ‚ñ° Maximal Square
  ‚ñ° Dungeon Game

Knapsack Family (4):
  ‚ñ° 0/1 Knapsack (classic)
  ‚ñ° Partition Equal Subset Sum
  ‚ñ° Target Sum
  ‚ñ° Coin Change 2

Advanced (4):
  ‚ñ° Regular Expression Matching
  ‚ñ° Wildcard Matching
  ‚ñ° Interleaving String
  ‚ñ° Distinct Subsequences
```

**Trees (18 problems):**
```
Traversal (4):
  ‚ñ° Binary Tree Inorder Traversal
  ‚ñ° Binary Tree Level Order Traversal
  ‚ñ° Binary Tree Zigzag Level Order
  ‚ñ° Binary Tree Vertical Order

Properties (5):
  ‚ñ° Maximum Depth of Binary Tree
  ‚ñ° Balanced Binary Tree
  ‚ñ° Diameter of Binary Tree
  ‚ñ° Lowest Common Ancestor
  ‚ñ° Validate Binary Search Tree

Construction (4):
  ‚ñ° Construct Binary Tree from Preorder and Inorder
  ‚ñ° Construct Binary Tree from Inorder and Postorder
  ‚ñ° Serialize and Deserialize Binary Tree
  ‚ñ° Flatten Binary Tree to Linked List

Advanced (5):
  ‚ñ° Binary Tree Maximum Path Sum
  ‚ñ° Count Complete Tree Nodes
  ‚ñ° Kth Smallest Element in BST
  ‚ñ° All Nodes Distance K in Binary Tree
  ‚ñ° Recover Binary Search Tree
```

**Graphs (15 problems):**
```
BFS/DFS (5):
  ‚ñ° Number of Islands
  ‚ñ° Clone Graph
  ‚ñ° Course Schedule
  ‚ñ° Pacific Atlantic Water Flow
  ‚ñ° Word Ladder

Topological Sort (3):
  ‚ñ° Course Schedule II
  ‚ñ° Alien Dictionary
  ‚ñ° Minimum Height Trees

Shortest Path (4):
  ‚ñ° Network Delay Time (Dijkstra)
  ‚ñ° Cheapest Flights Within K Stops
  ‚ñ° Path With Minimum Effort
  ‚ñ° Swim in Rising Water

Advanced (3):
  ‚ñ° Critical Connections in Network (Bridges)
  ‚ñ° Redundant Connection (DSU)
  ‚ñ° Accounts Merge (DSU)
```

### How to Practice Topic Sets

**Daily Routine:**
```
Day 1-2: Foundation problems
  - Learn template
  - Understand core pattern
  - Code from scratch 2-3 times

Day 3-5: Variations
  - Recognize pattern in different contexts
  - Time yourself (15-30 min per problem)
  - Review solutions if stuck

Day 6-8: Advanced
  - Solve without hints
  - Optimize after getting accepted
  - Read editorial for alternative solutions

Day 9-10: Challenge
  - Full simulation mode
  - Time limit: 45-60 min per problem
  - Review even if solved
```

**Mastery Checklist:**
```
For each problem:
  ‚ñ° Solved without hints
  ‚ñ° Optimal time complexity
  ‚ñ° Optimal space complexity
  ‚ñ° Code is clean and bug-free
  ‚ñ° Can explain to someone else
  ‚ñ° Can solve variations
```

---

## Mixed Rounds

### What Are Mixed Rounds?

**Random selection of problems across all topics.**

**Purpose:**
- Test pattern recognition
- Build mental models
- Simulate real contests

### How to Structure Mixed Rounds

**Format:**
```
Duration: 2 hours
Problems: 4-6 problems
Difficulty: Same rating range (e.g., all 1400-1600)

Example Mixed Round:
  1. Array problem (1400)
  2. Tree problem (1450)
  3. DP problem (1500)
  4. Graph problem (1550)
  5. Greedy problem (1600)
```

**Selection Strategy:**
```
Random selection from each category:
  - Arrays/Strings: 1 problem
  - Trees/Graphs: 1 problem
  - DP/Greedy: 1 problem
  - Search/Sort: 1 problem
  - Math/Bit/Other: 1 problem
```

### My Mixed Round Templates

**Beginner Round (1000-1200):**
```
Problem 1: Two Sum variants
Problem 2: Simple tree traversal
Problem 3: Basic DP (climbing stairs, fibonacci)
Problem 4: Binary search application
Problem 5: Greedy with sorting

Time: 90 minutes
Goal: 4/5 problems solved
```

**Intermediate Round (1200-1400):**
```
Problem 1: Sliding window / two pointers
Problem 2: Tree properties (height, diameter)
Problem 3: 2D DP or knapsack
Problem 4: BFS/DFS application
Problem 5: Prefix sums or math

Time: 2 hours
Goal: 3-4/5 problems solved
```

**Advanced Round (1400-1600):**
```
Problem 1: Hash map + array technique
Problem 2: LCA or tree DP
Problem 3: String DP or advanced DP
Problem 4: Dijkstra or topological sort
Problem 5: Segment tree or advanced DS

Time: 2 hours
Goal: 2-3/5 problems solved
```

### Pattern Recognition Training

**First 5 Minutes:**
```
For each problem, identify:
  1. What is being asked?
     - Counting? Optimization? Yes/No?
  
  2. What are the constraints?
     - n ‚â§ 10: Try all possibilities (brute force)
     - n ‚â§ 20: O(2^n) possible (bitmask, meet-in-middle)
     - n ‚â§ 100: O(n¬≥) possible (Floyd-Warshall, DP)
     - n ‚â§ 1000: O(n¬≤) possible (DP, nested loops)
     - n ‚â§ 10‚Åµ: O(n log n) required (sorting, heap, segment tree)
     - n ‚â§ 10‚Å∂: O(n) or O(n log n) (linear scan, hash, sort)
  
  3. What patterns appear?
     - Sorted array ‚Üí binary search
     - Tree ‚Üí DFS/BFS/DP on tree
     - Shortest path ‚Üí BFS/Dijkstra
     - Subarray/substring ‚Üí sliding window
     - Distinct elements ‚Üí hash set
     - Kth element ‚Üí heap/quickselect
     - Range query ‚Üí prefix sum/segment tree
```

**Decision Tree:**
```
Optimization problem?
  ‚îú‚îÄ Yes ‚Üí DP or Greedy?
  ‚îÇ        ‚îú‚îÄ Overlapping subproblems ‚Üí DP
  ‚îÇ        ‚îî‚îÄ Greedy choice property ‚Üí Greedy
  ‚îÇ
  ‚îî‚îÄ No ‚Üí Search problem?
           ‚îú‚îÄ Yes ‚Üí BFS/DFS
           ‚îî‚îÄ No ‚Üí Data structure problem

Array/String?
  ‚îú‚îÄ Subarray/substring ‚Üí Sliding window
  ‚îú‚îÄ Two elements ‚Üí Two pointers or hash
  ‚îî‚îÄ Multiple queries ‚Üí Prefix sum or segment tree

Tree?
  ‚îú‚îÄ Path queries ‚Üí DFS/LCA
  ‚îú‚îÄ Subtree queries ‚Üí DFS/DP on tree
  ‚îî‚îÄ Level queries ‚Üí BFS

Graph?
  ‚îú‚îÄ Shortest path ‚Üí BFS/Dijkstra
  ‚îú‚îÄ Connectivity ‚Üí DFS/DSU
  ‚îî‚îÄ Ordering ‚Üí Topological sort
```

### Weekly Mixed Round Schedule

**Week 1: Pattern Recognition**
```
Mon: Beginner round (5 problems)
Wed: Review + editorial
Fri: Beginner round (5 problems)
Sun: Review + solve variations
```

**Week 2: Difficulty Increase**
```
Mon: Intermediate round (5 problems)
Wed: Review
Fri: Intermediate round (5 problems)
Sun: Re-solve week 1 problems faster
```

**Week 3: Advanced Practice**
```
Mon: Advanced round (4 problems)
Wed: Review
Fri: Mixed difficulty (3 easy, 2 hard)
Sun: Virtual contest (Codeforces Div 3)
```

**Week 4: Mastery**
```
Mon: Advanced round
Wed: Topic set (weak area)
Fri: Advanced round
Sun: Virtual contest (Codeforces Div 2)
```

---

## Timed Contests

### What Are Timed Contests?

**Full simulation of competition environment.**

**Purpose:**
- Build speed under pressure
- Practice time management
- Develop contest strategies

### Contest Types

**Codeforces Virtual Contests:**
```
Div 3: 6-7 problems, 2 hours
  - Recommended for beginners
  - Problems A-D: standard patterns
  - Problems E-F: advanced techniques

Div 2: 5-6 problems, 2 hours
  - Intermediate level
  - Problem A-B: warm-up
  - Problem C-D: main difficulty
  - Problem E-F: hard/very hard

Div 1: 5 problems, 2 hours
  - Advanced
  - All problems require deep thinking
```

**LeetCode Contests:**
```
Weekly Contest: 4 problems, 90 minutes
  - Problem 1: Easy (5 min)
  - Problem 2: Medium (15-20 min)
  - Problem 3: Medium-Hard (25-30 min)
  - Problem 4: Hard (40+ min)

Biweekly Contest: 4 problems, 90 minutes
  - Similar structure
```

**AtCoder Beginner Contest (ABC):**
```
8 problems, 100 minutes
  - A-D: Standard (first 40 min)
  - E-F: Advanced techniques (next 40 min)
  - G-H: Hard (remaining time)
```

### Contest Strategy

**Time Allocation:**
```
Read all problems first: 5-10 minutes
  - Identify easiest problems
  - Plan solving order

Solve in difficulty order:
  - Easy problems: 5-10 min each
  - Medium problems: 15-25 min each
  - Hard problems: 30-45 min each

Leave buffer: 10-15 minutes
  - Re-check solutions
  - Debug failed cases
```

**Solving Order:**
```
Optimal strategy:
  1. Solve all easy problems first
  2. Lock in guaranteed points
  3. Attempt medium problems
  4. Try hard only if time permits

Example (Codeforces Div 2):
  0-5 min: Read A, B, C
  5-15 min: Solve A
  15-30 min: Solve B
  30-35 min: Read D, E
  35-60 min: Solve C
  60-90 min: Attempt D
  90-120 min: Attempt E or debug
```

### My Contest Routine

**Before Contest (30 min):**
```
‚ñ° Set up environment
  - Editor, terminal, browser
  - Template file ready
  - Test script prepared

‚ñ° Warm up
  - Solve 1-2 easy problems
  - Review common patterns

‚ñ° Mental preparation
  - Deep breathing
  - Confidence boost
  - Positive mindset
```

**During Contest:**
```
‚ñ° Read all problem statements (5 min)
  - Note constraints
  - Identify difficulty
  - Plan order

‚ñ° Solve problems
  - Code quickly but carefully
  - Test with examples
  - Submit when confident

‚ñ° After submission
  - Move to next problem immediately
  - Don't dwell on mistakes
```

**After Contest (1 hour):**
```
‚ñ° Review submissions
  - Understand failed tests
  - Optimize accepted solutions

‚ñ° Read editorials
  - Learn new techniques
  - Compare with own solution

‚ñ° Solve unsolved problems
  - No time pressure
  - Deep understanding
```

### Speed Building Exercises

**Typing Speed:**
```
Practice template writing:
  - Time yourself: write full solution template
  - Goal: < 2 minutes for standard template

Common code snippets:
  - Binary search
  - DFS/BFS
  - DP table initialization
  - Segment tree
```

**Pattern Recognition Drills:**
```
100 problems in 10 days:
  - Just read and identify pattern
  - Don't code
  - Build mental index

Categories:
  - "Ah, this is sliding window"
  - "This needs binary search on answer"
  - "Classic DP on trees"
```

**Implementation Speed:**
```
Re-solve problems you've done:
  - Set timer: 50% of original time
  - Force faster implementation
  - Build muscle memory

Example:
  - First time: 30 minutes
  - Second time: 15 minutes
  - Third time: 10 minutes
```

---

## Patterns Checklist

### What Is a Patterns Checklist?

**Mental checklist to rapidly identify problem type.**

**Use before coding every problem!**

### My Master Patterns Checklist

**Array/String Patterns:**
```
‚ñ° Two pointers
  ‚Ü≥ Converging (two sum, palindrome)
  ‚Ü≥ Same direction (remove duplicates)
  ‚Ü≥ Sliding window (subarray sum)

‚ñ° Hash map/set
  ‚Ü≥ Frequency counting
  ‚Ü≥ Seen/not seen checking
  ‚Ü≥ Index mapping

‚ñ° Prefix sums
  ‚Ü≥ Range sum queries
  ‚Ü≥ Subarray sum equals k
  ‚Ü≥ 2D prefix sums

‚ñ° Sorting
  ‚Ü≥ Sort + two pointers
  ‚Ü≥ Sort + binary search
  ‚Ü≥ Custom comparator

‚ñ° Kadane's algorithm
  ‚Ü≥ Maximum subarray sum
  ‚Ü≥ Maximum product subarray
```

**Tree Patterns:**
```
‚ñ° DFS
  ‚Ü≥ Preorder (visit ‚Üí left ‚Üí right)
  ‚Ü≥ Inorder (left ‚Üí visit ‚Üí right)
  ‚Ü≥ Postorder (left ‚Üí right ‚Üí visit)

‚ñ° BFS
  ‚Ü≥ Level order traversal
  ‚Ü≥ Level-by-level processing

‚ñ° Tree properties
  ‚Ü≥ Height/depth
  ‚Ü≥ Diameter
  ‚Ü≥ Balanced check

‚ñ° LCA (Lowest Common Ancestor)
  ‚Ü≥ Binary lifting
  ‚Ü≥ Parent pointers

‚ñ° DP on trees
  ‚Ü≥ Subtree DP
  ‚Ü≥ Path DP
  ‚Ü≥ Rerooting

‚ñ° BST properties
  ‚Ü≥ Inorder = sorted
  ‚Ü≥ Search in O(log n)
  ‚Ü≥ Range queries
```

**Graph Patterns:**
```
‚ñ° BFS
  ‚Ü≥ Shortest path (unweighted)
  ‚Ü≥ Level-by-level exploration
  ‚Ü≥ 0-1 BFS

‚ñ° DFS
  ‚Ü≥ Connected components
  ‚Ü≥ Cycle detection
  ‚Ü≥ Topological sort

‚ñ° Dijkstra
  ‚Ü≥ Shortest path (weighted, non-negative)
  ‚Ü≥ Priority queue

‚ñ° Bellman-Ford
  ‚Ü≥ Negative weights
  ‚Ü≥ Negative cycle detection

‚ñ° Floyd-Warshall
  ‚Ü≥ All pairs shortest path
  ‚Ü≥ Transitive closure

‚ñ° Topological sort
  ‚Ü≥ Kahn's algorithm (BFS)
  ‚Ü≥ DFS-based

‚ñ° MST
  ‚Ü≥ Kruskal (edge-based)
  ‚Ü≥ Prim (vertex-based)

‚ñ° DSU
  ‚Ü≥ Connectivity queries
  ‚Ü≥ Kruskal's MST
  ‚Ü≥ Dynamic connectivity

‚ñ° Advanced
  ‚Ü≥ Bridges/Articulation points
  ‚Ü≥ Strongly Connected Components
  ‚Ü≥ Euler tour
```

**DP Patterns:**
```
‚ñ° 1D DP
  ‚Ü≥ dp[i] = answer for prefix [0..i]
  ‚Ü≥ Fibonacci variants
  ‚Ü≥ House robber

‚ñ° 2D DP
  ‚Ü≥ dp[i][j] = grid/two sequences
  ‚Ü≥ Unique paths
  ‚Ü≥ LCS, Edit distance

‚ñ° Knapsack
  ‚Ü≥ 0/1 knapsack (backward iteration)
  ‚Ü≥ Unbounded (forward iteration)
  ‚Ü≥ Subset sum

‚ñ° String DP
  ‚Ü≥ LCS
  ‚Ü≥ Edit distance
  ‚Ü≥ Palindrome partitioning

‚ñ° DP on trees
  ‚Ü≥ Subtree DP
  ‚Ü≥ Path DP

‚ñ° State compression
  ‚Ü≥ Bitmask DP
  ‚Ü≥ Digit DP

‚ñ° Optimization
  ‚Ü≥ Space: rolling array
  ‚Ü≥ Time: monotonic queue
```

**Binary Search Patterns:**
```
‚ñ° Standard binary search
  ‚Ü≥ Find exact value
  ‚Ü≥ First/last occurrence

‚ñ° Binary search on answer
  ‚Ü≥ Minimize/maximize something
  ‚Ü≥ Check if value is feasible

‚ñ° Search in rotated array
  ‚Ü≥ Find rotation point
  ‚Ü≥ Search in rotated

‚ñ° 2D binary search
  ‚Ü≥ Row-wise sorted
  ‚Ü≥ Row and column sorted
```

**Greedy Patterns:**
```
‚ñ° Sorting + greedy
  ‚Ü≥ Interval scheduling
  ‚Ü≥ Activity selection

‚ñ° Priority queue + greedy
  ‚Ü≥ Huffman coding
  ‚Ü≥ Merge K lists

‚ñ° Two pointers + greedy
  ‚Ü≥ Container with most water
  ‚Ü≥ Jump game
```

### How to Use the Checklist

**Step 1: Read problem**
```
Identify:
  - Input type (array, tree, graph, string)
  - Output type (count, min/max, yes/no, construct)
  - Constraints (n size, value ranges)
```

**Step 2: Run through checklist**
```
Array problem + subarray/substring?
  ‚Üí Check sliding window
  ‚Üí Check prefix sums

Tree problem + path-related?
  ‚Üí Check DFS
  ‚Üí Check LCA

Graph + shortest path?
  ‚Üí Check BFS/Dijkstra
  ‚Üí Check edge weights
```

**Step 3: Validate pattern**
```
Does this pattern fit?
  - Can I reduce to this pattern?
  - What's the complexity?
  - Any edge cases?

If yes ‚Üí code
If no ‚Üí try next pattern
```

### Pattern Recognition Practice

**Exercise: Identify pattern in 30 seconds**
```
Problem: "Find longest substring with at most K distinct characters"

Checklist:
  ‚ñ° String ‚Üí sliding window?
  ‚ñ° Subarray/substring ‚Üí YES
  ‚ñ° "At most K" ‚Üí window expansion/contraction
  
Pattern: Sliding window ‚úì
Time: O(n)
```

```
Problem: "Find LCA of two nodes in binary tree"

Checklist:
  ‚ñ° Tree ‚Üí DFS/BFS?
  ‚ñ° Ancestor relationship ‚Üí LCA pattern
  ‚ñ° Binary tree ‚Üí can use parent pointers or DFS
  
Pattern: DFS with parent tracking or Binary lifting ‚úì
Time: O(n) or O(log n) with preprocessing
```

---

## Test Generation

### Why Generate Tests?

**Edge cases break solutions!**

**Your solution might fail on:**
- Empty input
- Single element
- All same elements
- Maximum constraints
- Negative numbers
- Overflow cases

### How to Generate Tests

**Manual Test Cases:**
```cpp
// Template for test generation
void test_manual() {
    // Empty
    assert(solve({}) == expected);
    
    // Single element
    assert(solve({1}) == expected);
    
    // Two elements
    assert(solve({1, 2}) == expected);
    
    // All same
    assert(solve({5, 5, 5, 5}) == expected);
    
    // Negative
    assert(solve({-1, -2, -3}) == expected);
    
    // Maximum constraint
    vector<int> large(100000, 1);
    solve(large);  // Check for TLE/MLE
    
    // Overflow
    assert(solve({INT_MAX, INT_MAX}) == expected);
}
```

**Random Test Generation:**
```cpp
#include <random>

mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

int randInt(int l, int r) {
    return uniform_int_distribution<int>(l, r)(rng);
}

vector<int> generateArray(int n, int minVal, int maxVal) {
    vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        arr[i] = randInt(minVal, maxVal);
    }
    return arr;
}

// Stress testing
void stress_test() {
    for (int test = 0; test < 1000; test++) {
        int n = randInt(1, 100);
        auto arr = generateArray(n, -1000, 1000);
        
        auto result1 = bruteForce(arr);  // Slow correct solution
        auto result2 = optimized(arr);   // Fast solution to verify
        
        if (result1 != result2) {
            cout << "Failed on: ";
            for (int x : arr) cout << x << " ";
            cout << "\nExpected: " << result1 << "\nGot: " << result2 << endl;
            break;
        }
    }
    cout << "All tests passed!" << endl;
}
```

### Test Categories

**Category 1: Edge Cases**
```
‚ñ° Empty input
‚ñ° Single element
‚ñ° Two elements (minimum for comparisons)
‚ñ° All same elements
‚ñ° Already sorted (if relevant)
‚ñ° Reverse sorted (if relevant)
```

**Category 2: Boundary Cases**
```
‚ñ° Minimum constraint (n=1, val=0, etc.)
‚ñ° Maximum constraint (n=10^5, val=10^9, etc.)
‚ñ° Just below/above threshold
  Example: If n ‚â§ 1000, test n=999, n=1000, n=1001
```

**Category 3: Data Type Cases**
```
‚ñ° Negative numbers
‚ñ° Zero
‚ñ° Large numbers (near INT_MAX)
‚ñ° Overflow possibility
‚ñ° Precision issues (for doubles)
```

**Category 4: Logic Cases**
```
‚ñ° No valid answer exists
‚ñ° Multiple valid answers
‚ñ° Answer is at start/end/middle
‚ñ° Answer is minimum/maximum possible
```

### Stress Testing Framework

```cpp
class Tester {
    mt19937 rng;
    
    template<typename T>
    void assertEqual(T expected, T actual, string msg) {
        if (expected != actual) {
            cerr << "FAILED: " << msg << endl;
            cerr << "Expected: " << expected << endl;
            cerr << "Actual: " << actual << endl;
            exit(1);
        }
    }
    
public:
    Tester() : rng(chrono::steady_clock::now().time_since_epoch().count()) {}
    
    // Generate random array
    vector<int> randomArray(int n, int minVal, int maxVal) {
        vector<int> arr(n);
        for (int& x : arr) {
            x = uniform_int_distribution<int>(minVal, maxVal)(rng);
        }
        return arr;
    }
    
    // Compare two implementations
    template<typename Func1, typename Func2>
    void compareImplementations(Func1 brute, Func2 optimized, int tests = 1000) {
        for (int t = 0; t < tests; t++) {
            int n = uniform_int_distribution<int>(1, 100)(rng);
            auto arr = randomArray(n, -1000, 1000);
            
            auto result1 = brute(arr);
            auto result2 = optimized(arr);
            
            assertEqual(result1, result2, "Test " + to_string(t));
            
            if (t % 100 == 0) {
                cout << "Passed " << t << " tests..." << endl;
            }
        }
        cout << "All " << tests << " tests passed!" << endl;
    }
    
    // Time comparison
    template<typename Func>
    void timeIt(Func func, vector<int> arr, string name) {
        auto start = chrono::high_resolution_clock::now();
        func(arr);
        auto end = chrono::high_resolution_clock::now();
        auto duration = chrono::duration_cast<chrono::milliseconds>(end - start);
        cout << name << " took " << duration.count() << " ms" << endl;
    }
};

// Usage:
int main() {
    Tester tester;
    
    auto brute = [](vector<int> arr) { /* slow O(n¬≤) */ return 0; };
    auto fast = [](vector<int> arr) { /* fast O(n log n) */ return 0; };
    
    tester.compareImplementations(brute, fast, 1000);
    
    auto large = tester.randomArray(100000, -1e9, 1e9);
    tester.timeIt(fast, large, "Optimized");
    
    return 0;
}
```

### Test Case Examples

**Binary Search:**
```cpp
void test_binary_search() {
    // Empty
    assert(binarySearch({}, 5) == -1);
    
    // Single element
    assert(binarySearch({5}, 5) == 0);
    assert(binarySearch({5}, 3) == -1);
    
    // Not found
    assert(binarySearch({1,2,3}, 5) == -1);
    
    // First element
    assert(binarySearch({1,2,3}, 1) == 0);
    
    // Last element
    assert(binarySearch({1,2,3}, 3) == 2);
    
    // Duplicates
    assert(binarySearch({1,2,2,2,3}, 2) >= 1);
    assert(binarySearch({1,2,2,2,3}, 2) <= 3);
}
```

**Tree Problems:**
```cpp
void test_tree() {
    // Empty tree
    assert(maxDepth(nullptr) == 0);
    
    // Single node
    TreeNode* single = new TreeNode(1);
    assert(maxDepth(single) == 1);
    
    // Skewed tree
    TreeNode* skewed = new TreeNode(1);
    skewed->left = new TreeNode(2);
    skewed->left->left = new TreeNode(3);
    assert(maxDepth(skewed) == 3);
    
    // Balanced tree
    TreeNode* balanced = new TreeNode(1);
    balanced->left = new TreeNode(2);
    balanced->right = new TreeNode(3);
    assert(maxDepth(balanced) == 2);
}
```

---

## Debugging Diary

### What Is a Debugging Diary?

**Log of every bug encountered and how you fixed it.**

**Purpose:**
- Learn from mistakes
- Identify patterns in bugs
- Build debugging checklist

### How to Maintain Debugging Diary

**Format:**
```
Date: YYYY-MM-DD
Problem: [Problem name]
Bug type: [Category]
What happened: [Description]
Root cause: [Why it happened]
Fix: [How you fixed it]
Prevention: [How to avoid in future]
```

**Example Entry:**
```
Date: 2025-11-06
Problem: Binary Search in Rotated Array
Bug type: Off-by-one error

What happened:
  - Getting wrong answer on rotated arrays
  - Works on non-rotated arrays

Root cause:
  - Used mid+1 instead of mid when updating left pointer
  - Missed the case where target could be at mid

Fix:
  - Changed `left = mid + 1` to proper condition check
  - Added explicit check for arr[mid] == target

Prevention:
  - Always test binary search with:
    ‚úì Target at start
    ‚úì Target at end
    ‚úì Target at middle
    ‚úì Target not present
```

### Common Bug Categories

**1. Off-by-one errors:**
```
Symptoms:
  - Answer off by 1
  - Array out of bounds
  - Infinite loops

Common causes:
  - <= vs <
  - i+1 vs i
  - 0-indexed vs 1-indexed

Prevention:
  - Draw small example (n=3)
  - Check boundaries explicitly
```

**2. Integer overflow:**
```
Symptoms:
  - Wrong answer on large inputs
  - Negative result when should be positive

Common causes:
  - int + int overflows
  - Multiplying large numbers

Prevention:
  - Use long long for large values
  - Check if a*b > INT_MAX before computing
  - Use 1LL * a * b
```

**3. Uninitialized variables:**
```
Symptoms:
  - Random behavior
  - Different results on different runs

Common causes:
  - Forgot to initialize
  - Wrong initial value

Prevention:
  - Always initialize variables
  - Use constructor initializer lists
  - Fill arrays with memset or fill()
```

**4. Wrong data structure:**
```
Symptoms:
  - TLE on correct algorithm
  - Correct logic but slow

Common causes:
  - Using vector when should use set
  - Using set when should use unordered_set
  - Using map when array would work

Prevention:
  - Choose DS based on operations needed
  - Know complexity of each operation
```

**5. Edge cases:**
```
Symptoms:
  - Fails on specific inputs
  - Works on examples, fails on submission

Common causes:
  - Didn't consider empty input
  - Didn't consider single element
  - Didn't consider duplicates

Prevention:
  - Use edge case checklist
  - Generate edge case tests
```

### My Debugging Diary Template

```markdown
## Bug Log

### Entry #1: Array Index Error
**Date:** 2025-11-01
**Problem:** Two Sum
**Bug Type:** Off-by-one

**What Happened:**
Wrong answer on test case [3, 2, 4], target = 6

**Root Cause:**
Loop ran to i < n instead of i < n-1 for second pointer

**Fix:**
```cpp
// Before:
for (int i = 0; i < n; i++) {
    for (int j = i; j < n; j++) { // ‚Üê Bug: should be j = i+1
        
// After:
for (int i = 0; i < n; i++) {
    for (int j = i+1; j < n; j++) { // ‚Üê Fixed
```

**Prevention:**
- Always start second loop at i+1 when avoiding duplicates
- Draw small example to verify loop bounds

---

### Entry #2: Integer Overflow
**Date:** 2025-11-02
**Problem:** Product of Array Except Self
**Bug Type:** Overflow

**What Happened:**
Wrong answer on large inputs, worked on small inputs

**Root Cause:**
Product of large numbers exceeded INT_MAX

**Fix:**
```cpp
// Before:
int product = 1;
for (int x : nums) product *= x; // ‚Üê Overflow

// After:
long long product = 1;
for (int x : nums) product *= x; // ‚Üê Use long long
```

**Prevention:**
- Use long long when multiplying
- Check constraints: if numbers can be up to 10^9, product can be 10^18
- Add overflow check: `if (product > INT_MAX) break;`

---

### Entry #3: Uninitialized DP Array
**Date:** 2025-11-03
**Problem:** Coin Change
**Bug Type:** Initialization

**What Happened:**
Getting random large values as answer

**Root Cause:**
DP array not initialized to infinity

**Fix:**
```cpp
// Before:
vector<int> dp(amount + 1); // ‚Üê Default to 0

// After:
vector<int> dp(amount + 1, INT_MAX); // ‚Üê Initialize to INF
dp[0] = 0;
```

**Prevention:**
- Always initialize DP arrays explicitly
- Use fill() or constructor initialization
- Double-check initial state

---
```

### Debugging Checklist

**Before submitting:**
```
‚ñ° Tested on all sample inputs
‚ñ° Tested edge cases:
  ‚ñ° Empty input
  ‚ñ° Single element
  ‚ñ° Two elements
  ‚ñ° Maximum constraint
  
‚ñ° Checked for overflow:
  ‚ñ° Large multiplication
  ‚ñ° Large addition
  ‚ñ° Array indexing with large numbers
  
‚ñ° Verified algorithm:
  ‚ñ° Time complexity correct
  ‚ñ° Space complexity acceptable
  ‚ñ° Handles all cases
  
‚ñ° Code review:
  ‚ñ° No off-by-one errors
  ‚ñ° All variables initialized
  ‚ñ° No integer division where should be float
  ‚ñ° No missing edge case handling
```

**After wrong answer:**
```
‚ñ° Re-read problem statement
  - Misunderstood requirement?
  - Missed constraint?

‚ñ° Check failed test
  - What input caused failure?
  - What was expected output?
  - What did I output?

‚ñ° Add print statements
  - Print intermediate values
  - Verify algorithm steps

‚ñ° Generate similar test
  - Create small version of failed test
  - Step through manually

‚ñ° Review common bugs
  - Check debugging diary
  - Have I made this mistake before?
```

---

## Contest Preparation

### Pre-Contest Checklist

**1 Week Before:**
```
‚ñ° Solve topic sets in weak areas
‚ñ° Review common patterns
‚ñ° Practice virtual contests
‚ñ° Get adequate sleep
```

**1 Day Before:**
```
‚ñ° Light practice (don't burn out)
‚ñ° Review template code
‚ñ° Prepare environment
‚ñ° Relax and stay confident
```

**1 Hour Before:**
```
‚ñ° Warm up with 2-3 easy problems
‚ñ° Test environment
‚ñ° Have water/snacks ready
‚ñ° Clear mind, positive attitude
```

### Post-Contest Review

**Immediate (within 1 hour):**
```
‚ñ° Read editorials for problems you solved
  - Learn alternative solutions
  - Optimize your approach

‚ñ° Read editorials for problems you didn't solve
  - Understand the pattern
  - Add to practice list

‚ñ° Analyze mistakes
  - Why did you fail test?
  - What could you have done better?
```

**Next Day:**
```
‚ñ° Re-solve problems you failed
  - Without looking at editorial
  - Implement clean solution

‚ñ° Add to debugging diary
  - Log bugs encountered
  - Log patterns learned

‚ñ° Update patterns checklist
  - New pattern discovered?
  - Variation of known pattern?
```

### Progress Tracking

**Weekly Review:**
```
‚ñ° Problems solved this week: ___
‚ñ° New patterns learned: ___
‚ñ° Contest ranking: ___
‚ñ° Rating change: ___
‚ñ° Strong topics: ___
‚ñ° Weak topics: ___
```

**Monthly Goals:**
```
Month: ___
Target problems: 100
Target rating: 1400
Focus topics: DP, Graphs
Contests participated: 8

Achieved:
Problems: ___
Rating: ___
Contests: ___
```

---

## Mental Models

### Problem-Solving Framework

**Step 1: Understand (5 min)**
```
- Read problem carefully
- Identify input/output
- Note constraints
- Understand examples
```

**Step 2: Analyze (5-10 min)**
```
- What pattern does this fit?
- What's the brute force?
- Can I optimize?
- What's the bottleneck?
```

**Step 3: Design (5-10 min)**
```
- Choose algorithm
- Verify complexity
- Consider edge cases
- Plan data structures
```

**Step 4: Implement (10-30 min)**
```
- Code cleanly
- Test as you go
- Handle edge cases
```

**Step 5: Verify (5 min)**
```
- Test on examples
- Test on edge cases
- Check complexity
- Submit
```

### Growth Mindset

**Fixed mindset:**
```
‚ùå "I'm not good at DP"
‚ùå "This problem is too hard"
‚ùå "I'll never get this"
```

**Growth mindset:**
```
‚úì "I haven't mastered DP yet"
‚úì "This problem will teach me something new"
‚úì "Every problem is a learning opportunity"
```

### Learning from Mistakes

**Every wrong answer is valuable:**
```
Wrong Answer ‚Üí Learn edge case
Time Limit ‚Üí Learn optimization
Memory Limit ‚Üí Learn space efficiency
Runtime Error ‚Üí Learn careful coding
```

**Review cycle:**
```
Solve ‚Üí Fail ‚Üí Debug ‚Üí Learn ‚Üí Retry ‚Üí Master
```

---

## Key Takeaways

1. **Three-phase learning: Topic ‚Üí Mixed ‚Üí Timed** - Depth, breadth, speed
2. **Topic sets build muscle memory** - 15-30 problems per topic
3. **Mixed rounds build pattern recognition** - Random topic selection
4. **Timed contests build speed** - Full simulation with time pressure
5. **Patterns checklist speeds up recognition** - Mental index of all patterns
6. **Test generation catches edge cases** - Empty, single, max, overflow
7. **Stress testing compares brute vs optimized** - Random tests find bugs
8. **Debugging diary prevents repeated mistakes** - Log every bug
9. **Bug categories: off-by-one, overflow, initialization** - Know common pitfalls
10. **Contest strategy: read all ‚Üí solve easy ‚Üí attempt hard** - Time management
11. **Pre-contest warm up** - Solve 2-3 easy problems
12. **Post-contest review within 1 hour** - Read editorials while fresh
13. **Weekly review tracks progress** - Problems solved, rating change
14. **Growth mindset over fixed mindset** - "Haven't mastered yet" vs "not good at"
15. **Every problem is learning opportunity** - Mistakes are valuable

Build these systems and watch your competitive programming skills soar! üìà

