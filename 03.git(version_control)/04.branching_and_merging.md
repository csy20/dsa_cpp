# Branching & Merging

This is where Git's true power for safe development and collaboration shines. Branching allows you to work on features, experiments, and fixes without affecting the main codebase.

## 4.1. Why Use Branches?

Branches are one of Git's most powerful features, enabling parallel development and safe experimentation. Think of branches as alternate timelines for your project.

### The Problems Branches Solve

#### Without Branches (The Old Way)
```
Single Timeline Problems:
‚îú‚îÄ‚îÄ Working on Feature A
‚îú‚îÄ‚îÄ Bug discovered in production
‚îú‚îÄ‚îÄ Need to fix bug immediately
‚îú‚îÄ‚îÄ Feature A is half-finished and broken
‚îú‚îÄ‚îÄ Can't deploy the fix!
‚îî‚îÄ‚îÄ üò∞ Everything is blocked
```

#### With Branches (The Git Way)
```
Multiple Timeline Solution:
main:     A---B---C---F---G    (always deployable)
           \         /
feature:    D---E---/          (isolated development)
             \
hotfix:       H---I            (emergency fixes)
```

### Key Benefits of Branching

#### 1. **Keep Main Branch Clean and Deployable**
```bash
# Main branch stays stable
main branch:  ‚úÖ Always working
              ‚úÖ Always deployable  
              ‚úÖ Ready for releases
              ‚úÖ Safe for hotfixes

# Development happens elsewhere
feature branches: üöß Work in progress
                  üî¨ Experiments
                  üêõ Bug fixes
                  ‚ú® New features
```

#### 2. **Parallel Development**
```bash
# Multiple developers working simultaneously
Developer A: main ‚Üí feature/user-auth
Developer B: main ‚Üí feature/dashboard  
Developer C: main ‚Üí bugfix/login-error
Developer D: main ‚Üí hotfix/security-patch

# No conflicts, no stepping on each other's work!
```

#### 3. **Risk-Free Experimentation**
```bash
# Try new approaches without fear
git checkout -b experiment/new-architecture
# ... make radical changes ...
# If it works: merge back
# If it fails: delete branch, no harm done
```

#### 4. **Feature Isolation**
```bash
# Each feature develops independently
Feature A: 50% complete, not ready
Feature B: 90% complete, testing needed  
Feature C: 100% complete, ready to ship

# Ship Feature C without waiting for A or B
```

### Common Branch Types

#### **Main/Master Branch**
- üéØ **Purpose**: Production-ready code
- üìã **Rules**: Always stable, always deployable
- üîí **Protection**: Often protected from direct pushes

#### **Development Branch**
- üéØ **Purpose**: Integration of completed features
- üìã **Rules**: More stable than feature branches
- üîÑ **Flow**: Features merge here first, then to main

#### **Feature Branches**
- üéØ **Purpose**: Individual feature development
- üìã **Naming**: `feature/feature-name` or `feat/feature-name`
- üîÑ **Lifespan**: Created from main, merged back when complete

#### **Bugfix Branches**
- üéØ **Purpose**: Non-critical bug fixes
- üìã **Naming**: `bugfix/bug-description` or `fix/bug-description`
- üîÑ **Flow**: Similar to feature branches

#### **Hotfix Branches**
- üéØ **Purpose**: Critical production fixes
- üìã **Naming**: `hotfix/critical-fix`
- üîÑ **Flow**: Branch from main, merge to both main and develop

#### **Release Branches**
- üéØ **Purpose**: Preparing releases
- üìã **Naming**: `release/v1.2.0`
- üîÑ **Flow**: Final testing and minor fixes before release

## 4.2. Branching Operations

Let's learn the essential commands for working with branches effectively.

### Viewing Branches

```bash
# List all local branches
git branch

# Example output:
#   feature/user-auth
# * main                    # * indicates current branch
#   bugfix/login-error

# List all branches (local and remote)
git branch -a

# Example output:
#   feature/user-auth
# * main
#   remotes/origin/main
#   remotes/origin/develop
#   remotes/origin/feature/dashboard

# List remote branches only
git branch -r

# Show last commit for each branch
git branch -v

# Example output:
#   feature/user-auth  a1b2c3d Add password validation
# * main              e4f5g6h Update documentation  
#   bugfix/login      h7i8j9k Fix login redirect
```

### Creating Branches

#### Method 1: Create and Stay on Current Branch
```bash
# Create new branch from current location
git branch feature/user-profile

# Verify branch was created
git branch
# Output:
#   feature/user-profile
# * main                    # Still on main

# Create branch from specific commit
git branch bugfix/old-issue a1b2c3d

# Create branch from another branch
git branch feature/advanced-auth feature/user-auth
```

#### Method 2: Create and Switch Immediately
```bash
# Create and switch in one command (traditional)
git checkout -b feature/shopping-cart

# Create and switch in one command (modern)
git switch -c feature/shopping-cart

# Expected output:
# Switched to a new branch 'feature/shopping-cart'

# Verify you're on the new branch
git branch
# Output:
# * feature/shopping-cart   # * shows current branch
#   main
```

#### Method 3: Create from Remote Branch
```bash
# Create local branch tracking remote branch
git checkout -b feature/dashboard origin/feature/dashboard

# Simplified syntax (Git 2.23+)
git switch feature/dashboard  # Automatically tracks origin/feature/dashboard

# Create local branch with different name
git checkout -b local-dashboard origin/feature/dashboard
```

### Switching Between Branches

#### Using `git checkout` (Traditional)
```bash
# Switch to existing branch
git checkout main
git checkout feature/user-auth

# Switch with uncommitted changes (if safe)
git checkout feature/dashboard

# Force switch (discards uncommitted changes - DANGEROUS!)
git checkout --force feature/dashboard
```

#### Using `git switch` (Modern - Git 2.23+)
```bash
# Switch to existing branch
git switch main
git switch feature/user-auth

# Switch and create new branch
git switch -c feature/new-feature

# Switch with uncommitted changes
git switch feature/dashboard

# Restore previous branch
git switch -  # Like 'cd -' in bash
```

### Branch Naming Conventions

#### Standard Naming Patterns
```bash
# Feature branches
git checkout -b feature/user-authentication
git checkout -b feat/shopping-cart
git checkout -b feature/JIRA-123-payment-gateway

# Bug fixes
git checkout -b bugfix/fix-login-validation
git checkout -b fix/header-alignment
git checkout -b bugfix/ISSUE-456-memory-leak

# Hotfixes
git checkout -b hotfix/security-vulnerability
git checkout -b hotfix/v1.2.1-critical-patch

# Documentation
git checkout -b docs/api-documentation
git checkout -b docs/update-readme

# Refactoring
git checkout -b refactor/database-layer
git checkout -b refactor/simplify-auth-logic

# Experimental
git checkout -b experiment/new-ui-framework
git checkout -b spike/performance-optimization
```

#### Team Naming Conventions
```bash
# Include developer name
git checkout -b john/feature/user-profile
git checkout -b jane/bugfix/payment-error

# Include ticket numbers
git checkout -b feature/PROJ-123-user-dashboard
git checkout -b bugfix/BUG-456-login-issue

# Include dates for releases
git checkout -b release/2024-01-15
git checkout -b hotfix/2024-01-08-security
```

### Deleting Branches

#### Safe Deletion (Merged Only)
```bash
# Delete branch (only if merged)
git branch -d feature/completed-feature

# Example output if merged:
# Deleted branch feature/completed-feature (was a1b2c3d).

# Example output if not merged:
# error: The branch 'feature/incomplete' is not fully merged.
# If you are sure you want to delete it, run 'git branch -D feature/incomplete'.
```

#### Force Deletion (Unmerged)
```bash
# Force delete branch (even if not merged)
git branch -D feature/experimental-feature

# Delete remote branch
git push origin --delete feature/old-feature

# Delete remote tracking reference
git branch -dr origin/feature/old-feature
```

#### Cleaning Up Branches
```bash
# List branches that are merged into main
git branch --merged main

# Delete all merged branches (be careful!)
git branch --merged main | grep -v "main" | xargs git branch -d

# List branches not merged into main
git branch --no-merged main

# Prune remote tracking branches that no longer exist
git remote prune origin
```

## 4.3. Merging Branches

Merging combines the changes from one branch into another. Git offers different merge strategies depending on the branch history.

### Basic Merge Operation

```bash
# Basic merge workflow
# 1. Switch to target branch (usually main)
git checkout main

# 2. Pull latest changes (if working with remotes)
git pull origin main

# 3. Merge feature branch
git merge feature/user-authentication

# 4. Push merged changes
git push origin main
```

### Types of Merges

#### 1. Fast-Forward Merge

This happens when the target branch hasn't changed since the feature branch was created.

```bash
# Scenario: Linear history
main:     A---B---C
               \
feature:        D---E

# After fast-forward merge:
main:     A---B---C---D---E
```

**Example:**
```bash
# Start from main
git checkout main
# main is at commit C

# Create feature branch
git checkout -b feature/simple-fix
# Make commits D and E
git commit -m "Fix simple bug" # D
git commit -m "Add tests" # E

# Switch back to main (still at C)
git checkout main

# Fast-forward merge
git merge feature/simple-fix
# Output: Fast-forward
#         a1b2c3d..e4f5g6h  main -> main

# History is now linear: A-B-C-D-E
```

#### 2. Three-Way Merge (True Merge)

This happens when both branches have new commits.

```bash
# Scenario: Divergent history
main:     A---B---C---F---G
               \         /
feature:        D---E---/

# After three-way merge:
main:     A---B---C---F---G---M
               \             /
feature:        D---E-------/
# M is a merge commit
```

**Example:**
```bash
# Start from main at commit C
git checkout -b feature/new-feature
# Make commits D and E on feature branch

# Meanwhile, main got commits F and G
# When merging:
git checkout main
git merge feature/new-feature

# Output: Merge made by the 'recursive' strategy.
#         [additional files changed details]

# Creates merge commit M with two parents: G and E
```

#### 3. Squash Merge

Combines all feature branch commits into a single commit.

```bash
# Scenario: Multiple commits on feature branch
feature:  D---E---F---G (4 commits)

# After squash merge:
main:     A---B---C---S (S contains all changes from D,E,F,G)
```

**Example:**
```bash
# Squash merge (doesn't create merge commit)
git checkout main
git merge --squash feature/multiple-commits

# This stages all changes but doesn't commit
git status
# Output: All modifications staged

# Create single commit
git commit -m "Add complete user authentication feature

- Implement login system
- Add password validation  
- Create user registration
- Add authentication tests"

# Clean up feature branch
git branch -d feature/multiple-commits
```

### Merge Options and Flags

#### No Fast-Forward Merge
```bash
# Always create merge commit (even for fast-forward)
git merge --no-ff feature/important-feature

# Why use --no-ff?
# - Preserves feature branch history
# - Makes it clear when features were integrated
# - Easier to revert entire features
```

#### Fast-Forward Only
```bash
# Only merge if fast-forward is possible
git merge --ff-only feature/simple-change

# If fast-forward isn't possible:
# fatal: Not possible to fast-forward, aborting.
```

#### Custom Merge Messages
```bash
# Provide custom merge commit message
git merge -m "Integrate user authentication system" feature/user-auth

# Edit merge message in editor
git merge --edit feature/user-auth
```

### Merge vs. Rebase

#### Merge: Preserves History
```bash
# Merge preserves the branching structure
main:     A---B---C---M
               \     /
feature:        D---E

# Pro: Complete history, easy to see when features were added
# Con: Can create complex graph with many merge commits
```

#### Rebase: Linear History  
```bash
# Rebase creates linear history
git checkout feature/user-auth
git rebase main
git checkout main
git merge feature/user-auth  # Fast-forward

# Result:
main:     A---B---C---D'---E'

# Pro: Clean, linear history
# Con: Rewrites commit history, loses branching context
```

## 4.4. Handling Merge Conflicts

Merge conflicts occur when Git can't automatically combine changes from different branches. This happens when the same lines of code are modified in both branches.

### When Conflicts Occur

#### Common Conflict Scenarios
```bash
# Scenario 1: Same line modified differently
# Branch A changes line 5: "Hello World"  
# Branch B changes line 5: "Hello Git"
# Conflict: Git doesn't know which to keep

# Scenario 2: File deleted in one branch, modified in another
# Branch A: Deletes file.txt
# Branch B: Modifies file.txt
# Conflict: Delete or keep the modified file?

# Scenario 3: Same file renamed differently
# Branch A: Renames file.txt to document.txt
# Branch B: Renames file.txt to readme.txt  
# Conflict: Which name to use?
```

### Recognizing Merge Conflicts

```bash
# When a merge conflict occurs
git merge feature/conflicting-branch

# Output:
# Auto-merging src/main.py
# CONFLICT (content): Merge conflict in src/main.py
# Automatic merge failed; fix conflicts and then commit the result.

# Check status during conflict
git status

# Output:
# On branch main
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#   (use "git merge --abort" to abort the merge)
# 
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#         both modified:   src/main.py
```

### Understanding Conflict Markers

When Git encounters a conflict, it adds special markers to the file:

```python
# Example conflicted file: src/main.py
def greet_user(name):
<<<<<<< HEAD
    print(f"Hello {name}, welcome to our app!")
    return f"Welcome {name}"
=======
    print(f"Hi {name}, glad you're here!")
    return f"Greetings {name}"
>>>>>>> feature/new-greeting
```

**Conflict Marker Explanation:**
- `<<<<<<< HEAD`: Start of current branch changes (main)
- `=======`: Separator between conflicting versions
- `>>>>>>> feature/new-greeting`: End of merging branch changes
- Everything between markers shows the conflicting content

### Resolving Conflicts Manually

#### Step 1: Open Conflicted Files
```bash
# Find conflicted files
git status

# Open in your editor
code src/main.py  # VS Code
vim src/main.py   # Vim
nano src/main.py  # Nano
```

#### Step 2: Choose Resolution Strategy

**Strategy 1: Keep Current Branch (HEAD)**
```python
# Remove conflict markers and keep HEAD version
def greet_user(name):
    print(f"Hello {name}, welcome to our app!")
    return f"Welcome {name}"
```

**Strategy 2: Keep Incoming Branch**
```python  
# Remove conflict markers and keep incoming version
def greet_user(name):
    print(f"Hi {name}, glad you're here!")
    return f"Greetings {name}"
```

**Strategy 3: Combine Both Changes**
```python
# Merge both changes creatively
def greet_user(name):
    print(f"Hello {name}, welcome to our app!")
    print(f"We're glad you're here!")
    return f"Welcome {name}"
```

**Strategy 4: Write New Solution**
```python
# Create entirely new solution
def greet_user(name):
    greeting = f"Hello {name}! Welcome to our amazing app!"
    print(greeting)
    return greeting
```

#### Step 3: Mark as Resolved
```bash
# After editing the file, stage it
git add src/main.py

# Check that conflict is resolved
git status
# Output:
# On branch main
# All conflicts fixed but you are still merging.
#   (use "git commit" to conclude merge)
```

#### Step 4: Complete the Merge
```bash
# Commit the merge (opens editor for merge commit message)
git commit

# Or provide message directly
git commit -m "Merge feature/new-greeting

Resolved conflict in greet_user function by combining
both greeting approaches for better user experience."
```

### Using Visual Merge Tools

#### Configure Merge Tool
```bash
# Set up VS Code as merge tool
git config --global merge.tool vscode
git config --global mergetool.vscode.cmd 'code --wait $MERGED'

# Set up other popular tools
git config --global merge.tool kdiff3     # KDiff3
git config --global merge.tool meld       # Meld  
git config --global merge.tool vimdiff    # Vim diff
```

#### Launch Merge Tool
```bash
# Start visual merge tool for conflicts
git mergetool

# This opens your configured tool with three panels:
# - Left: Current branch (HEAD)
# - Center: Result (edit here)  
# - Right: Incoming branch

# After resolving in tool, stage the file
git add resolved-file.py
```

### Advanced Conflict Resolution

#### Aborting a Merge
```bash
# If conflicts are too complex, abort the merge
git merge --abort

# This returns you to the state before merge attempt
# Your working directory is restored
# No merge commit is created
```

#### Using Git's Automatic Resolution
```bash
# Automatically resolve conflicts favoring one side
git merge -X ours feature/branch      # Favor current branch
git merge -X theirs feature/branch    # Favor incoming branch

# Note: This only works for conflicts, not all changes
```

#### Cherry-pick Specific Changes
```bash
# Instead of merging entire branch, pick specific commits
git cherry-pick a1b2c3d  # Apply single commit
git cherry-pick a1b2c3d..e4f5g6h  # Apply range of commits
```

### Preventing Conflicts

#### 1. **Frequent Integration**
```bash
# Regularly update feature branches from main
git checkout feature/my-branch
git pull origin main
# or
git rebase origin/main
```

#### 2. **Small, Focused Branches**
```bash
# Create small branches that change fewer files
git checkout -b feature/fix-single-bug
# Better than large branches touching many files
```

#### 3. **Communication**
```bash
# Coordinate with team on file ownership
# Use code review to catch potential conflicts early
# Establish coding standards to reduce style conflicts
```

#### 4. **File Organization**
```bash
# Structure code to minimize overlapping changes
# Use dependency injection to reduce coupling
# Separate concerns into different files
```

### Complex Conflict Example

Let's walk through a realistic conflict resolution:

```bash
# Setup: Two developers working on same feature
# Developer A: Adds error handling
# Developer B: Adds logging

# File before changes (main branch):
def process_data(data):
    result = transform(data)
    return result

# Developer A's changes (feature/error-handling):
def process_data(data):
    try:
        result = transform(data)
        return result
    except Exception as e:
        print(f"Error processing data: {e}")
        return None

# Developer B's changes (feature/logging):
def process_data(data):
    print(f"Processing data: {data}")
    result = transform(data)
    print(f"Transform completed: {result}")
    return result

# Merge conflict when combining:
def process_data(data):
<<<<<<< HEAD
    try:
        result = transform(data)
        return result
    except Exception as e:
        print(f"Error processing data: {e}")
        return None
=======
    print(f"Processing data: {data}")
    result = transform(data)
    print(f"Transform completed: {result}")
    return result
>>>>>>> feature/logging

# Resolved version (combines both features):
def process_data(data):
    print(f"Processing data: {data}")
    try:
        result = transform(data)
        print(f"Transform completed: {result}")
        return result
    except Exception as e:
        print(f"Error processing data: {e}")
        return None
```

## Best Practices for Branching and Merging

### 1. **Branch Strategy**
```bash
# Use consistent naming conventions
feature/TICKET-123-user-auth
bugfix/fix-login-redirect  
hotfix/security-patch-v1.2.1

# Keep branches short-lived
# Merge or delete within 1-2 weeks
```

### 2. **Before Merging**
```bash
# Always test your branch
# Update from main branch first
git checkout feature/my-branch
git pull origin main

# Run tests
npm test  # or your test command

# Push and create pull request for review
```

### 3. **Merge Commit Messages**
```bash
# Use descriptive merge messages
git merge -m "Add user authentication system

Features added:
- Login/logout functionality  
- Password reset capability
- Session management
- Input validation

Resolves: #123, #124
Reviewed-by: @teammate" feature/user-auth
```

### 4. **Post-Merge Cleanup**
```bash
# Delete merged feature branches
git branch -d feature/completed-feature
git push origin --delete feature/completed-feature

# Update main branch
git checkout main
git pull origin main
```

---

## Branch Merge Visualization

### Before Merge:
```
main:     A---B---C
               \
feature:        D---E---F
```

### After Fast-Forward Merge:
```
main:     A---B---C---D---E---F
```

### After Three-Way Merge:
```
main:     A---B---C-------M
               \         /
feature:        D---E---F
```

### After Rebase:
```
Before:
main:     A---B---C
               \
feature:        D---E---F

After rebase (feature onto main):
main:     A---B---C
                   \
feature:            D'---E'---F'
(D', E', F' are new commits with same changes but different hashes)
```

---

## Merge vs Rebase - Detailed Comparison

| Aspect | Merge | Rebase |
|--------|-------|--------|
| **History** | Preserves complete history with merge commits | Creates linear, clean history |
| **Commits** | Creates new merge commit | Re-applies commits one by one |
| **Conflicts** | Resolve once during merge | May resolve multiple times |
| **When to Use** | Main/production branches | Feature branches before merging |
| **Team Work** | Safer for shared branches | Good for local work only |
| **Traceability** | Full history with all branches visible | Simplified timeline |
| **Command** | `git merge feature` | `git rebase main` |
| **Reversibility** | Easy to undo with `git revert` | Harder to undo (rewrites history) |
| **Safety** | Safe everywhere | ‚ö†Ô∏è **NEVER on public/shared branches** |
| **Visual Result** | Branch lines visible in history | Single line of commits |
| **Collaboration** | Shows who merged when | Hides merge details |

### Decision Tree: Merge or Rebase?

```
Is this a shared/public branch?
‚îÇ
‚îú‚îÄ YES (main, develop, release branches)
‚îÇ  ‚îî‚îÄ‚Üí Use MERGE ‚úÖ
‚îÇ     "git merge feature-branch"
‚îÇ
‚îî‚îÄ NO (your local feature branch)
   ‚îÇ
   ‚îú‚îÄ Want clean, linear history?
   ‚îÇ  ‚îî‚îÄ‚Üí Use REBASE ‚úÖ
   ‚îÇ     "git rebase main"
   ‚îÇ
   ‚îî‚îÄ Want to preserve exact history?
      ‚îî‚îÄ‚Üí Use MERGE ‚úÖ
         "git merge feature-branch"

### Golden Rule:
‚ùå NEVER rebase commits that exist outside your repository
‚úÖ ONLY rebase commits that are local to your machine
```

---

## ‚ö†Ô∏è Common Branching Mistakes

### ‚ùå Mistake #1: Working Directly on Main
**Problem**: Breaking production code, no isolation for features

**Solution**:
```bash
# BAD: Working on main
git checkout main
# ... make changes ...
git commit -m "new feature"  # ‚ùå main is now broken if feature isn't done

# GOOD: Create feature branch
git checkout main
git checkout -b feature/new-dashboard
# ... make changes ...
git commit -m "Add new dashboard"  # ‚úÖ main is still stable
```

### ‚ùå Mistake #2: Deleting Branch While Still On It
**Problem**: Git won't let you delete current branch

**Error**:
```bash
git checkout feature-branch
git branch -d feature-branch
# Error: Cannot delete branch 'feature-branch' checked out at...
```

**Solution**:
```bash
# Switch to another branch first
git checkout main
git branch -d feature-branch  # ‚úÖ Now it works
```

### ‚ùå Mistake #3: Force Pushing to Shared Branch
**Problem**: Overwrites teammates' work, causes conflicts

**BAD**:
```bash
git push --force origin main  # ‚ùå DANGER! Never do this on shared branches
```

**GOOD**:
```bash
# Only force push to YOUR feature branches if absolutely necessary
git push --force-with-lease origin my-feature-branch  # ‚úÖ Safer alternative
```

### ‚ùå Mistake #4: Creating Branch from Outdated Main
**Problem**: Your feature branch is missing recent changes

**Solution**:
```bash
# BAD: Create branch from old main
git checkout -b feature/new-thing  # main is 10 commits behind

# GOOD: Update main first
git checkout main
git pull origin main              # Get latest changes
git checkout -b feature/new-thing  # Now you're up to date
```

### ‚ùå Mistake #5: Ignoring Merge Conflicts
**Problem**: Incomplete merges break the code

**Error Example**:
```
<<<<<<< HEAD
function oldVersion() {
=======
function newVersion() {
>>>>>>> feature-branch
```

**Solution**:
```bash
# 1. DON'T commit conflict markers!
# 2. Manually resolve conflicts:
#    - Keep one version, or
#    - Combine both versions, or
#    - Write new code

# 3. After resolving, stage and commit
git add resolved-file.py
git commit -m "Resolve merge conflict between old and new versions"
```

---

## üîß Troubleshooting Branching Issues

### Problem 1: "Cannot delete branch (not fully merged)"

**Error Message:**
```
error: The branch 'feature-branch' is not fully merged.
If you are sure you want to delete it, run 'git branch -D feature-branch'.
```

**What This Means:**  
Branch has commits that aren't in the current branch.

**How to Fix:**
```bash
# Option 1: Merge the branch first
git checkout main
git merge feature-branch
git branch -d feature-branch  # Now it works

# Option 2: Force delete if you're sure
git branch -D feature-branch  # ‚ö†Ô∏è Permanently loses commits!

# Option 3: Check what would be lost
git log main..feature-branch  # Shows commits only in feature-branch
```

---

### Problem 2: "Detached HEAD state"

**Error Message:**
```
You are in 'detached HEAD' state...
```

**What This Means:**  
You checked out a specific commit instead of a branch.

**How to Fix:**
```bash
# If you made changes you want to keep:
git checkout -b new-branch-name  # Create branch from current position

# If you just want to go back to a branch:
git checkout main
```

---

### Problem 3: Merge Conflict

**Error Message:**
```
CONFLICT (content): Merge conflict in file.txt
Automatic merge failed; fix conflicts and then commit the result.
```

**What This Means:**  
Both branches changed the same lines differently.

**How to Fix:**
```bash
# 1. See which files have conflicts
git status

# 2. Open conflicted files, look for markers:
# <<<<<<< HEAD
# your changes
# =======
# their changes
# >>>>>>> branch-name

# 3. Edit file to resolve conflict (remove markers, keep desired code)

# 4. Stage resolved files
git add resolved-file.txt

# 5. Complete the merge
git commit -m "Resolve merge conflict in file.txt"
```

**Tools to Help:**
```bash
# Use visual merge tool
git mergetool

# Abort merge if needed
git merge --abort
```

---

### Problem 4: "Your branch has diverged from 'origin/main'"

**Error Message:**
```
Your branch and 'origin/main' have diverged,
and have 2 and 3 different commits each, respectively.
```

**What This Means:**  
Your local branch and remote branch have different commits.

**How to Fix:**
```bash
# Option 1: Merge remote changes
git pull origin main

# Option 2: Rebase your commits on top of remote
git pull --rebase origin main

# Option 3: See what's different
git log --oneline main..origin/main  # Remote commits you don't have
git log --oneline origin/main..main  # Your commits not on remote
```

---

### Problem 5: Lost Commits After Branch Delete

**Scenario**: Accidentally deleted branch with important commits.

**How to Fix:**
```bash
# 1. Find lost commits with reflog
git reflog

# 2. Look for commit hash before deletion
# Example output:
# abc1234 HEAD@{0}: checkout: moving from feature to main
# def5678 HEAD@{1}: commit: Important changes  ‚Üê This one!

# 3. Recover by creating branch from commit
git checkout -b recovered-branch def5678

# 4. Or cherry-pick specific commits
git cherry-pick def5678
```

---

## üìù Knowledge Check

### Quick Quiz

1. **What's the difference between `git merge` and `git rebase`?**
2. **Can you delete a branch you're currently on?**
3. **What does "fast-forward" merge mean?**
4. **When is it safe to use `git rebase`?**
5. **How do you undo a merge that's already committed?**

### Hands-On Challenge

Practice branching workflow:

```bash
# 1. Create repo and make initial commit
git init branch-practice
cd branch-practice
echo "# Branch Practice" > README.md
git add README.md
git commit -m "Initial commit"

# 2. Create and switch to feature branch
git checkout -b feature/add-hello

# 3. Make changes
echo "print('Hello from feature')" > hello.py
git add hello.py
git commit -m "Add hello script"

# 4. Switch back to main and create another file
git checkout main
echo "print('Hello from main')" > main.py
git add main.py
git commit -m "Add main script"

# 5. Merge feature branch
git merge feature/add-hello

# 6. Check result
git log --oneline --graph --all

# 7. Clean up
git branch -d feature/add-hello
```

### Answers

<details>
<summary>Click to reveal answers</summary>

1. **Merge vs Rebase**:
   - **Merge**: Combines branches with a new merge commit, preserves history
   - **Rebase**: Re-applies commits on top of another branch, creates linear history
   - **Rule**: Merge for shared branches, rebase for local feature branches

2. **Delete Current Branch**:
   - NO! You must switch to another branch first
   - `git checkout main` then `git branch -d feature`

3. **Fast-Forward Merge**:
   - When target branch hasn't changed since feature branch was created
   - Git just moves the branch pointer forward (no merge commit needed)
   - Example: main hasn't changed while you worked on feature

4. **Safe Rebase**:
   - ‚úÖ ONLY on local branches that haven't been pushed
   - ‚úÖ ONLY on commits that only you have
   - ‚ùå NEVER on shared/public branches (main, develop, etc.)

5. **Undo Merge**:
   - **If not pushed**: `git reset --hard HEAD~1`
   - **If pushed**: `git revert -m 1 HEAD` (creates new commit that undoes merge)

</details>

---

## üìã Quick Reference Card

### Essential Branch Commands

| Task | Command |
|------|---------|
| **List branches** | `git branch` |
| **Create branch** | `git branch feature-name` |
| **Switch branch** | `git checkout feature-name` |
| **Create & switch** | `git checkout -b feature-name` |
| **Merge branch** | `git merge feature-name` |
| **Delete branch** | `git branch -d feature-name` |
| **Force delete** | `git branch -D feature-name` |
| **List remote branches** | `git branch -r` |
| **List all branches** | `git branch -a` |

### Branch Naming Conventions

```
feature/feature-name      # New features
fix/bug-description       # Bug fixes
hotfix/critical-fix       # Production hotfixes
release/version-number    # Release preparation
experiment/idea           # Experimental work
docs/documentation        # Documentation updates
```

### Merge Types

| Type | When | How |
|------|------|-----|
| **Fast-Forward** | Target unchanged | Just move pointer |
| **Three-Way** | Both branches changed | Create merge commit |
| **Squash** | Want clean history | Combine all commits into one |

### Remember
‚úÖ Branch for every feature/fix  
‚úÖ Keep main branch always stable  
‚úÖ Merge or delete branches after completion  
‚úÖ Pull main before creating new branches  
‚úÖ Never rebase public branches  
‚ùå Don't work directly on main  
‚ùå Don't force push to shared branches  

---

## üèÜ Best Practices for Branching

### Branch Lifecycle

1. **Creation**
   ```bash
   git checkout main
   git pull origin main
   git checkout -b feature/new-feature
   ```

2. **Development**
   ```bash
   # Work, commit, repeat
   git add .
   git commit -m "Progress on feature"
   ```

3. **Keep Updated**
   ```bash
   # Periodically sync with main
   git checkout main
   git pull origin main
   git checkout feature/new-feature
   git merge main  # Or: git rebase main
   ```

4. **Completion**
   ```bash
   git checkout main
   git pull origin main
   git merge feature/new-feature
   git push origin main
   ```

5. **Cleanup**
   ```bash
   git branch -d feature/new-feature
   git push origin --delete feature/new-feature
   ```

---

This comprehensive guide to branching and merging provides the foundation for safe, collaborative development. Master these concepts to unlock Git's full potential for managing complex projects and team workflows!

**Next Steps**: Learn about [Collaboration with GitHub](05.collaboration_with_github.md) to work effectively with teams using pull requests, forks, and code reviews.