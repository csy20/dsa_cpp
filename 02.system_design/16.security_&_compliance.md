# Security & Compliance

## What Is Security & Compliance?

**Protect systems and data while meeting regulatory requirements**

```
Security principles (CIA Triad):
‚îú‚îÄ Confidentiality: Only authorized access (encryption, access control)
‚îú‚îÄ Integrity: Data accuracy and trustworthiness (checksums, signatures)
‚îî‚îÄ Availability: System accessible when needed (redundancy, DDoS protection)

Defense in depth (layers):
1. Network: Firewalls, VPC, security groups
2. Application: Authentication, authorization, input validation
3. Data: Encryption at rest and in transit
4. Identity: MFA, SSO, least privilege
5. Monitoring: Audit logs, intrusion detection

Compliance (regulations):
‚îú‚îÄ GDPR (EU): Data privacy, right to deletion
‚îú‚îÄ CCPA (California): Consumer data rights
‚îú‚îÄ HIPAA (Healthcare): Patient data protection
‚îú‚îÄ PCI DSS (Payments): Credit card security
‚îî‚îÄ SOC 2: Security, availability, confidentiality
```

---

## 1. Authentication & Authorization

### 1.1 Authentication (AuthN)

**Verify user identity (who you are)**

```
Authentication methods:

1. Password-based (traditional):
   ‚îú‚îÄ User provides username + password
   ‚îú‚îÄ Server verifies credentials
   ‚îî‚îÄ Problems: Phishing, password reuse, weak passwords

2. Multi-factor authentication (MFA):
   ‚îú‚îÄ Something you know (password)
   ‚îú‚îÄ Something you have (phone, hardware key)
   ‚îî‚îÄ Something you are (biometric: fingerprint, face)

3. Token-based (modern):
   ‚îú‚îÄ User logs in once
   ‚îú‚îÄ Receives token (JWT, OAuth)
   ‚îú‚îÄ Token used for subsequent requests
   ‚îî‚îÄ Benefits: Stateless, scalable

4. Passwordless:
   ‚îú‚îÄ Email magic link
   ‚îú‚îÄ SMS code
   ‚îú‚îÄ WebAuthn (biometric, hardware key)
   ‚îî‚îÄ Benefits: No password to steal
```

**Password Storage (DO NOT store plaintext!):**

```python
import bcrypt

# Hash password (one-way, irreversible)
def hash_password(password: str) -> bytes:
    # Generate salt (random data)
    salt = bcrypt.gensalt(rounds=12)  # 12 rounds = 2^12 iterations
    
    # Hash password with salt
    hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
    
    return hashed

# Verify password
def verify_password(password: str, hashed: bytes) -> bool:
    return bcrypt.checkpw(password.encode('utf-8'), hashed)

# Usage (user registration)
user_password = "MySecureP@ssw0rd"
hashed = hash_password(user_password)
db.users.insert({"username": "john", "password_hash": hashed})

# Usage (user login)
input_password = "MySecureP@ssw0rd"
stored_hash = db.users.find_one({"username": "john"})["password_hash"]

if verify_password(input_password, stored_hash):
    print("Login successful")
else:
    print("Invalid credentials")

# Why bcrypt?
# + Slow by design (expensive to brute force)
# + Built-in salt (prevents rainbow tables)
# + Adaptive (increase rounds as computers get faster)

# Never:
# ‚úó Store plaintext: db.insert({"password": "MySecureP@ssw0rd"})
# ‚úó Use MD5/SHA1: hash = hashlib.md5(password.encode()).hexdigest()
# ‚úó Hash without salt: hash = hashlib.sha256(password.encode()).hexdigest()
```

### 1.2 OAuth 2.0

**Delegated authorization (allow third-party access)**

```
OAuth 2.0 flow (Authorization Code Grant):

User wants to let App access their Google Drive:

1. User ‚Üí App: "Connect Google Drive"
2. App ‚Üí User: Redirect to Google authorization URL
   https://accounts.google.com/o/oauth2/auth?
     client_id=APP_ID&
     redirect_uri=https://app.example.com/callback&
     response_type=code&
     scope=drive.readonly

3. User ‚Üí Google: Login and approve (grant permissions)
4. Google ‚Üí User ‚Üí App: Redirect with authorization code
   https://app.example.com/callback?code=AUTH_CODE

5. App ‚Üí Google: Exchange code for access token
   POST https://oauth2.googleapis.com/token
   {
     "code": "AUTH_CODE",
     "client_id": "APP_ID",
     "client_secret": "APP_SECRET",
     "redirect_uri": "https://app.example.com/callback",
     "grant_type": "authorization_code"
   }

6. Google ‚Üí App: Access token + refresh token
   {
     "access_token": "ya29.a0AfH6SMC...",
     "refresh_token": "1//0gL3...",
     "expires_in": 3600,
     "token_type": "Bearer"
   }

7. App ‚Üí Google API: Access user's Drive (with access token)
   GET https://www.googleapis.com/drive/v3/files
   Authorization: Bearer ya29.a0AfH6SMC...

8. Google API ‚Üí App: User's files

Key concepts:
‚îú‚îÄ Authorization code: Short-lived (1 use, 10 minutes)
‚îú‚îÄ Access token: Short-lived (1 hour), used to access API
‚îú‚îÄ Refresh token: Long-lived (days/months), get new access token
‚îî‚îÄ Scopes: Permissions (drive.readonly, gmail.send, etc.)
```

**OAuth 2.0 Implementation:**

```python
from flask import Flask, redirect, request, session
import requests

app = Flask(__name__)
app.secret_key = 'your_secret_key'

# OAuth configuration
OAUTH_CLIENT_ID = 'your_client_id'
OAUTH_CLIENT_SECRET = 'your_client_secret'
OAUTH_REDIRECT_URI = 'http://localhost:5000/callback'
OAUTH_AUTHORIZE_URL = 'https://accounts.google.com/o/oauth2/auth'
OAUTH_TOKEN_URL = 'https://oauth2.googleapis.com/token'

# Step 1: Redirect user to OAuth provider
@app.route('/login')
def login():
    params = {
        'client_id': OAUTH_CLIENT_ID,
        'redirect_uri': OAUTH_REDIRECT_URI,
        'response_type': 'code',
        'scope': 'openid email profile',
        'state': 'random_state_string'  # CSRF protection
    }
    
    auth_url = f"{OAUTH_AUTHORIZE_URL}?{'&'.join([f'{k}={v}' for k, v in params.items()])}"
    return redirect(auth_url)

# Step 2: Handle callback, exchange code for token
@app.route('/callback')
def callback():
    # Verify state (CSRF protection)
    state = request.args.get('state')
    if state != 'random_state_string':
        return "Invalid state", 400
    
    # Get authorization code
    code = request.args.get('code')
    
    # Exchange code for access token
    token_data = {
        'code': code,
        'client_id': OAUTH_CLIENT_ID,
        'client_secret': OAUTH_CLIENT_SECRET,
        'redirect_uri': OAUTH_REDIRECT_URI,
        'grant_type': 'authorization_code'
    }
    
    response = requests.post(OAUTH_TOKEN_URL, data=token_data)
    tokens = response.json()
    
    # Store tokens in session (or database)
    session['access_token'] = tokens['access_token']
    session['refresh_token'] = tokens.get('refresh_token')
    
    return redirect('/dashboard')

# Step 3: Use access token to call API
@app.route('/dashboard')
def dashboard():
    access_token = session.get('access_token')
    
    if not access_token:
        return redirect('/login')
    
    # Call Google API with access token
    headers = {'Authorization': f'Bearer {access_token}'}
    response = requests.get(
        'https://www.googleapis.com/oauth2/v2/userinfo',
        headers=headers
    )
    
    user_info = response.json()
    return f"Hello, {user_info['name']}!"

# Refresh access token (when expired)
def refresh_access_token(refresh_token):
    token_data = {
        'refresh_token': refresh_token,
        'client_id': OAUTH_CLIENT_ID,
        'client_secret': OAUTH_CLIENT_SECRET,
        'grant_type': 'refresh_token'
    }
    
    response = requests.post(OAUTH_TOKEN_URL, data=token_data)
    tokens = response.json()
    
    return tokens['access_token']
```

### 1.3 OpenID Connect (OIDC)

**Authentication layer on top of OAuth 2.0**

```
OAuth 2.0: Authorization (what can you access?)
OIDC: Authentication (who are you?) + Authorization

OIDC adds:
‚îú‚îÄ ID Token (JWT): User identity information
‚îú‚îÄ UserInfo endpoint: Get user profile
‚îî‚îÄ Standard claims: name, email, picture, etc.

ID Token (JWT):
{
  "iss": "https://accounts.google.com",
  "sub": "1234567890",
  "aud": "your_client_id",
  "exp": 1640995200,
  "iat": 1640991600,
  "name": "John Doe",
  "email": "john@example.com",
  "picture": "https://..."
}

Signature: Verify token wasn't tampered with
```

### 1.4 JWT (JSON Web Tokens)

**Stateless authentication tokens**

```
JWT structure:
header.payload.signature

Header (algorithm, type):
{
  "alg": "HS256",
  "typ": "JWT"
}

Payload (claims):
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1640991600,
  "exp": 1640995200
}

Signature (verify integrity):
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret_key
)

Full JWT:
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNjQwOTkxNjAwLCJleHAiOjE2NDA5OTUyMDB9.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

Benefits:
+ Stateless (no server-side session storage)
+ Self-contained (all info in token)
+ Scalable (no database lookup)

Drawbacks:
- Cannot revoke (until expiration)
- Size (larger than session ID)
- Security (if secret leaked, all tokens compromised)
```

**JWT Implementation:**

```python
import jwt
from datetime import datetime, timedelta

SECRET_KEY = 'your-secret-key-keep-this-safe'

# Generate JWT
def generate_token(user_id, expires_in_minutes=60):
    payload = {
        'sub': user_id,  # Subject (user ID)
        'iat': datetime.utcnow(),  # Issued at
        'exp': datetime.utcnow() + timedelta(minutes=expires_in_minutes),  # Expiration
        'name': 'John Doe',
        'role': 'admin'
    }
    
    token = jwt.encode(payload, SECRET_KEY, algorithm='HS256')
    return token

# Verify JWT
def verify_token(token):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=['HS256'])
        return payload
    except jwt.ExpiredSignatureError:
        return None  # Token expired
    except jwt.InvalidTokenError:
        return None  # Invalid token

# Usage (login)
@app.route('/login', methods=['POST'])
def login():
    username = request.json['username']
    password = request.json['password']
    
    # Verify credentials
    user = db.users.find_one({'username': username})
    if user and verify_password(password, user['password_hash']):
        # Generate JWT
        token = generate_token(user['_id'])
        return jsonify({'token': token})
    
    return jsonify({'error': 'Invalid credentials'}), 401

# Usage (protected endpoint)
@app.route('/api/profile')
def profile():
    # Extract token from Authorization header
    auth_header = request.headers.get('Authorization')
    if not auth_header or not auth_header.startswith('Bearer '):
        return jsonify({'error': 'Missing token'}), 401
    
    token = auth_header.split(' ')[1]
    
    # Verify token
    payload = verify_token(token)
    if not payload:
        return jsonify({'error': 'Invalid or expired token'}), 401
    
    # Access granted
    user_id = payload['sub']
    user = db.users.find_one({'_id': user_id})
    
    return jsonify({'name': user['name'], 'email': user['email']})
```

**JWT Best Practices:**

```python
# 1. Use asymmetric keys (RS256) for distributed systems
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import rsa

# Generate RSA key pair
private_key = rsa.generate_private_key(
    public_exponent=65537,
    key_size=2048,
    backend=default_backend()
)

public_key = private_key.public_key()

# Sign with private key (auth service)
token = jwt.encode(payload, private_key, algorithm='RS256')

# Verify with public key (any service)
payload = jwt.decode(token, public_key, algorithms=['RS256'])

# 2. Short expiration (15 minutes) + refresh tokens
access_token = generate_token(user_id, expires_in_minutes=15)
refresh_token = generate_token(user_id, expires_in_minutes=10080)  # 7 days

# 3. Include minimal data in JWT
payload = {
    'sub': user_id,
    'role': 'admin',  # Only role, not full profile
    'exp': ...
}

# 4. Refresh token rotation (invalidate old refresh token)
@app.route('/token/refresh', methods=['POST'])
def refresh():
    refresh_token = request.json['refresh_token']
    payload = verify_token(refresh_token)
    
    if not payload:
        return jsonify({'error': 'Invalid refresh token'}), 401
    
    # Generate new access token + new refresh token
    new_access_token = generate_token(payload['sub'], expires_in_minutes=15)
    new_refresh_token = generate_token(payload['sub'], expires_in_minutes=10080)
    
    # Invalidate old refresh token (store in database or Redis)
    revoked_tokens.add(refresh_token)
    
    return jsonify({
        'access_token': new_access_token,
        'refresh_token': new_refresh_token
    })
```

### 1.5 Authorization (AuthZ)

**Determine what user can do (permissions)**

```
Authorization models:

1. Role-Based Access Control (RBAC):
   ‚îú‚îÄ Users assigned roles (admin, editor, viewer)
   ‚îú‚îÄ Roles have permissions (read, write, delete)
   ‚îî‚îÄ Simple, common

2. Attribute-Based Access Control (ABAC):
   ‚îú‚îÄ Access based on attributes (user, resource, environment)
   ‚îú‚îÄ Flexible, complex
   ‚îî‚îÄ Example: "Allow if user.department == resource.department"

3. Access Control Lists (ACL):
   ‚îú‚îÄ Each resource has list of users + permissions
   ‚îî‚îÄ Example: File permissions (owner, group, others)

4. Policy-Based Access Control:
   ‚îú‚îÄ Policies define rules (Open Policy Agent)
   ‚îî‚îÄ Centralized, declarative
```

**RBAC Implementation:**

```python
# Database schema
users = {
    "_id": "user123",
    "username": "john",
    "roles": ["editor", "viewer"]
}

roles = {
    "_id": "editor",
    "permissions": ["posts:read", "posts:write", "posts:delete"]
}

# Check permission
def has_permission(user_id, permission):
    user = db.users.find_one({"_id": user_id})
    user_roles = user["roles"]
    
    for role_name in user_roles:
        role = db.roles.find_one({"_id": role_name})
        if permission in role["permissions"]:
            return True
    
    return False

# Decorator for permission checks
from functools import wraps

def require_permission(permission):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            user_id = get_current_user_id()  # From JWT or session
            
            if not has_permission(user_id, permission):
                return jsonify({"error": "Forbidden"}), 403
            
            return func(*args, **kwargs)
        return wrapper
    return decorator

# Usage
@app.route('/posts', methods=['POST'])
@require_permission('posts:write')
def create_post():
    # Only users with posts:write permission can access
    return jsonify({"message": "Post created"})

@app.route('/posts/<post_id>', methods=['DELETE'])
@require_permission('posts:delete')
def delete_post(post_id):
    # Only users with posts:delete permission can access
    return jsonify({"message": "Post deleted"})
```

**Resource-Based Authorization:**

```python
# Check if user owns resource
def is_resource_owner(user_id, resource_id):
    resource = db.posts.find_one({"_id": resource_id})
    return resource and resource["author_id"] == user_id

@app.route('/posts/<post_id>', methods=['PUT'])
def update_post(post_id):
    user_id = get_current_user_id()
    
    # Check ownership or admin role
    if not is_resource_owner(user_id, post_id) and not has_role(user_id, 'admin'):
        return jsonify({"error": "Forbidden"}), 403
    
    # Update post
    return jsonify({"message": "Post updated"})
```

---

## 2. Secrets Management

### 2.1 Secrets Storage

**Never hardcode secrets in source code**

```
Bad (hardcoded):
API_KEY = "sk_live_51H123456789..."
DATABASE_URL = "postgresql://user:password@localhost/db"

Good (environment variables):
import os
API_KEY = os.environ.get('API_KEY')
DATABASE_URL = os.environ.get('DATABASE_URL')

Better (secrets manager):
import boto3
secrets = boto3.client('secretsmanager')
response = secrets.get_secret_value(SecretId='prod/api_key')
API_KEY = response['SecretString']

Best (dynamic secrets):
# Vault generates short-lived database credentials
vault_client = hvac.Client(url='http://vault:8200')
db_creds = vault_client.secrets.database.generate_credentials('my-role')
DATABASE_URL = f"postgresql://{db_creds['username']}:{db_creds['password']}@localhost/db"
```

### 2.2 AWS Secrets Manager

```python
import boto3
import json

secrets_client = boto3.client('secretsmanager', region_name='us-east-1')

# Store secret
def store_secret(secret_name, secret_value):
    secrets_client.create_secret(
        Name=secret_name,
        SecretString=json.dumps(secret_value)
    )

# Retrieve secret
def get_secret(secret_name):
    response = secrets_client.get_secret_value(SecretId=secret_name)
    return json.loads(response['SecretString'])

# Usage
store_secret('prod/database', {
    'username': 'admin',
    'password': 'SuperSecureP@ssw0rd',
    'host': 'db.example.com',
    'port': 5432
})

db_config = get_secret('prod/database')
connection = psycopg2.connect(
    host=db_config['host'],
    port=db_config['port'],
    user=db_config['username'],
    password=db_config['password']
)

# Rotate secret (automatic)
secrets_client.rotate_secret(
    SecretId='prod/database',
    RotationLambdaARN='arn:aws:lambda:...',
    RotationRules={'AutomaticallyAfterDays': 30}
)
```

### 2.3 HashiCorp Vault

```python
import hvac

# Initialize Vault client
vault_client = hvac.Client(url='http://vault:8200')

# Authenticate (AppRole)
vault_client.auth.approle.login(
    role_id='your-role-id',
    secret_id='your-secret-id'
)

# Store secret (KV v2)
vault_client.secrets.kv.v2.create_or_update_secret(
    path='myapp/config',
    secret={
        'api_key': 'sk_live_123456',
        'database_password': 'SecureP@ssw0rd'
    }
)

# Read secret
secret = vault_client.secrets.kv.v2.read_secret_version(path='myapp/config')
api_key = secret['data']['data']['api_key']

# Dynamic secrets (database credentials)
db_creds = vault_client.secrets.database.generate_credentials('my-role')
# Returns: {'username': 'v-root-my-role-abc123', 'password': '...', 'lease_duration': 3600}

# Short-lived credentials (expire after 1 hour)
# Vault automatically revokes after expiration
```

### 2.4 Key Management Service (KMS)

**Encrypt/decrypt data with managed keys**

```python
import boto3
import base64

kms_client = boto3.client('kms', region_name='us-east-1')

# Encrypt data
def encrypt_data(plaintext, key_id):
    response = kms_client.encrypt(
        KeyId=key_id,
        Plaintext=plaintext.encode('utf-8')
    )
    
    # Return base64-encoded ciphertext
    return base64.b64encode(response['CiphertextBlob']).decode('utf-8')

# Decrypt data
def decrypt_data(ciphertext):
    ciphertext_blob = base64.b64decode(ciphertext)
    
    response = kms_client.decrypt(
        CiphertextBlob=ciphertext_blob
    )
    
    return response['Plaintext'].decode('utf-8')

# Usage
key_id = 'arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012'

# Encrypt sensitive data before storing in database
ssn = "123-45-6789"
encrypted_ssn = encrypt_data(ssn, key_id)
db.users.insert({"user_id": 123, "ssn_encrypted": encrypted_ssn})

# Decrypt when needed
encrypted_ssn = db.users.find_one({"user_id": 123})["ssn_encrypted"]
ssn = decrypt_data(encrypted_ssn)

# Envelope encryption (encrypt large data efficiently)
def envelope_encrypt(plaintext, key_id):
    # Generate data key
    response = kms_client.generate_data_key(
        KeyId=key_id,
        KeySpec='AES_256'
    )
    
    data_key_plaintext = response['Plaintext']
    data_key_encrypted = response['CiphertextBlob']
    
    # Encrypt data with data key (local, fast)
    from cryptography.fernet import Fernet
    fernet = Fernet(base64.urlsafe_b64encode(data_key_plaintext[:32]))
    ciphertext = fernet.encrypt(plaintext.encode('utf-8'))
    
    # Return encrypted data + encrypted data key
    return {
        'ciphertext': base64.b64encode(ciphertext).decode('utf-8'),
        'encrypted_data_key': base64.b64encode(data_key_encrypted).decode('utf-8')
    }

# Decrypt
def envelope_decrypt(encrypted_data):
    # Decrypt data key with KMS
    data_key_encrypted = base64.b64decode(encrypted_data['encrypted_data_key'])
    response = kms_client.decrypt(CiphertextBlob=data_key_encrypted)
    data_key_plaintext = response['Plaintext']
    
    # Decrypt data with data key
    from cryptography.fernet import Fernet
    fernet = Fernet(base64.urlsafe_b64encode(data_key_plaintext[:32]))
    ciphertext = base64.b64decode(encrypted_data['ciphertext'])
    plaintext = fernet.decrypt(ciphertext)
    
    return plaintext.decode('utf-8')
```

---

## 3. Network Security

### 3.1 TLS/SSL (HTTPS)

**Encrypt data in transit**

```
TLS handshake:

1. Client ‚Üí Server: ClientHello (supported ciphers, TLS versions)
2. Server ‚Üí Client: ServerHello (chosen cipher, TLS version)
3. Server ‚Üí Client: Certificate (public key)
4. Client: Verify certificate (CA signature, expiration, hostname)
5. Client ‚Üí Server: Encrypted pre-master secret (with server's public key)
6. Both: Derive session keys from pre-master secret
7. Both: Exchange "Finished" messages (encrypted with session key)
8. Both: Application data (encrypted with session key)

Benefits:
+ Encryption (eavesdropping protection)
+ Authentication (verify server identity)
+ Integrity (detect tampering)

Certificate chain:
Root CA (trusted) ‚Üí Intermediate CA ‚Üí Server certificate
Browser trusts root CA ‚Üí validates chain ‚Üí trusts server
```

**Force HTTPS:**

```python
from flask import Flask, request, redirect

app = Flask(__name__)

@app.before_request
def force_https():
    if not request.is_secure:
        # Redirect HTTP to HTTPS
        return redirect(request.url.replace('http://', 'https://'), code=301)

# HSTS header (force HTTPS for future visits)
@app.after_request
def add_security_headers(response):
    response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'
    return response
```

### 3.2 mTLS (Mutual TLS)

**Both client and server authenticate**

```
Regular TLS:
‚îú‚îÄ Server provides certificate
‚îú‚îÄ Client verifies server
‚îî‚îÄ Server doesn't verify client

mTLS:
‚îú‚îÄ Server provides certificate
‚îú‚îÄ Client provides certificate
‚îú‚îÄ Both verify each other
‚îî‚îÄ Use case: Service-to-service communication

mTLS handshake:
1. Client ‚Üí Server: ClientHello
2. Server ‚Üí Client: ServerHello + Server certificate
3. Server ‚Üí Client: Certificate request
4. Client ‚Üí Server: Client certificate
5. Server: Verify client certificate
6. Both: Encrypted communication

Benefits:
+ Strong authentication (certificates, not passwords)
+ Zero-trust networking (verify every connection)
+ Prevent man-in-the-middle attacks
```

**mTLS with Requests:**

```python
import requests

# Client certificate + private key
response = requests.get(
    'https://api.example.com/data',
    cert=('/path/to/client_cert.pem', '/path/to/client_key.pem'),
    verify='/path/to/ca_cert.pem'  # Verify server certificate
)

# Server validates client certificate
# Only authorized clients (with valid cert) can connect
```

**mTLS Server (Flask):**

```python
from flask import Flask
import ssl

app = Flask(__name__)

# Configure mTLS
context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
context.load_cert_chain('/path/to/server_cert.pem', '/path/to/server_key.pem')
context.load_verify_locations('/path/to/ca_cert.pem')
context.verify_mode = ssl.CERT_REQUIRED  # Require client certificate

@app.route('/api/data')
def get_data():
    # Only clients with valid certificate can reach here
    return {"data": "sensitive information"}

app.run(host='0.0.0.0', port=5000, ssl_context=context)
```

### 3.3 Web Application Firewall (WAF)

**Filter malicious HTTP requests**

```
WAF protects against:
‚îú‚îÄ SQL injection: ' OR '1'='1
‚îú‚îÄ Cross-site scripting (XSS): <script>alert('XSS')</script>
‚îú‚îÄ Command injection: ; rm -rf /
‚îú‚îÄ Path traversal: ../../etc/passwd
‚îú‚îÄ DDoS attacks: Rate limiting, bot detection
‚îî‚îÄ Known vulnerabilities: OWASP Top 10

WAF placement:
Internet ‚Üí WAF ‚Üí Load Balancer ‚Üí App Servers

WAF rules:
1. Allow known good (whitelist)
2. Block known bad (blacklist)
3. Rate limiting (per IP, per endpoint)
4. Geo-blocking (block countries)
5. Bot detection (challenge-response)
```

**AWS WAF Example:**

```python
import boto3

waf_client = boto3.client('wafv2', region_name='us-east-1')

# Create rate-based rule (block IPs with >2000 requests/5 minutes)
waf_client.create_web_acl(
    Name='MyWebACL',
    Scope='REGIONAL',
    DefaultAction={'Allow': {}},
    Rules=[
        {
            'Name': 'RateLimitRule',
            'Priority': 1,
            'Statement': {
                'RateBasedStatement': {
                    'Limit': 2000,
                    'AggregateKeyType': 'IP'
                }
            },
            'Action': {'Block': {}},
            'VisibilityConfig': {
                'SampledRequestsEnabled': True,
                'CloudWatchMetricsEnabled': True,
                'MetricName': 'RateLimitRule'
            }
        },
        {
            'Name': 'SQLiProtection',
            'Priority': 2,
            'Statement': {
                'ManagedRuleGroupStatement': {
                    'VendorName': 'AWS',
                    'Name': 'AWSManagedRulesSQLiRuleSet'
                }
            },
            'OverrideAction': {'None': {}},
            'VisibilityConfig': {
                'SampledRequestsEnabled': True,
                'CloudWatchMetricsEnabled': True,
                'MetricName': 'SQLiProtection'
            }
        }
    ],
    VisibilityConfig={
        'SampledRequestsEnabled': True,
        'CloudWatchMetricsEnabled': True,
        'MetricName': 'MyWebACL'
    }
)
```

**Application-Level Protection:**

```python
from flask import Flask, request
import re

app = Flask(__name__)

# SQL injection detection
def is_sql_injection(value):
    sql_patterns = [
        r"(\bunion\b.*\bselect\b)",
        r"(\bor\b\s+['\"]?\d+['\"]?\s*=\s*['\"]?\d+['\"]?)",
        r"(;\s*drop\s+table)",
        r"(--\s*$)"
    ]
    
    for pattern in sql_patterns:
        if re.search(pattern, value, re.IGNORECASE):
            return True
    return False

# XSS detection
def is_xss(value):
    xss_patterns = [
        r"<script[^>]*>.*?</script>",
        r"javascript:",
        r"onerror\s*=",
        r"onload\s*="
    ]
    
    for pattern in xss_patterns:
        if re.search(pattern, value, re.IGNORECASE):
            return True
    return False

@app.before_request
def validate_input():
    # Check all query parameters and form data
    for key, value in request.values.items():
        if is_sql_injection(value) or is_xss(value):
            return jsonify({"error": "Malicious input detected"}), 400

# Rate limiting (simple)
from collections import defaultdict
import time

request_counts = defaultdict(list)

@app.before_request
def rate_limit():
    ip = request.remote_addr
    now = time.time()
    
    # Clean old requests (older than 1 minute)
    request_counts[ip] = [t for t in request_counts[ip] if now - t < 60]
    
    # Check rate limit (100 requests per minute)
    if len(request_counts[ip]) >= 100:
        return jsonify({"error": "Rate limit exceeded"}), 429
    
    request_counts[ip].append(now)
```

---

## 4. Compliance & Privacy

### 4.1 PII (Personally Identifiable Information)

**Data that can identify individuals**

```
PII categories:

Direct identifiers (uniquely identify):
‚îú‚îÄ Name (full name)
‚îú‚îÄ Social Security Number (SSN)
‚îú‚îÄ Email address
‚îú‚îÄ Phone number
‚îú‚îÄ Passport number
‚îú‚îÄ Driver's license
‚îî‚îÄ Biometric data (fingerprint, face)

Indirect identifiers (combined, can identify):
‚îú‚îÄ Date of birth
‚îú‚îÄ ZIP code
‚îú‚îÄ Gender
‚îî‚îÄ Race/ethnicity

Sensitive PII (higher risk):
‚îú‚îÄ Health information (medical records)
‚îú‚îÄ Financial data (credit card, bank account)
‚îú‚îÄ Biometric data
‚îî‚îÄ Criminal records

PII handling:
1. Minimize collection (only collect what's needed)
2. Encrypt at rest (database encryption)
3. Encrypt in transit (TLS/HTTPS)
4. Access control (least privilege)
5. Audit logs (who accessed what, when)
6. Anonymization/pseudonymization (when possible)
7. Retention limits (delete after period)
8. Secure deletion (unrecoverable)
```

**PII Anonymization:**

```python
import hashlib

# Pseudonymization (reversible with key)
def pseudonymize(pii, key):
    """Replace PII with pseudonym (hash)"""
    return hashlib.sha256(f"{pii}{key}".encode()).hexdigest()

# Anonymization (irreversible)
def anonymize_email(email):
    """user@example.com ‚Üí u***@example.com"""
    parts = email.split('@')
    username = parts[0]
    domain = parts[1]
    
    if len(username) > 2:
        anonymized = username[0] + '*' * (len(username) - 1)
    else:
        anonymized = '*' * len(username)
    
    return f"{anonymized}@{domain}"

def anonymize_phone(phone):
    """123-456-7890 ‚Üí ***-***-7890"""
    return '***-***-' + phone[-4:]

def anonymize_ssn(ssn):
    """123-45-6789 ‚Üí ***-**-6789"""
    return '***-**-' + ssn[-4:]

# K-anonymity (group records)
def k_anonymize(records, k=5):
    """Ensure each record indistinguishable from k-1 others"""
    # Group by quasi-identifiers (age, ZIP, gender)
    # Generalize values (age 32 ‚Üí age 30-35, ZIP 12345 ‚Üí ZIP 123**)
    pass

# Differential privacy (add noise)
def differential_privacy_query(query_result, sensitivity=1, epsilon=0.1):
    """Add Laplace noise to query result"""
    import numpy as np
    noise = np.random.laplace(0, sensitivity / epsilon)
    return query_result + noise

# Example: Age distribution (noisy)
actual_count = 1000
noisy_count = differential_privacy_query(actual_count, sensitivity=1, epsilon=0.1)
# Returns: ~1000 (with noise, prevents exact inference)
```

### 4.2 GDPR (General Data Protection Regulation)

**EU data privacy regulation**

```
GDPR principles:

1. Lawfulness, fairness, transparency:
   ‚îú‚îÄ Inform users about data collection
   ‚îú‚îÄ Obtain consent (explicit, opt-in)
   ‚îî‚îÄ Privacy policy (clear, accessible)

2. Purpose limitation:
   ‚îú‚îÄ Collect data for specific purpose only
   ‚îî‚îÄ Don't repurpose without consent

3. Data minimization:
   ‚îî‚îÄ Collect only necessary data

4. Accuracy:
   ‚îî‚îÄ Keep data accurate and up-to-date

5. Storage limitation:
   ‚îî‚îÄ Delete data when no longer needed

6. Integrity and confidentiality:
   ‚îú‚îÄ Secure data (encryption, access control)
   ‚îî‚îÄ Prevent unauthorized access

7. Accountability:
   ‚îî‚îÄ Demonstrate compliance (audit logs, policies)

User rights:

1. Right to access (data portability):
   ‚îî‚îÄ User can request all their data

2. Right to rectification:
   ‚îî‚îÄ User can correct inaccurate data

3. Right to erasure ("right to be forgotten"):
   ‚îî‚îÄ User can request data deletion

4. Right to restrict processing:
   ‚îî‚îÄ User can limit how data is used

5. Right to object:
   ‚îî‚îÄ User can opt out of processing

6. Right to data portability:
   ‚îî‚îÄ User can export data in machine-readable format

Penalties:
‚îú‚îÄ Up to ‚Ç¨20 million
‚îî‚îÄ Or 4% of global annual revenue (whichever higher)
```

**GDPR Compliance Implementation:**

```python
# 1. Consent management
def request_consent(user_id, purpose):
    """Record user consent"""
    db.consents.insert({
        'user_id': user_id,
        'purpose': purpose,  # 'marketing', 'analytics', etc.
        'granted': True,
        'timestamp': datetime.utcnow(),
        'ip_address': request.remote_addr
    })

def has_consent(user_id, purpose):
    """Check if user consented"""
    consent = db.consents.find_one({
        'user_id': user_id,
        'purpose': purpose,
        'granted': True
    })
    return consent is not None

# 2. Right to access (data export)
@app.route('/api/user/export', methods=['GET'])
def export_user_data():
    user_id = get_current_user_id()
    
    # Collect all user data from all tables
    user_data = {
        'profile': db.users.find_one({'_id': user_id}),
        'orders': list(db.orders.find({'user_id': user_id})),
        'posts': list(db.posts.find({'author_id': user_id})),
        'comments': list(db.comments.find({'user_id': user_id}))
    }
    
    # Return as JSON (machine-readable)
    return jsonify(user_data)

# 3. Right to erasure (delete account)
@app.route('/api/user/delete', methods=['DELETE'])
def delete_user_account():
    user_id = get_current_user_id()
    
    # Log deletion request (audit trail)
    db.deletion_logs.insert({
        'user_id': user_id,
        'timestamp': datetime.utcnow(),
        'ip_address': request.remote_addr
    })
    
    # Delete user data from all tables
    db.users.delete_one({'_id': user_id})
    db.orders.delete_many({'user_id': user_id})
    db.posts.delete_many({'author_id': user_id})
    db.comments.delete_many({'user_id': user_id})
    
    # Anonymize instead of delete (if retention required)
    # db.users.update_one(
    #     {'_id': user_id},
    #     {'$set': {
    #         'email': f'deleted_{user_id}@example.com',
    #         'name': 'Deleted User',
    #         'deleted': True
    #     }}
    # )
    
    return jsonify({'message': 'Account deleted'})

# 4. Data retention policy
def enforce_data_retention():
    """Delete old data (automated job)"""
    # Delete logs older than 90 days
    cutoff_date = datetime.utcnow() - timedelta(days=90)
    db.logs.delete_many({'timestamp': {'$lt': cutoff_date}})
    
    # Delete inactive users (no login in 2 years)
    inactive_cutoff = datetime.utcnow() - timedelta(days=730)
    db.users.delete_many({'last_login': {'$lt': inactive_cutoff}})

# Run daily
import schedule
schedule.every().day.at("02:00").do(enforce_data_retention)
```

### 4.3 CCPA (California Consumer Privacy Act)

```
CCPA (similar to GDPR, California residents):

Consumer rights:
1. Right to know (what data collected)
2. Right to delete
3. Right to opt-out (data sale)
4. Right to non-discrimination (no penalty for exercising rights)

Requirements:
‚îú‚îÄ Privacy policy (conspicuous, accessible)
‚îú‚îÄ "Do Not Sell My Personal Information" link
‚îú‚îÄ Respond to requests within 45 days
‚îî‚îÄ Verify consumer identity before fulfilling requests

Penalties:
‚îú‚îÄ Up to $7,500 per intentional violation
‚îî‚îÄ $2,500 per unintentional violation
```

### 4.4 Audit Trails

**Log access and changes to sensitive data**

```
Audit log requirements:
‚îú‚îÄ Who (user ID, IP address)
‚îú‚îÄ What (action: read, write, delete)
‚îú‚îÄ When (timestamp)
‚îú‚îÄ Where (resource ID, table, field)
‚îú‚îÄ Result (success, failure)
‚îî‚îÄ Immutable (tamper-proof)

Audit events:
‚îú‚îÄ Authentication (login, logout, failed attempts)
‚îú‚îÄ Authorization (permission checks, access denied)
‚îú‚îÄ Data access (read sensitive PII)
‚îú‚îÄ Data modification (create, update, delete)
‚îú‚îÄ Configuration changes (role assignments, permissions)
‚îî‚îÄ Security events (password reset, MFA setup)
```

**Audit Logging Implementation:**

```python
from datetime import datetime

def log_audit_event(event_type, user_id, resource_type, resource_id, action, result, details=None):
    """Log audit event"""
    audit_log = {
        'timestamp': datetime.utcnow(),
        'event_type': event_type,  # 'authentication', 'authorization', 'data_access'
        'user_id': user_id,
        'ip_address': request.remote_addr,
        'user_agent': request.headers.get('User-Agent'),
        'resource_type': resource_type,  # 'user', 'order', 'payment'
        'resource_id': resource_id,
        'action': action,  # 'read', 'create', 'update', 'delete'
        'result': result,  # 'success', 'failure', 'denied'
        'details': details  # Additional context
    }
    
    db.audit_logs.insert_one(audit_log)

# Usage
@app.route('/api/users/<user_id>', methods=['GET'])
def get_user(user_id):
    current_user_id = get_current_user_id()
    
    # Check authorization
    if not has_permission(current_user_id, 'users:read'):
        log_audit_event(
            event_type='authorization',
            user_id=current_user_id,
            resource_type='user',
            resource_id=user_id,
            action='read',
            result='denied',
            details={'reason': 'insufficient permissions'}
        )
        return jsonify({'error': 'Forbidden'}), 403
    
    # Fetch user
    user = db.users.find_one({'_id': user_id})
    
    # Log successful access
    log_audit_event(
        event_type='data_access',
        user_id=current_user_id,
        resource_type='user',
        resource_id=user_id,
        action='read',
        result='success'
    )
    
    return jsonify(user)

@app.route('/api/users/<user_id>', methods=['DELETE'])
def delete_user(user_id):
    current_user_id = get_current_user_id()
    
    # Delete user
    result = db.users.delete_one({'_id': user_id})
    
    # Log deletion
    log_audit_event(
        event_type='data_modification',
        user_id=current_user_id,
        resource_type='user',
        resource_id=user_id,
        action='delete',
        result='success' if result.deleted_count > 0 else 'failure'
    )
    
    return jsonify({'message': 'User deleted'})

# Query audit logs
def get_audit_trail(resource_type, resource_id):
    """Get full audit trail for resource"""
    logs = db.audit_logs.find({
        'resource_type': resource_type,
        'resource_id': resource_id
    }).sort('timestamp', -1)
    
    return list(logs)

# Example: Who accessed this user's data?
audit_trail = get_audit_trail('user', 'user123')
for event in audit_trail:
    print(f"{event['timestamp']}: {event['user_id']} performed {event['action']} - {event['result']}")
```

---

## 5. Security Best Practices

### 5.1 Principle of Least Privilege

**Grant minimum permissions necessary**

```
Bad (overprivileged):
‚îú‚îÄ Service account with admin access (full database access)
‚îú‚îÄ Developer with production database access
‚îî‚îÄ App with read/write to all S3 buckets

Good (least privilege):
‚îú‚îÄ Service account with read-only access to specific tables
‚îú‚îÄ Developer with read-only production access (read via replica)
‚îî‚îÄ App with read/write to specific S3 bucket prefix only

IAM policy (AWS):
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": ["s3:GetObject", "s3:PutObject"],
      "Resource": "arn:aws:s3:::my-bucket/uploads/*"
    }
  ]
}

Only allows read/write to uploads/ prefix (not entire bucket)
```

### 5.2 Defense in Depth

**Multiple layers of security**

```
Layers:

1. Network perimeter:
   ‚îú‚îÄ Firewall (block unauthorized traffic)
   ‚îú‚îÄ DDoS protection (CloudFlare, AWS Shield)
   ‚îî‚îÄ VPN (private network access)

2. Network segmentation:
   ‚îú‚îÄ Public subnet (load balancers, bastion)
   ‚îú‚îÄ Private subnet (app servers)
   ‚îî‚îÄ Data subnet (databases, isolated)

3. Application:
   ‚îú‚îÄ Authentication (OAuth, JWT)
   ‚îú‚îÄ Authorization (RBAC, ACL)
   ‚îú‚îÄ Input validation (prevent injection)
   ‚îî‚îÄ Rate limiting (prevent abuse)

4. Data:
   ‚îú‚îÄ Encryption at rest (KMS, AES-256)
   ‚îú‚îÄ Encryption in transit (TLS)
   ‚îî‚îÄ Access logging (audit trail)

5. Monitoring:
   ‚îú‚îÄ Intrusion detection (IDS/IPS)
   ‚îú‚îÄ Log analysis (SIEM)
   ‚îî‚îÄ Anomaly detection (unusual patterns)

Breach one layer ‚â† compromise entire system
```

### 5.3 Threat Modeling

**Identify and mitigate security risks**

```
STRIDE model (threat categories):

S = Spoofing (impersonate user):
   Threat: Attacker steals JWT token
   Mitigation: Short token expiration, HTTPS only, secure storage

T = Tampering (modify data):
   Threat: Man-in-the-middle attack
   Mitigation: TLS, message signing, integrity checks

R = Repudiation (deny action):
   Threat: User claims "I didn't do that"
   Mitigation: Audit logs, digital signatures, non-repudiation

I = Information disclosure (leak data):
   Threat: Unauthorized data access
   Mitigation: Encryption, access control, DLP (data loss prevention)

D = Denial of service (unavailable):
   Threat: DDoS attack, resource exhaustion
   Mitigation: Rate limiting, load balancing, CDN, auto-scaling

E = Elevation of privilege (gain unauthorized access):
   Threat: Exploit vulnerability to become admin
   Mitigation: Least privilege, input validation, security updates

Threat modeling process:
1. Identify assets (data, systems)
2. Identify threats (STRIDE)
3. Assess risk (likelihood √ó impact)
4. Mitigate (controls, countermeasures)
5. Validate (penetration testing)
```

**Example Threat Model:**

```
System: E-commerce checkout

Assets:
‚îú‚îÄ Payment information (credit cards)
‚îú‚îÄ User accounts (credentials, PII)
‚îî‚îÄ Order data (purchases, history)

Threats:

1. SQL injection (data breach):
   ‚îú‚îÄ Likelihood: Medium
   ‚îú‚îÄ Impact: High (steal all credit cards)
   ‚îú‚îÄ Risk: High
   ‚îî‚îÄ Mitigation: Parameterized queries, input validation, WAF

2. XSS (steal session tokens):
   ‚îú‚îÄ Likelihood: Medium
   ‚îú‚îÄ Impact: Medium (account takeover)
   ‚îú‚îÄ Risk: Medium
   ‚îî‚îÄ Mitigation: Escape output, CSP headers, HttpOnly cookies

3. Brute force login:
   ‚îú‚îÄ Likelihood: High
   ‚îú‚îÄ Impact: Low (single account compromise)
   ‚îú‚îÄ Risk: Medium
   ‚îî‚îÄ Mitigation: Rate limiting, CAPTCHA, MFA

4. Payment card skimming:
   ‚îú‚îÄ Likelihood: Low
   ‚îú‚îÄ Impact: High (mass card theft)
   ‚îú‚îÄ Risk: Medium
   ‚îî‚îÄ Mitigation: PCI DSS compliance, tokenization, iframe isolation

5. DDoS (site unavailable):
   ‚îú‚îÄ Likelihood: Medium
   ‚îú‚îÄ Impact: High (revenue loss)
   ‚îú‚îÄ Risk: High
   ‚îî‚îÄ Mitigation: CDN, auto-scaling, rate limiting, WAF
```

---

## Best Practices Summary

```
Authentication & Authorization:
‚úì Use bcrypt/Argon2 for passwords (never plaintext, MD5, SHA1)
‚úì Implement MFA (multi-factor authentication)
‚úì Use OAuth 2.0/OIDC for third-party auth
‚úì Short-lived JWT access tokens (15 min) + refresh tokens
‚úì RBAC for permissions (role-based access control)
‚úì Least privilege (minimum permissions needed)
‚úó Don't store passwords in plaintext
‚úó Don't use session cookies without HttpOnly, Secure, SameSite
‚úó Don't skip CSRF protection (use tokens)

Secrets Management:
‚úì Use secrets manager (AWS Secrets Manager, Vault)
‚úì Rotate secrets regularly (30-90 days)
‚úì Never commit secrets to git (use .env, .gitignore)
‚úì Use KMS for encryption keys (managed keys)
‚úì Dynamic secrets (short-lived credentials)
‚úì Audit secret access (who accessed what, when)
‚úó Don't hardcode API keys, passwords
‚úó Don't share secrets via email, Slack
‚úó Don't use same secret across environments

Network Security:
‚úì Use HTTPS everywhere (TLS 1.2+)
‚úì Force HTTPS redirects (HTTP ‚Üí HTTPS)
‚úì HSTS header (force HTTPS in browser)
‚úì mTLS for service-to-service (mutual authentication)
‚úì WAF for application protection (SQL injection, XSS, DDoS)
‚úì VPC/network segmentation (public, private, data subnets)
‚úó Don't use TLS 1.0/1.1 (deprecated, insecure)
‚úó Don't allow unencrypted database connections
‚úó Don't expose internal services publicly

Compliance & Privacy:
‚úì Minimize PII collection (only necessary data)
‚úì Encrypt PII at rest and in transit
‚úì Implement data retention policies (auto-delete old data)
‚úì GDPR/CCPA compliance (consent, right to delete)
‚úì Audit logs for all data access (who, what, when)
‚úì Anonymize/pseudonymize data (when possible)
‚úì Privacy policy (clear, accessible)
‚úó Don't collect unnecessary PII
‚úó Don't retain data indefinitely (delete when no longer needed)
‚úó Don't share PII without consent

General Security:
‚úì Defense in depth (multiple security layers)
‚úì Principle of least privilege (minimum permissions)
‚úì Input validation (prevent injection attacks)
‚úì Output encoding (prevent XSS)
‚úì Rate limiting (prevent brute force, DDoS)
‚úì Security headers (CSP, X-Frame-Options, etc.)
‚úì Regular security audits (penetration testing)
‚úì Keep dependencies updated (patch vulnerabilities)
‚úì Threat modeling (STRIDE, identify risks)
‚úó Don't trust user input (validate, sanitize)
‚úó Don't roll your own crypto (use proven libraries)
‚úó Don't ignore security warnings (CVEs, alerts)
```

Complete security and compliance foundation! üîíüõ°Ô∏èüìú