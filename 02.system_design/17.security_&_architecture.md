# Architecture Evolution & Microservices

## What Is Architecture Evolution?

**Transition from monolith â†’ modular â†’ microservices**

```
Evolution stages:

1. Monolith (single deployable unit):
   â”œâ”€ All code in one codebase
   â”œâ”€ Single database
   â”œâ”€ Deploy entire application
   â””â”€ Simple, but doesn't scale well

2. Modular Monolith (organized modules):
   â”œâ”€ Same deployment, but organized internally
   â”œâ”€ Clear module boundaries
   â”œâ”€ Still single database (or shared)
   â””â”€ Easier to understand, maintain

3. Microservices (distributed services):
   â”œâ”€ Independent deployable services
   â”œâ”€ Each service has own database
   â”œâ”€ Communicate via APIs (HTTP, gRPC)
   â””â”€ Complex, but scales independently

Trade-offs:
Monolith: Simple deployment, shared state, hard to scale
Microservices: Complex deployment, independent scaling, distributed problems
```

---

## 1. Architecture Patterns

### 1.1 Monolithic Architecture

**Single deployable application**

```
Monolith structure:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Monolithic App              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   User Interface (Web/API)   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   Business Logic Layer       â”‚  â”‚
â”‚  â”‚  â”œâ”€ User Management          â”‚  â”‚
â”‚  â”‚  â”œâ”€ Order Processing         â”‚  â”‚
â”‚  â”‚  â”œâ”€ Payment                  â”‚  â”‚
â”‚  â”‚  â””â”€ Inventory                â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   Data Access Layer          â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   Database    â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Characteristics:
+ Simple to develop (no distributed complexity)
+ Simple to deploy (single unit)
+ Simple to test (no network calls)
+ Easy transactions (single database)

- Hard to scale (scale entire app, not components)
- Slow deployment (deploy entire app)
- Technology lock-in (entire app in one language/framework)
- Hard to parallelize development (merge conflicts)
- Risky deployments (one bug affects entire app)
```

**Monolith Example (Flask):**

```python
from flask import Flask, jsonify, request
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'postgresql://localhost/ecommerce'
db = SQLAlchemy(app)

# Models (all in one database)
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(120), unique=True)

class Product(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100))
    price = db.Column(db.Float)

class Order(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    total = db.Column(db.Float)

# All business logic in one app
@app.route('/users', methods=['POST'])
def create_user():
    data = request.json
    user = User(email=data['email'])
    db.session.add(user)
    db.session.commit()
    return jsonify({'id': user.id})

@app.route('/orders', methods=['POST'])
def create_order():
    data = request.json
    
    # Calculate total (in-memory, same process)
    products = Product.query.filter(Product.id.in_(data['product_ids'])).all()
    total = sum(p.price for p in products)
    
    # Create order (single transaction)
    order = Order(user_id=data['user_id'], total=total)
    db.session.add(order)
    db.session.commit()
    
    return jsonify({'id': order.id, 'total': total})

# Single deployment
if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
```

### 1.2 Modular Monolith

**Organized internal structure**

```
Modular Monolith structure:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Monolithic App              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   API Gateway Layer          â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â” â”‚
â”‚  â”‚ User    â”‚  â”‚ Order   â”‚  â”‚Pay â”‚ â”‚
â”‚  â”‚ Module  â”‚  â”‚ Module  â”‚  â”‚mentâ”‚ â”‚
â”‚  â”‚         â”‚  â”‚         â”‚  â”‚Mod â”‚ â”‚
â”‚  â”‚ - Logic â”‚  â”‚ - Logic â”‚  â”‚ule â”‚ â”‚
â”‚  â”‚ - Data  â”‚  â”‚ - Data  â”‚  â”‚    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”˜ â”‚
â”‚       â†“            â†“          â†“    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   Database    â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Benefits:
+ Clear boundaries (modules isolated)
+ Easier to understand (domain-driven)
+ Easier to test (module-level tests)
+ Simpler than microservices (no network)
+ Path to microservices (extract modules later)

Still monolith:
- Single deployment
- Shared database (but schema per module)
- In-process communication
```

**Modular Monolith Example:**

```python
# users/service.py
class UserService:
    def __init__(self, db):
        self.db = db
    
    def create_user(self, email):
        user = User(email=email)
        self.db.session.add(user)
        self.db.session.commit()
        return user
    
    def get_user(self, user_id):
        return User.query.get(user_id)

# orders/service.py
class OrderService:
    def __init__(self, db, user_service, payment_service):
        self.db = db
        self.user_service = user_service
        self.payment_service = payment_service
    
    def create_order(self, user_id, product_ids):
        # Verify user exists (cross-module call)
        user = self.user_service.get_user(user_id)
        if not user:
            raise ValueError("User not found")
        
        # Calculate total
        products = Product.query.filter(Product.id.in_(product_ids)).all()
        total = sum(p.price for p in products)
        
        # Process payment (cross-module call)
        payment = self.payment_service.process_payment(user_id, total)
        
        # Create order
        order = Order(user_id=user_id, total=total, payment_id=payment.id)
        self.db.session.add(order)
        self.db.session.commit()
        
        return order

# payments/service.py
class PaymentService:
    def __init__(self, db):
        self.db = db
    
    def process_payment(self, user_id, amount):
        payment = Payment(user_id=user_id, amount=amount, status='success')
        self.db.session.add(payment)
        self.db.session.commit()
        return payment

# app.py (composition root)
app = Flask(__name__)
db = SQLAlchemy(app)

# Dependency injection
user_service = UserService(db)
payment_service = PaymentService(db)
order_service = OrderService(db, user_service, payment_service)

@app.route('/orders', methods=['POST'])
def create_order():
    data = request.json
    order = order_service.create_order(data['user_id'], data['product_ids'])
    return jsonify({'id': order.id})

# Still single deployment, but organized
```

### 1.3 Microservices Architecture

**Distributed, independent services**

```
Microservices structure:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ API Gateway  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â†“    â†“    â†“
â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”
â”‚User â”‚ â”‚Orderâ”‚ â”‚Pay  â”‚
â”‚Svc  â”‚ â”‚ Svc â”‚ â”‚ Svc â”‚
â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜
   â†“       â†“       â†“
â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”
â”‚User â”‚ â”‚Orderâ”‚ â”‚Pay  â”‚
â”‚ DB  â”‚ â”‚ DB  â”‚ â”‚ DB  â”‚
â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜

Characteristics:
+ Independent deployment (deploy one service)
+ Independent scaling (scale only what's needed)
+ Technology diversity (different languages)
+ Team autonomy (own service lifecycle)
+ Fault isolation (one service failure â‰  total failure)

Challenges:
- Distributed complexity (network, latency)
- Data consistency (no shared transactions)
- Testing complexity (integration tests hard)
- Operational overhead (monitoring, logging)
- Service discovery (find service locations)
```

**Microservices Example:**

```python
# User Service (port 5001)
from flask import Flask, jsonify, request

app = Flask(__name__)

@app.route('/users', methods=['POST'])
def create_user():
    data = request.json
    user = {"id": 123, "email": data['email']}
    # Save to user database
    return jsonify(user)

@app.route('/users/<user_id>', methods=['GET'])
def get_user(user_id):
    # Fetch from user database
    return jsonify({"id": user_id, "email": "john@example.com"})

if __name__ == '__main__':
    app.run(port=5001)

# Order Service (port 5002)
from flask import Flask, jsonify, request
import requests

app = Flask(__name__)

@app.route('/orders', methods=['POST'])
def create_order():
    data = request.json
    
    # Call User Service (HTTP request)
    user_response = requests.get(f'http://user-service:5001/users/{data["user_id"]}')
    user = user_response.json()
    
    # Call Payment Service (HTTP request)
    payment_response = requests.post('http://payment-service:5003/payments', json={
        'user_id': data['user_id'],
        'amount': data['total']
    })
    payment = payment_response.json()
    
    # Create order (own database)
    order = {"id": 456, "user_id": user['id'], "payment_id": payment['id']}
    return jsonify(order)

if __name__ == '__main__':
    app.run(port=5002)

# Payment Service (port 5003)
from flask import Flask, jsonify, request

app = Flask(__name__)

@app.route('/payments', methods=['POST'])
def create_payment():
    data = request.json
    payment = {"id": 789, "user_id": data['user_id'], "amount": data['amount']}
    # Save to payment database
    return jsonify(payment)

if __name__ == '__main__':
    app.run(port=5003)
```

### 1.4 Bounded Contexts (Domain-Driven Design)

**Logical boundaries between services**

```
Bounded Context: Clear boundary for a domain model

Example: E-commerce

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Catalog Context    â”‚
â”‚  - Product          â”‚  Product = catalog item
â”‚  - Category         â”‚  (name, price, description)
â”‚  - Inventory        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Order Context      â”‚
â”‚  - Order            â”‚  Product = line item
â”‚  - OrderLine        â”‚  (quantity, price at purchase)
â”‚  - Cart             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Shipping Context   â”‚
â”‚  - Shipment         â”‚  Product = physical item
â”‚  - Address          â”‚  (weight, dimensions)
â”‚  - Tracking         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Same entity (Product) has different meaning in each context!

Benefits:
+ Clear responsibilities
+ Independent evolution (change one context)
+ Avoid "God objects" (single Product class for everything)

Communication:
â”œâ”€ Each context owns its data
â”œâ”€ Communicate via well-defined APIs
â””â”€ Translate between contexts (anti-corruption layer)
```

**Bounded Context Example:**

```python
# Catalog Service (Product as catalog item)
class CatalogProduct:
    def __init__(self, id, name, price, description, stock):
        self.id = id
        self.name = name
        self.price = price
        self.description = description
        self.stock = stock
    
    def is_available(self):
        return self.stock > 0

# Order Service (Product as line item)
class OrderLineItem:
    def __init__(self, product_id, name, quantity, price_at_purchase):
        self.product_id = product_id  # Reference to catalog
        self.name = name  # Snapshot (product name at purchase)
        self.quantity = quantity
        self.price_at_purchase = price_at_purchase  # Price when ordered
    
    def total(self):
        return self.quantity * self.price_at_purchase

# Order Service creates order
def create_order(user_id, product_ids):
    order_lines = []
    
    for product_id in product_ids:
        # Fetch current product info from Catalog Service
        catalog_product = catalog_service.get_product(product_id)
        
        # Create order line (snapshot of product)
        line = OrderLineItem(
            product_id=catalog_product.id,
            name=catalog_product.name,  # Copy name (immutable)
            quantity=1,
            price_at_purchase=catalog_product.price  # Lock price
        )
        order_lines.append(line)
    
    # Even if catalog product changes (price increase), order unchanged
    order = Order(user_id=user_id, lines=order_lines)
    return order
```

---

## 2. Containers & Orchestration

### 2.1 Docker Containers

**Lightweight, portable application packaging**

```
Container vs VM:

Virtual Machine:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    App A    â”‚    App B      â”‚
â”‚  Libraries  â”‚  Libraries    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Guest OS  â”‚   Guest OS    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚      Hypervisor             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚      Host OS                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Container:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    App A    â”‚    App B      â”‚
â”‚  Libraries  â”‚  Libraries    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Container Runtime (Docker)â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚      Host OS                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Containers:
+ Lightweight (share OS kernel)
+ Fast startup (seconds vs minutes)
+ Portable (same image on dev/prod)
+ Isolated (process, filesystem, network)

VM:
+ Full isolation (separate OS)
+ More overhead (GB memory per VM)
```

**Dockerfile Example:**

```dockerfile
# Base image
FROM python:3.11-slim

# Set working directory
WORKDIR /app

# Copy requirements
COPY requirements.txt .

# Install dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Expose port
EXPOSE 5000

# Run application
CMD ["python", "app.py"]
```

**Build and Run:**

```bash
# Build image
docker build -t user-service:latest .

# Run container
docker run -d \
  --name user-service \
  -p 5001:5000 \
  -e DATABASE_URL=postgresql://db:5432/users \
  user-service:latest

# Container runs in isolation:
# - Own filesystem (from image)
# - Own network (port mapping 5001:5000)
# - Own processes (isolated from host)
```

**Docker Compose (multi-container):**

```yaml
# docker-compose.yml
version: '3.8'

services:
  user-service:
    build: ./user-service
    ports:
      - "5001:5000"
    environment:
      - DATABASE_URL=postgresql://db:5432/users
    depends_on:
      - db
  
  order-service:
    build: ./order-service
    ports:
      - "5002:5000"
    environment:
      - DATABASE_URL=postgresql://db:5432/orders
      - USER_SERVICE_URL=http://user-service:5000
    depends_on:
      - db
  
  db:
    image: postgres:15
    environment:
      - POSTGRES_USER=admin
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres-data:/var/lib/postgresql/data

volumes:
  postgres-data:
```

```bash
# Start all services
docker-compose up -d

# Scale service (run multiple instances)
docker-compose up -d --scale order-service=3

# Stop all services
docker-compose down
```

### 2.2 Kubernetes (Container Orchestration)

**Automate deployment, scaling, management of containers**

```
Kubernetes components:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Control Plane             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   API Server (kube-apiserver)â”‚  â”‚  Entry point
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   Scheduler (kube-scheduler) â”‚  â”‚  Assign pods to nodes
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   Controller Manager         â”‚  â”‚  Maintain desired state
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   etcd (distributed store)   â”‚  â”‚  Cluster state
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            Worker Nodes             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   Pod (user-service)         â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚  â”‚  Container             â”‚  â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   Pod (order-service)        â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚  â”‚  Container             â”‚  â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   kubelet (node agent)       â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Key concepts:
â”œâ”€ Pod: Smallest unit (one or more containers)
â”œâ”€ Deployment: Manage replica sets (desired state)
â”œâ”€ Service: Stable endpoint for pods (load balancing)
â”œâ”€ ConfigMap: Configuration data
â”œâ”€ Secret: Sensitive data (passwords, keys)
â””â”€ Ingress: HTTP routing (external access)
```

**Kubernetes Deployment:**

```yaml
# user-service-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-service
spec:
  replicas: 3  # Run 3 instances
  selector:
    matchLabels:
      app: user-service
  template:
    metadata:
      labels:
        app: user-service
    spec:
      containers:
      - name: user-service
        image: user-service:latest
        ports:
        - containerPort: 5000
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: url
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:  # Health check (restart if unhealthy)
          httpGet:
            path: /health
            port: 5000
          initialDelaySeconds: 10
          periodSeconds: 5
        readinessProbe:  # Ready to serve traffic
          httpGet:
            path: /ready
            port: 5000
          initialDelaySeconds: 5
          periodSeconds: 3
```

**Kubernetes Service:**

```yaml
# user-service-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: user-service
spec:
  selector:
    app: user-service
  ports:
  - protocol: TCP
    port: 80        # Service port
    targetPort: 5000  # Container port
  type: ClusterIP  # Internal only (use LoadBalancer for external)
```

**Deploy:**

```bash
# Apply deployment
kubectl apply -f user-service-deployment.yaml

# Apply service
kubectl apply -f user-service-service.yaml

# Check pods
kubectl get pods
# NAME                            READY   STATUS    RESTARTS
# user-service-5d7b8c9f4d-abc12   1/1     Running   0
# user-service-5d7b8c9f4d-def34   1/1     Running   0
# user-service-5d7b8c9f4d-ghi56   1/1     Running   0

# Scale deployment
kubectl scale deployment user-service --replicas=5

# Rolling update (zero downtime)
kubectl set image deployment/user-service user-service=user-service:v2

# Rollback
kubectl rollout undo deployment/user-service

# Check logs
kubectl logs -f user-service-5d7b8c9f4d-abc12
```

### 2.3 Service Mesh (Istio, Linkerd)

**Infrastructure layer for service-to-service communication**

```
Without Service Mesh:
Service A â†’ Service B (HTTP)
â”œâ”€ Service A implements retry logic
â”œâ”€ Service A implements circuit breaker
â”œâ”€ Service A implements metrics
â””â”€ Every service duplicates this logic

With Service Mesh:
Service A â†’ Sidecar Proxy â†’ Sidecar Proxy â†’ Service B
            (Envoy)         (Envoy)
â”œâ”€ Proxy handles retry, circuit breaking
â”œâ”€ Proxy collects metrics, traces
â”œâ”€ Service focuses on business logic
â””â”€ Consistent policies across all services

Service Mesh architecture:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Control Plane (Istio)        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   Pilot (traffic management) â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   Citadel (security/mTLS)    â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   Galley (config validation) â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â†“ (config)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Data Plane (Envoy)          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ Service A  â”‚   â”‚ Service B  â”‚   â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚  â”‚  Sidecar   â”‚ â†’ â”‚  Sidecar   â”‚   â”‚
â”‚  â”‚  (Envoy)   â”‚   â”‚  (Envoy)   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Features:
â”œâ”€ Traffic management (retry, timeout, circuit breaker)
â”œâ”€ Security (mTLS, authentication)
â”œâ”€ Observability (metrics, traces, logs)
â”œâ”€ Load balancing (client-side)
â””â”€ Service discovery
```

**Istio Example:**

```yaml
# Enable sidecar injection (automatic)
apiVersion: v1
kind: Namespace
metadata:
  name: microservices
  labels:
    istio-injection: enabled

# Traffic management (retry, timeout)
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: user-service
spec:
  hosts:
  - user-service
  http:
  - route:
    - destination:
        host: user-service
    timeout: 5s
    retries:
      attempts: 3
      perTryTimeout: 2s
      retryOn: 5xx,reset,connect-failure

# Circuit breaker
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: user-service
spec:
  host: user-service
  trafficPolicy:
    connectionPool:
      tcp:
        maxConnections: 100
      http:
        http1MaxPendingRequests: 50
        maxRequestsPerConnection: 2
    outlierDetection:  # Circuit breaker
      consecutiveErrors: 5
      interval: 30s
      baseEjectionTime: 30s
      maxEjectionPercent: 50

# mTLS (automatic encryption)
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
spec:
  mtls:
    mode: STRICT  # Require mTLS for all services
```

### 2.4 Sidecar Pattern

**Auxiliary container alongside main container**

```
Pod with sidecar:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Pod               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Main Container       â”‚  â”‚
â”‚  â”‚  (user-service)       â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Sidecar Container    â”‚  â”‚
â”‚  â”‚  (Envoy proxy)        â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Sidecar Container    â”‚  â”‚
â”‚  â”‚  (Log aggregator)     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Benefits:
+ Separation of concerns (logging, monitoring separate)
+ Reusability (same sidecar for all services)
+ Language-agnostic (sidecar in any language)
+ Hot-swappable (update sidecar independently)

Common sidecars:
â”œâ”€ Envoy proxy (service mesh)
â”œâ”€ Fluentd (log aggregation)
â”œâ”€ Prometheus exporter (metrics)
â””â”€ Cloud SQL proxy (database connection)
```

**Sidecar Example:**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: user-service-pod
spec:
  containers:
  # Main container
  - name: user-service
    image: user-service:latest
    ports:
    - containerPort: 5000
  
  # Sidecar: Envoy proxy
  - name: envoy-proxy
    image: envoyproxy/envoy:v1.28
    ports:
    - containerPort: 8001  # Admin port
    volumeMounts:
    - name: envoy-config
      mountPath: /etc/envoy
  
  # Sidecar: Log aggregator
  - name: fluentd
    image: fluent/fluentd:latest
    volumeMounts:
    - name: varlog
      mountPath: /var/log
  
  volumes:
  - name: envoy-config
    configMap:
      name: envoy-config
  - name: varlog
    emptyDir: {}
```

---

## 3. Service Communication

### 3.1 API Composition (Orchestration)

**Centralized service calls the others**

```
API Composition (synchronous):

Client â†’ API Gateway
         â†“
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    â†“         â†“
User Service  Order Service
    â†“         â†“
User DB    Order DB

API Gateway orchestrates:
1. Call User Service
2. Call Order Service
3. Combine results
4. Return to client

Benefits:
+ Simple (straightforward flow)
+ Consistent (single entry point)
+ Easy error handling (centralized)

Drawbacks:
- Tight coupling (gateway knows all services)
- Single point of failure (gateway down = all down)
- Higher latency (sequential calls)
```

**API Composition Example:**

```python
# API Gateway
from flask import Flask, jsonify
import requests

app = Flask(__name__)

@app.route('/api/user-profile/<user_id>')
def get_user_profile(user_id):
    # Call User Service
    user_response = requests.get(f'http://user-service/users/{user_id}')
    user = user_response.json()
    
    # Call Order Service
    orders_response = requests.get(f'http://order-service/orders?user_id={user_id}')
    orders = orders_response.json()
    
    # Call Payment Service
    payments_response = requests.get(f'http://payment-service/payments?user_id={user_id}')
    payments = payments_response.json()
    
    # Compose response
    profile = {
        'user': user,
        'orders': orders,
        'payments': payments
    }
    
    return jsonify(profile)

# Parallel calls (faster)
from concurrent.futures import ThreadPoolExecutor

@app.route('/api/user-profile-parallel/<user_id>')
def get_user_profile_parallel(user_id):
    def fetch_user():
        return requests.get(f'http://user-service/users/{user_id}').json()
    
    def fetch_orders():
        return requests.get(f'http://order-service/orders?user_id={user_id}').json()
    
    def fetch_payments():
        return requests.get(f'http://payment-service/payments?user_id={user_id}').json()
    
    # Execute in parallel
    with ThreadPoolExecutor(max_workers=3) as executor:
        user_future = executor.submit(fetch_user)
        orders_future = executor.submit(fetch_orders)
        payments_future = executor.submit(fetch_payments)
        
        # Wait for all results
        profile = {
            'user': user_future.result(),
            'orders': orders_future.result(),
            'payments': payments_future.result()
        }
    
    return jsonify(profile)
```

### 3.2 Choreography (Event-Driven)

**Services react to events (decoupled)**

```
Choreography (asynchronous):

Order Service â†’ Event Bus â†’ Payment Service
                â†“
             Shipping Service

Flow:
1. Order Service: Create order â†’ Publish "OrderCreated" event
2. Payment Service: Listen "OrderCreated" â†’ Process payment â†’ Publish "PaymentCompleted"
3. Shipping Service: Listen "PaymentCompleted" â†’ Ship order â†’ Publish "OrderShipped"

Benefits:
+ Decoupled (services don't know each other)
+ Scalable (add services without changing others)
+ Fault tolerant (service down = event queued)

Drawbacks:
- Complex flow (no single place to see workflow)
- Hard to debug (distributed tracing needed)
- Eventual consistency (not immediate)
```

**Choreography Example:**

```python
# Order Service (publish events)
import pika
import json

def publish_event(event_type, data):
    connection = pika.BlockingConnection(pika.ConnectionParameters('rabbitmq'))
    channel = connection.channel()
    
    # Declare exchange (topic)
    channel.exchange_declare(exchange='events', exchange_type='topic')
    
    # Publish event
    channel.basic_publish(
        exchange='events',
        routing_key=event_type,
        body=json.dumps(data)
    )
    
    connection.close()

@app.route('/orders', methods=['POST'])
def create_order():
    data = request.json
    
    # Create order
    order = {"id": 123, "user_id": data['user_id'], "total": 100}
    db.orders.insert_one(order)
    
    # Publish event
    publish_event('order.created', {
        'order_id': order['id'],
        'user_id': order['user_id'],
        'total': order['total']
    })
    
    return jsonify(order)

# Payment Service (listen events)
def handle_order_created(ch, method, properties, body):
    event = json.loads(body)
    
    # Process payment
    payment = {
        'order_id': event['order_id'],
        'amount': event['total'],
        'status': 'success'
    }
    db.payments.insert_one(payment)
    
    # Publish payment event
    publish_event('payment.completed', {
        'order_id': event['order_id'],
        'payment_id': payment['_id']
    })

# Subscribe to events
connection = pika.BlockingConnection(pika.ConnectionParameters('rabbitmq'))
channel = connection.channel()
channel.exchange_declare(exchange='events', exchange_type='topic')

# Create queue
result = channel.queue_declare(queue='payment-service', exclusive=True)
queue_name = result.method.queue

# Bind queue to event
channel.queue_bind(exchange='events', queue=queue_name, routing_key='order.created')

# Consume events
channel.basic_consume(queue=queue_name, on_message_callback=handle_order_created, auto_ack=True)
channel.start_consuming()

# Shipping Service (listen payment events)
def handle_payment_completed(ch, method, properties, body):
    event = json.loads(body)
    
    # Ship order
    shipment = {
        'order_id': event['order_id'],
        'status': 'shipped'
    }
    db.shipments.insert_one(shipment)
    
    # Publish shipping event
    publish_event('order.shipped', {
        'order_id': event['order_id'],
        'tracking_number': shipment['tracking_number']
    })

# Subscribe to payment events
channel.queue_bind(exchange='events', queue='shipping-service', routing_key='payment.completed')
channel.basic_consume(queue='shipping-service', on_message_callback=handle_payment_completed, auto_ack=True)
channel.start_consuming()
```

### 3.3 Saga Pattern

**Distributed transactions across services**

```
Problem: No distributed ACID transactions
â”œâ”€ Microservices have separate databases
â”œâ”€ Can't use database transactions across services
â””â”€ Need coordinated rollback on failure

Saga: Sequence of local transactions
â”œâ”€ Each step is local transaction (atomic)
â”œâ”€ If step fails, compensate previous steps (undo)
â””â”€ Eventual consistency (not immediate)

Two types:
1. Choreography Saga (event-driven)
2. Orchestration Saga (centralized coordinator)
```

**Choreography Saga:**

```
Create Order Saga (event-driven):

Success flow:
1. Order Service: Create order â†’ Publish "OrderCreated"
2. Payment Service: Charge card â†’ Publish "PaymentCompleted"
3. Inventory Service: Reserve items â†’ Publish "InventoryReserved"
4. Shipping Service: Ship order â†’ Publish "OrderShipped"

Failure flow (inventory out of stock):
1. Order Service: Create order â†’ Publish "OrderCreated"
2. Payment Service: Charge card â†’ Publish "PaymentCompleted"
3. Inventory Service: Reserve items FAILS â†’ Publish "InventoryFailed"
4. Payment Service: Listen "InventoryFailed" â†’ Refund â†’ Publish "PaymentRefunded"
5. Order Service: Listen "InventoryFailed" â†’ Cancel order â†’ Publish "OrderCancelled"

Compensating transactions (undo):
â”œâ”€ Payment: Refund
â”œâ”€ Inventory: Release reservation
â””â”€ Order: Cancel order
```

**Choreography Saga Example:**

```python
# Order Service
@app.route('/orders', methods=['POST'])
def create_order():
    order = {"id": 123, "status": "pending"}
    db.orders.insert_one(order)
    
    publish_event('order.created', {'order_id': order['id'], 'total': 100})
    return jsonify(order)

def handle_inventory_failed(event):
    # Compensate: Cancel order
    db.orders.update_one(
        {'_id': event['order_id']},
        {'$set': {'status': 'cancelled'}}
    )
    publish_event('order.cancelled', {'order_id': event['order_id']})

# Payment Service
def handle_order_created(event):
    # Charge card
    payment = {'order_id': event['order_id'], 'amount': event['total'], 'status': 'success'}
    db.payments.insert_one(payment)
    
    publish_event('payment.completed', {'order_id': event['order_id']})

def handle_inventory_failed(event):
    # Compensate: Refund
    payment = db.payments.find_one({'order_id': event['order_id']})
    db.payments.update_one(
        {'_id': payment['_id']},
        {'$set': {'status': 'refunded'}}
    )
    publish_event('payment.refunded', {'order_id': event['order_id']})

# Inventory Service
def handle_payment_completed(event):
    # Reserve items
    if not has_stock(event['order_id']):
        # Failure: Publish failure event
        publish_event('inventory.failed', {'order_id': event['order_id']})
        return
    
    reserve_items(event['order_id'])
    publish_event('inventory.reserved', {'order_id': event['order_id']})
```

**Orchestration Saga:**

```
Orchestration Saga (centralized):

Saga Orchestrator coordinates all steps

Success flow:
1. Orchestrator â†’ Order Service: Create order
2. Orchestrator â†’ Payment Service: Charge card
3. Orchestrator â†’ Inventory Service: Reserve items
4. Orchestrator â†’ Shipping Service: Ship order
5. Orchestrator: Mark saga complete

Failure flow (inventory fails):
1. Orchestrator â†’ Order Service: Create order âœ“
2. Orchestrator â†’ Payment Service: Charge card âœ“
3. Orchestrator â†’ Inventory Service: Reserve items âœ— (FAILS)
4. Orchestrator â†’ Payment Service: Refund (compensate)
5. Orchestrator â†’ Order Service: Cancel order (compensate)
6. Orchestrator: Mark saga failed

Benefits:
+ Centralized logic (easy to understand flow)
+ Easy to track state (single place)
+ Easy to add steps (modify orchestrator)

Drawbacks:
- Single point of failure (orchestrator down)
- Orchestrator knows all services (coupling)
```

**Orchestration Saga Example:**

```python
# Saga Orchestrator
class OrderSaga:
    def __init__(self, order_data):
        self.order_data = order_data
        self.order_id = None
        self.payment_id = None
        self.state = 'started'
    
    def execute(self):
        try:
            # Step 1: Create order
            self.order_id = self.create_order()
            
            # Step 2: Process payment
            self.payment_id = self.process_payment()
            
            # Step 3: Reserve inventory
            self.reserve_inventory()
            
            # Step 4: Ship order
            self.ship_order()
            
            self.state = 'completed'
            return {'status': 'success', 'order_id': self.order_id}
        
        except InventoryError as e:
            # Compensate (rollback)
            self.compensate()
            self.state = 'failed'
            return {'status': 'failed', 'reason': str(e)}
    
    def create_order(self):
        response = requests.post('http://order-service/orders', json=self.order_data)
        return response.json()['id']
    
    def process_payment(self):
        response = requests.post('http://payment-service/payments', json={
            'order_id': self.order_id,
            'amount': self.order_data['total']
        })
        return response.json()['id']
    
    def reserve_inventory(self):
        response = requests.post('http://inventory-service/reservations', json={
            'order_id': self.order_id,
            'items': self.order_data['items']
        })
        
        if response.status_code != 200:
            raise InventoryError("Out of stock")
    
    def ship_order(self):
        requests.post('http://shipping-service/shipments', json={
            'order_id': self.order_id
        })
    
    def compensate(self):
        """Rollback all completed steps"""
        # Refund payment
        if self.payment_id:
            requests.post(f'http://payment-service/payments/{self.payment_id}/refund')
        
        # Cancel order
        if self.order_id:
            requests.delete(f'http://order-service/orders/{self.order_id}')

# API endpoint
@app.route('/api/checkout', methods=['POST'])
def checkout():
    saga = OrderSaga(request.json)
    result = saga.execute()
    return jsonify(result)

# Saga state tracking (database)
class SagaState:
    def __init__(self, saga_id, saga_type):
        self.saga_id = saga_id
        self.saga_type = saga_type
        self.state = 'started'
        self.steps = []
    
    def add_step(self, step_name, status, data=None):
        self.steps.append({
            'step': step_name,
            'status': status,  # 'completed', 'failed'
            'timestamp': datetime.utcnow(),
            'data': data
        })
        db.saga_states.update_one(
            {'_id': self.saga_id},
            {'$set': {'steps': self.steps}}
        )
    
    def mark_completed(self):
        self.state = 'completed'
        db.saga_states.update_one(
            {'_id': self.saga_id},
            {'$set': {'state': 'completed'}}
        )
    
    def mark_failed(self):
        self.state = 'failed'
        db.saga_states.update_one(
            {'_id': self.saga_id},
            {'$set': {'state': 'failed'}}
        )
```

---

## Best Practices Summary

```
Architecture Evolution:
âœ“ Start with monolith (simple, proven domain)
âœ“ Modular monolith first (organize before splitting)
âœ“ Extract microservices when needed (independent scaling, team autonomy)
âœ“ Define bounded contexts (clear domain boundaries)
âœ“ Avoid premature microservices (complexity without benefit)
âœ— Don't split too early (overhead > benefit)
âœ— Don't create "distributed monolith" (shared database, tight coupling)

Containers & Orchestration:
âœ“ Use Docker for consistent environments (dev/prod parity)
âœ“ One process per container (single responsibility)
âœ“ Kubernetes for production (auto-scaling, self-healing)
âœ“ Resource limits (prevent resource exhaustion)
âœ“ Health checks (liveness, readiness probes)
âœ“ Service mesh for cross-cutting concerns (retry, circuit breaker, mTLS)
âœ— Don't run databases in containers (use managed services)
âœ— Don't store state in containers (use volumes, external storage)

Service Communication:
âœ“ API composition for read-heavy (simple aggregation)
âœ“ Choreography for event-driven (decoupled, scalable)
âœ“ Saga for distributed transactions (compensating transactions)
âœ“ Idempotent operations (safe to retry)
âœ“ Circuit breakers (prevent cascading failures)
âœ“ Timeouts (fail fast, don't wait forever)
âœ“ Async communication for long-running operations
âœ— Don't create chatty APIs (too many calls)
âœ— Don't ignore failures (implement fallbacks)
âœ— Don't use distributed transactions (2PC too slow, complex)

Bounded Contexts:
âœ“ One service per bounded context (clear ownership)
âœ“ Domain events for communication (loose coupling)
âœ“ Anti-corruption layer (translate between contexts)
âœ“ Shared nothing architecture (no shared database)
âœ— Don't create "God services" (too many responsibilities)
âœ— Don't share database tables (tight coupling)

Monitoring & Observability:
âœ“ Distributed tracing (request flow across services)
âœ“ Centralized logging (aggregate logs from all services)
âœ“ Metrics per service (RED: Rate, Errors, Duration)
âœ“ Service mesh observability (automatic instrumentation)
âœ— Don't deploy without monitoring (blind to failures)
âœ— Don't ignore latency (network calls add overhead)
```

Complete architecture evolution foundation! ğŸ—ï¸ğŸ³â˜¸ï¸